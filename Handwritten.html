<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<style>
  .container {
    overflow: hidden;
  }

  .middle,
  .left,
  .right {
    float: left;
    height: 100px;
  }

  .left {
    width: 100px;
    background: red;
    margin-left: -100%;
  }

  .right {
    width: 100px;
    background: blue;
    margin-left: -100px;
  }

  .middle {
    width: 100%;
    background: aqua;
  }

  .inner {
    margin: 0 100px;
  }

  img {

    background: #F1F1FA;

    width: 400px;

    height: 300px;

    display: block;

    margin: 10px auto;

    border: 0;

  }
</style>

<body>
  <!-- 圣杯布局 -->
  <div class="container">
    <div class="middle">
      <div class="inner">middle</div>
    </div>
    <div class="left">left</div>
    <div class="right">right</div>
  </div>
  <!-- 手写图片的懒加载 -->
  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image1.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image2.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image3.jpg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image2.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image3.jpg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image4.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image5.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image6.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image7.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image8.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image9.jpeg?tr=w-400,h-300" />

  <img class="lazy" data-src="https://ik.imagekit.io/demo/img/image10.jpeg?tr=w-400,h-300" />
  <script>
    //手写图片懒加载
    //图片出现在视窗内的情况： offsetTop < clientHeight + scrollTop
    //element.getBoundingClientRect().top < clientHeight
    // h5的IntersectionObserver方式
    // intersectionRatio：目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1 ，完全不可见时小于等于 0
    // function lazyload() {
    //   let imgs = document.querySelectorAll("img.lazy")  //伪数组
    //   let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    //   let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
    //   for (let i = 0; i < imgs.length; i++) {
    //     if (imgs[i].offsetTop < clientHeight + scrollTop) {
    //       imgs[i].setAttribute('src', imgs[i].dataset.src)
    //     }
    //   }
    // }
    // document.addEventListener("scroll", lazyload);

    // window.addEventListener("resize", lazyload);

    // window.addEventListener("orientationChange", lazyload);
    // function lazyload() {
    //   let imgs = document.querySelectorAll("img.lazy")  //伪数组
    //   let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
    //   // let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
    //   for (let i = 0; i < imgs.length; i++) {
    //    // console.log(i,imgs[i].getBoundingClientRect().top)
    //     if (imgs[i].getBoundingClientRect().top < clientHeight) {
    //       imgs[i].setAttribute('src', imgs[i].dataset.src)
    //     }
    //   }
    // }
    //  document.addEventListener("scroll", lazyload);

    // window.addEventListener("resize", lazyload);

    // window.addEventListener("orientationChange", lazyload);
    function lazyload() {
      let imgs = document.querySelectorAll("img.lazy") //伪数组
      let io = new IntersectionObserver(function (changes) {
        // console.log(changes,'IntersectionObserver')
        changes.forEach(function (change) {
          if (change.intersectionRatio > 0) {
            let img = change.target;
            img.src = img.dataset.src;
            io.unobserve(img);
          }
        })
      })
      for (let i = 0; i < imgs.length; i++) {
        io.observe(imgs[i])
      }
    }
    //优点:不需要绑定window事件  自带防抖  可以反向懒加载  缺点:兼容性
    lazyload()
    //手写call,apply,bind
    Function.prototype.myCall = function () {
      let obj = Array.from(arguments)[0]
      let args = Array.from(arguments).slice(1)
      let symbol = new Symbol()
      if (obj === undefined || obj === null) {
        obj = window
      } else {
        obj[symbol] = this
      }
      let result = obj[symbol](...arg)
      delete obj[symbol]
      return result
    }
    Function.prototype.myApply = function () {
      let obj = Array.from(arguments)[0]
      let args = Array.from(arguments).slice(1)
      let symbol = new Symbol()
      if (obj === undefined || obj === null) {
        obj = window
      } else {
        obj[symbol] = this
      }
      let result = obj[symbol](args)
      delete obj[symbol]
      return result
    }
    Function.prototype.myBind = function () {
      let obj = Array.from(arguments)[0]
      let args = Array.from(arguments).slice(1)
      if (obj === null || obj === undefined) {
        obj = window
      }
      let self = this
      return function () {
        let newArgs = Array.from(arguments)
        self.apply(obj, args.concat(newArgs))
      }
    }

    //promise封装ajax
    function Ajax(url, method, data) {
      return new Promise(function (resolve, reject) {
        let xhr = new XMLHttpRequest() || window.ActiveXObject
        xhr.open(method, url)
        xhr.send(data)
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4 && xhr.status === 200) {
            resolve(xhr.responseText)
          } else {
            reject(xhr.status)
          }
        }
      })
    }

    //图片的异步加载
    function loadImageAsync(url) {
      return new Promise(function (resolve, reject) {
        let image = new Image()
        image.src = src
        image.onload = function () {
          resolve(image)
        }
        image.onerror = function () {
          reject(new Error('此路径' + url + '的图片加载失败'))
        }
      })
    }

    //防抖
    //定时器版
    function debounce(fn, delay) {
      let timer
      return function () {
        clearTimeout(timer)
        timer = setInterval(() => {
          fn.apply(this, arguments)
        }, delay);
      }
    }
    //时间戳版
    function debounce(fn, delay) {
      let time = 0
      return function () {
        time = Date.now()
        if (Date.now() - time > delay) {
          fn.apply(this, arguments)
        }
      }
    }
    // 最后我们再思考一个小需求，
    // 我希望能取消 debounce 函数， 比如说我 debounce 的时间间隔是 10 秒钟， immediate 为 true，
    // 这样的话， 我只有等 10 秒后才能重新触发事件，
    // 现在我希望有一个按钮， 点击后， 取消防抖， 这样我再去触发， 就可以又立刻执行啦， 是不是很开心？
    // 为了这个需求， 我们写最后一版的代码：

    // 防抖终极版
    function debounce(func, wait, immediate) {
      var timeout, result;
      var debounced = function () {
        var context = this;
        var args = arguments;
        if (timeout) clearTimeout(timeout);
        if (immediate) {
          // 如果已经执行过，不再执行
          var callNow = !timeout;
          timeout = setTimeout(function () {
            timeout = null;
          }, wait)
          if (callNow) result = func.apply(context, args)
        } else {
          timeout = setTimeout(function () {
            func.apply(context, args)
          }, wait);
        }
        return result;
      };
      debounced.cancel = function () {
        clearTimeout(timeout);
        timeout = null;
      };
      return debounced;
    }
    //节流
    function throttle(fn, delay) {
      let canRun = true
      return function () {
        if (!canRun) return
        canRun = false
        setTimeout(() => {
          fn.apply(this, arguments)
          canRun = true
        }, delay);
      }
    }

    //原型链继承
    function SupType(val) {
      this.name = {
        name: val,
        sex: '男'
      }
    }

    function SubType() {
      this.sex = '女'
    }

    SubType.prototype = new SupType()
    // console.log(new SubType().name.name='徐娟')  原型链继承的缺点 引用类型会被不同的实例共享 不能向父类中传参数
    // console.log(new SubType().name)
    //call实现继承
    function Animal(name) {
      this.name = name
    }

    function Cat() {
      this.sex = '老鼠'
      Animal.call(this, '大象')
    }

    // console.log(new Cat().name)   优点: 可以向超类中传递参数   解决了原型中的引用类型被所有实例共享的问题
    //缺点:在超类的原型中的方法对子类来说是不可见的  方法都放在构造函数中复用无从谈起
    //组合继承
    function SuperType() {
      this.name = 'zc'
      this.colors = ['pink', 'blue', 'green'];
    }

    function SubType() {
      SuperType.call(this)
    }

    SubType.prototype = new SuperType()
    SubType.prototype.constructor = SubType
    let a = new SubType()
    let b = new SubType()
    //用原型链实现对原型属性和方法的继承，
    //通过借用构造函数来实现对实例属性的继承，
    //既通过在原型上定义方法来实现了函数复用，又保证了每个实例都有自己的属性。
    //无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。
    //原型式集成
    function object(o) {
      function F() { }

      F.prototype = o
      return new F()
    }

    //ECMAScript5通过新增 Object.create()方法规范了原型式继承。
    //这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象(可以覆盖原型对象上的同名属性)，
    //在传入一个参数的情况下，Object.create() 和 object() 方法的行为相同。
    //寄生式集成
    function object(o) {
      function F() { }

      F.prototype = o
      return new F()
    }

    function createAnother(original) {
      let clone = object(original)
      clone.sayHi = function () { }
      return clone
    }

    //基于 person 返回了一个新对象 -—— person2，
    //新对象不仅具有 person 的所有属性和方法，而且还有自己的 sayHi() 方法。
    //在考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。
    //使用寄生式继承来为对象添加函数，会由于不能做到函数复用而效率低下。
    //同原型链实现继承一样，包含引用类型值的属性会被所有实例共享。
    //寄生组合式集成
    function inheritPrototype(subType, superType) {
      var prototype = object(superType.prototype); //创建对象
      prototype.constructor = subType; //增强对象
      subType.prototype = prototype; //指定对象
    }

    function SuperType(name) {
      this.name = name;
      this.colors = ['pink', 'blue', 'green'];
    }

    function subType(name, age) {
      SuperType.call(this, name);
      this.age = age;
    }

    inheritPrototype(subType, SuperType);

    //手写new
    function _new(fn, ...args) {
      let obj = {}
      fn.apply(obj, args)
      fn.prototype.constructor = fn
      obj._proto_ = fn.prototype
      return obj
    }

    fn = function (val) {
      this.name = '付光雄'
      this.sex = '男'
      this.eat = val
    }
    // console.log(_new(fn,'大便'))
    //手写用递归实现一个深拷贝
    function checkedType(target) {
      return Object.prototype.toString.call(target).slice(8, -1)
    }

    function clone(target) {
      let targetType = checkedType(target)
      let result
      if (targetType === 'Array') {
        result = []
      } else if (targetType === 'Object') {
        result = {}
      } else {
        return target
      }
      for (const key in target) {
        if (target.hasOwnProperty(key)) {
          const element = target[key];
          if (checkedType(element) === 'Array' || checkedType(element) === 'Object') {
            result[key] = clone(element)
          } else {
            result[key] = element
          }
        }
      }
      return result
    }

    //手写一个柯里化
    // function curry(fn, args) {
    //     var length = fn.length; // 函数参数的长度
    //     // 闭包保存参数列表
    //     args = args || [];
    //     return function () {
    //         // 获取参数列表。
    //         var _args = args.slice(0);
    //         Array.prototype.push.apply(_args, Array.prototype.slice.call(arguments))
    //         if (_args.length < length) {
    //             // 如果传入的参数列表长度还没有超过函数定义时的参数长度，就 push 新的参数到参数列表中保存起来。
    //             // 自己调用自己，将保存的参数传递到下一个柯里化函数。
    //             return curry.call(this, fn, _args);
    //         } else {
    //             // 如果传入的参数列表长度已经超过函数定义时的参数长度，就执行。
    //             return fn.apply(this, _args);
    //         }
    //     }
    // }
    function curry(fn, ...args) {
      if (fn.length > args.length) {
        return function () {
          return curry.call(this, fn, ...args, ...arguments)
        }
      } else {
        fn(...args)
        //fn.call(this,...args)
      }
    }

    const add = curry(function (a, b, c) {
      // console.log([a, b, c].reduce((a, b) => a + b))
    })
    // add(1, 2, 3)
    // add(1, 2)(3)
    // add(1)(2)(3)
    // add(1)(2, 3)
    //手写一个双向绑定
    let vm = {} //想象成vue的实例
    let obj = { //想象成vue的data
      name: 'zc',
      age: '123'
    }
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        Object.defineProperty(vm, key, {
          get: function () {
            return obj[key]
          },
          set: function (val) {
            obj[key] = val
          }
        })
      }
    }
    obj.age = '30'
    vm.age = '112221' //触发set
    vm.age //触发get
    //手写一个双向绑定这个proxy版本
    let vm1 = new Proxy(obj, {
      get: function (target, propKey, receiver) {
        // console.log(target, propKey, receiver, '...............1')
        // console.log(Reflect.get(target, propKey, receiver), '..............11')    //112221
      },
      set: function (target, propKey, value, receiver) {
        // console.log(target, propKey, value, receiver, '...............2')
        // console.log(Reflect.set(target, propKey, value, receiver), '.............22')  //true   它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。
      }
    })
    vm1.age
    vm1.age = '30'
    //观察者模式
    // 目标者类
    class Subject {
      constructor() {
        this.observers = []; // 观察者列表
      }

      // 添加
      add(observer) {
        this.observers.push(observer);
      }

      // 删除
      remove(observer) {
        let idx = this.observers.findIndex(item => item === observer);
        idx > -1 && this.observers.splice(idx, 1);
      }

      // 通知
      notify() {
        for (let observer of this.observers) {
          observer.update();
        }
      }
    }

    // 观察者类
    class Observer {
      constructor(name) {
        this.name = name;
      }

      // 目标对象更新时触发的回调
      update() {
        // console.log(`目标者通知我更新了，我是：${this.name}`);
      }
    }

    // 实例化目标者
    let subject = new Subject();
    // 实例化两个观察者
    let obs1 = new Observer('前端开发者');
    let obs2 = new Observer('后端开发者');
    // 向目标者添加观察者
    subject.add(obs1);
    subject.add(obs2);
    // 目标者通知更新
    subject.notify();
    // 输出：
    // 目标者通知我更新了，我是前端开发者
    // 目标者通知我更新了，我是后端开发者
    //发布订阅者模式
    class Pubsub {
      list = []
      // constructor(){
      //     this.list = {}
      // }
      subscribe(event, fn) { //订阅
        if (!this.list[event]) {
          this.list[event] = []
        }
        this.list[event].push(fn)
      }

      publish(event, args) { //发布
        for (let fn of this.list[event]) {
          // console.log(fn,this)
          // fn.call(this, args)
          fn(args)
        }
      }

      unSubscribe(event) { //取消订阅
        this.list[event].length = 0
      }
    }

    let pubsub = new Pubsub()
    pubsub.subscribe('oneat', function (a) {
      // console.log(a)
    })
    pubsub.subscribe('oneat', function (a) {
      // console.log(a)
    })
    pubsub.subscribe('oneat', function (a) {
      // console.log(a)
    })
    pubsub.publish('oneat', '米饭')
    //js获取路径参数
    let test =
      '?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=21331&rsv_pq=b8627e62001efbb9&rsv_t=eef5sqIQ98s66yOwueYH5BWlFUARj0PkHBdCA4ahbSVYQA5qO9MBoZPC0mU&rqlang=cn&rsv_enter=1&rsv_dl=tb&rsv_sug3=5&rsv_sug1=1&rsv_sug7=100&rsv_sug2=0&inputT=509&rsv_sug4=509'

    function f(str) {
      let str1 = str.slice(1)
      let arr = str1.split('&')
      let map = new Map()
      arr.map(item => {
        const [key, value] = item.split('=')
        map.set(key, decodeURIComponent(value))
      })
      return map //map可以用for of遍历   遍历出的每一项是数组
    }

    for (let item of f(test)) {
      // console.log(item)
    }

    //冒泡排序最终优化版
    function bubble(arr) {
      for (let i = 0; i < arr.length; i++) {
        let Change = false
        for (let j = 0; j < arr.length - i; j++) {
          if (arr[j] > arr[j + 1]) {
            Change = true
            arr[j] = arr[j] ^ arr[j + 1]
            arr[j + 1] = arr[j] ^ arr[j + 1]
            arr[j] = arr[j + 1] ^ arr[j]
          }
        }
        if (!Change) {
          return arr
        }
      }
    }

    // console.log(bubble([1, 5, 9, 7, 5, 3, 2, 4]))
    //选择排序
    function selectSort(arr) {
      let minIndex, temp
      for (let i = 0; i < arr.length; i++) {
        minIndex = i //假设第一项是值最小的索引
        for (let j = i; j < arr.length; j++) {
          if (arr[j] < arr[minIndex]) {
            minIndex = j
          }
        }
        temp = arr[minIndex]
        arr[minIndex] = arr[i]
        arr[i] = temp
      }
      return arr
    }

    // console.log(selectSort([1, 5, 9, 7, 5, 3, 2, 4]))
    //插入排序
    function insertSort(arr) {
      if (arr.length < 2) {
        return arr
      }
      let temp, j
      for (let i = 1; i < arr.length; i++) {
        j = i
        temp = arr[i]
        // while (j > 0 && arr[j - 1] > temp) {
        //     arr[j] = arr[j - 1]
        //     j--
        // }
        for (let k = i - 1; k < i && k > -1; k--) {
          if (temp < arr[k]) {
            arr[k + 1] = arr[k]
            arr[k] = temp
          }
        }
      }
      return arr
    }

    //希尔排序 (对插入排序的升级)
    // function shellSort(arr) {
    //   let len = arr.length;
    //   // gap 即为增量
    //   for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
    //     for (let i = gap; i < len; i++) {
    //       let j = i;
    //       let current = arr[i];
    //       while (j - gap >= 0 && current < arr[j - gap]) {
    //         arr[j] = arr[j - gap];
    //         j = j - gap;
    //       }
    //       arr[j] = current;
    //     }
    //   }
    // }
    var shellSort = function () {
      if (this.array === null || this.array.length < 2) return this.array
      let length = this.array.length
      //初始化增量
      var gap = Math.floor(length / 2)
      // whlie循环
      while (gap > 1) {
        for (let i = gap; i < length; i++) {
          let temp = this.array[i]
          let j = i
          while (this.array[j - gap] > temp && j > gap - 1) {
            this.array[j] = this.array[j - gap]
            j -= gap
          }
          this.array[j] = temp
        }
        gap = Math.floor(gap / 2)
      }
    }

    // console.log(insertSort([1, 5, 9, 7, 5, 3, 2, 4]))
    //快速排序
    // 我们都知道快排的时间复杂度是 O(nlogn) ，遇到最差的情况会退化成为 O(n ^ 2) ，但什么情况最差？
    // 最差的情况：
    // 数组已经是排好序的，并且你每次基准 pivot 选的是数组最左面或者是最右面
    // 所有元素都相同
    //方法一优化版(避免每趟都选中极值)
    // 1. 快速排序如果选择的基准bai值为最小值的话，划du分的结果序列只有一个，皆位于基准值zhi的一侧（具体哪侧需要dao视序列的升序或降序情况而定）。但是其特征不变，即通过该趟排序基准值在最终序列的位置即被确定。
    // 2. 快速排序若每趟排序选取的基准值都为数组中的最小值，则其排序效率会降到最低
    // 3. 快速排序基准值的选定并非是一定的，可以采用随机选择，取中间位置、或加入其它算法进行选择，这些方式可以降低每趟皆选中极值的情况。
    function quickSort(arr, left, right) { //这个left和right代表分区后“新数组”的区间下标，因为这里没有新开数组，所以需要left/right来确认新数组的位置
      if (left < right) {
        let pos = left - 1 //pos即“被置换的位置”，第一趟为-1
        for (let i = left; i <= right; i++) { //循环遍历数组，置换元素
          let pivot = arr[right] //选取数组最后一位作为基准数，
          if (arr[i] <= pivot) { //若小于等于基准数，pos++，并置换元素, 这里使用小于等于而不是小于, 其实是为了避免因为重复数据而进入死循环
            pos++
            let temp = arr[pos]
            arr[pos] = arr[i]
            arr[i] = temp
          }
        }
        //一趟排序完成后，pos位置即基准数的位置，以pos的位置分割数组
        quickSort(arr, left, pos - 1)
        quickSort(arr, pos + 1, right)
      }
      return arr //数组只包含1或0个元素时(即left>=right)，递归终止
    }
    // //使用
    // var arr = [5, 1, 4, 2, 3]
    // var start = 0;
    // var end = arr.length - 1;
    // quickSort(arr, start, end)
    //方法二普通版
    // function quickSort(arr) {
    //   if (arr.length < 2) {
    //     return arr
    //   }
    //   let end = arr.length - 1
    //   let pivot = arr.splice(Math.floor(end / 2), 1)[0];
    //   // let base = arr[Math.floor(end / 2)]
    //   let leftArr = []
    //   let rightArr = []
    //   for (let i = 0; i < arr.length; i++) {
    //     if (arr[i] <= pivot) {
    //       leftArr.push(arr[i])
    //     } else {
    //       rightArr.push(arr[i])
    //     }
    //   }
    //   return quickSort(leftArr).concat([pivot], quickSort(rightArr))
    // }
    //方法三while版
    // var arr = [3, 3, -5, 6, 0, 2, -1, -1, 3];
    // console.log(arr);
    // quick_sort(arr, 0, arr.length - 1);
    // console.log(arr);
    /**
    题目：快速排序算法
    思路：两个哨兵，i,j,j从右边找比基数小的，i从左边找比基数大的，然后交换两个目标元素的位置，直到i=j,然后交换i和基数的位置，递归处理。
    **/
    function quickSort(arr, from, to) {
      var i = from; //哨兵i
      var j = to; //哨兵j
      var key = arr[from]; //标准值
      if (from >= to) { //如果数组只有一个元素
        return;
      }
      while (i < j) {
        while (arr[j] > key && i < j) { //从右边向左找第一个比key小的数，找到或者两个哨兵相碰，跳出循环
          j--;
        }
        while (arr[i] <= key && i <
          j) { //从左边向右找第一个比key大的数，找到或者两个哨兵相碰，跳出循环,这里的=号保证在本轮循环结束前，key的位置不变，否则的话跳出循环，交换i和from的位置的时候，from位置的上元素有可能不是key
          i++;
        }
        /**
          代码执行道这里，1、两个哨兵到找到了目标值。2、j哨兵找到了目标值。3、两个哨兵都没找到(key是当前数组最小值)
        **/
        if (i < j) { //交换两个元素的位置
          var temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;

        }
      }
      arr[from] = arr[i] //将基数与下标为 i 的元素原地交换，从而实现划分；
      arr[i] = key;
      quickSort(arr, from, i - 1);
      quickSort(arr, i + 1, to);
    }

    // arr = [2, 1, 5, 8, 3, 7, 4, 6, 9];
    // console.log(quickSort(arr)); //[1, 2, 3, 4, 5, 6, 7, 8, 9]
    //合并两个有序数组
    function Merger(a, b) {
      let len1 = a && a.length //a ?.length //链判断运算符
      let len2 = b && b.length //b ?.length
      let index1 = 0
      let index2 = 0
      let arr = []
      while (index1 < len1 && index2 < len2) { //保证有一个有序数组已经遍历完
        if (a[index1] > b[index2]) {
          arr.push(b[index2++])
        } else {
          arr.push(a[index1++])
        }
      }
      while (index1 < len1) {
        arr.push(a[index1++])
      }
      while (index2 < len2) {
        arr.push(b[index2++])
      }
      return arr
    }

    // console.log(Merger([2, 5, 9],[1,6,8,11]))  无序数组为什么不能用这个方法??
    //归并排序
    function mergeSort(arr = [1, 9, 7, 5, 6, 4, 9, 8, 1, 3]) {
      if (arr.length === 1) {
        return arr
      }
      let mid = Math.floor(arr.length / 2)
      let left = arr.slice(0, mid)
      let right = arr.slice(mid)
      // return mergeSort(left).concat(mergeSort(right))
      return Merger(mergeSort(left), mergeSort(right))
    }

    // console.log(mergeSort(),'归并排序')

    //手写迭代器
    var it = makeIterator(["a", "b"]);

    function makeIterator(arr) {
      nowIndex = 0
      return {
        next: function () {
          if (nowIndex < arr.length) {
            return {
              value: arr[nowIndex++],
              done: false
            }
          } else {
            return {
              value: undefined,
              done: true
            }
          }
        }
      }
    }

    //求数组的最大子序列和
    // dp方程 dp[n] = Math.max(dp[n - 1], 0) + a[n]

    // 解释：

    // dp[n] 表示 n 个元素里面，出现连续元素相加和的最大值。
    // dp[n - 1] 只可能有两种结果 要么大于等于 0，要么小于 0，小于择舍弃，取 a[n]。
    // /**
    //  * @param {number[]} nums
    //  * @return {number}
    //  */

    // // dp[n] n 个元素里面 出现连续元素相加和的最大值
    // // dp 方程 dp[n] = Math.max(dp[n-1], 0) + a[n]
    // // dp[n-1] 只可能有两种结果 要么大于等于 0，要么小于 0，小于择舍弃，取 a[n]
    var maxSubArray = function (nums) {
      const dp = [nums[0]]
      for (let i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1], 0) + nums[i]
      }
      return Math.max(...dp)
    }

    let arr = [1, -5, 8, 3, -4, 15, -8]

    function getNum(arr) {
      let num = arr[0]
      let max = arr[0]
      for (let i = 1; i < arr.length; i++) {
        num = (num > 0) ? arr[i] + num : arr[i]
        max = (num > max) ? num : max
        // console.log(num, max)
      }
      return max
    }

    function contMax(array) {
      if (array.length == 0)
        return 0
      var sum = array[0] //保存每组的和
      var maxSum = array[0] //连续子数组最大和
      for (var i = 1; i < array.length; i++) {
        sum = Math.max(sum + array[i], array[i]);
        maxSum = Math.max(sum, maxSum)
      }
      return maxSum
    }

    getNum(arr)

    //乘积最大子数组(连续)
    // dp 方程 dp[n] = Math.max(dp[n - 1] * nums[n], nums[n])

    // 解释

    // dp[n] 表示 n 个元素里面，出现连续元素相乘的最大乘积。
    // 该题的技巧，是注意乘积会出现 负负得正的 case ，存储上次乘积的结果 dp[n - 1] 的最大值和最小值。
    // /**
    //  * 需要考虑 负负得正的 case，需要存储存储最大值和最小值
    //  * dp[n] = Math.max(dp[n-1]*nums[n], nums[n])
    //  */

    var maxProduct = function (nums) {
      if (!nums.length) return null
      let state = [],
        max = nums[0];
      for (let i = 0; i < nums.length; i++) {
        state[i] = [0, 0];
      }

      state[0][0] = nums[0]; // 从 0 至 0 处的最大值
      state[0][1] = nums[0]; // 从 0 至 0 处的最小值

      for (let i = 1; i < nums.length; i++) {
        if (nums[i] >= 0) {
          state[i][0] = Math.max(state[i - 1][0] * nums[i], nums[i]);
          state[i][1] = Math.min(state[i - 1][1] * nums[i], nums[i]);
        } else {
          state[i][0] = Math.max(state[i - 1][1] * nums[i], nums[i]);
          state[i][1] = Math.min(state[i - 1][0] * nums[i], nums[i]);
        }
        if (max < state[i][0]) {
          max = state[i][0]
        }
      };
      return max
    }


    //实现一个EventListener类，包含on，off，emit方法
    class EventListener {
      constructor() {
        this.list = {}
      }

      on(key, fn) {
        if (!this.list[key]) {
          this.list[key] = []
        }
        this.list[key].push(fn)
      }

      emit(key, ...args) {
        for (let fn of this.list[key]) {
          fn.apply(this, args)
        }
      }

      off(key, fn) {
        let fnlist = this.list[key]
        if (!fnlist) return
        if (!fn) {
          fnlist.length = 0
        } else {
          fnlist.forEach((item, index) => {
            if (item === fn) {
              fnlist.splice(index, 1)
            }
          })
        }
      }
    }

    let obj1 = new EventListener()
    obj1.on('work', value => {
      //  console.log(`我是${value}啊`)
    })
    obj1.on('eat', value => {
      //  console.log(`我在${value}啊`)
    })
    obj1.emit('work', 'zc')
    obj1.off('eat')
    obj1.emit('eat', '吃西瓜')

    //手写一个sleep函数
    function sleep(ms) {
      return new Promise(function (resolve, reject) {
        setTimeout(() => {
          resolve('徐娟')
        }, ms);
      })
    }

    // sleep(10000).then((data) => {
    //     console.log(data)
    // })
    async function init() {
      await sleep(2000)
      // console.log('徐娟')
    }

    init()
    //手写斐波那契数列
    //递归版本
    // function getNumx(n) {
    //     if (n <= 1) {
    //         return 1
    //     }
    //     return getNumx(n - 1) + getNumx(n - 2)
    // }
    // console.log(getNumx(8))
    //动态规划版本
    // function getNumx(n) {
    //   if (n === 1 || n === 2) {
    //     return 1
    //   } else {
    //     var arr = []
    //     arr[0] = 1
    //     arr[1] = 1
    //     for (let i = 2; i < n + 1; i++) {
    //       arr[i] = arr[i - 1] + arr[i - 2]
    //     }
    //     return arr[n - 1]
    //   }
    // }
    //generator版本
    function* getNumx() {
      // let prev = 0;
      // let curr = 1
      let [prev, curr] = [0, 1]
      while (true) {
        yield curr; //后面必须有分号  不然会把curr和 [prev, curr] = [curr, prev + curr];都当做yeild后面的内容
        // let temp = curr
        // curr = curr + prev
        // prev = temp
        [prev, curr] = [curr, prev + curr];
      }
      // for (; ;) {
      //   yield curr
      //   let temp = curr
      //   curr = curr + prev
      //   prev = temp
      // }
    }
    for (let a of getNumx()) {
      if (a > 1000) {
        break
      }
      //console.log(a)
    }
    // console.log(getNumx(8))
    //求一个数组的最小子元素和
    //[1, -5, 8, 3, -4, 15, -8]
    function mostMin(arr) {
      let sum, min;
      sum = arr[0],
        min = arr[0]
      for (let i = 1; i < arr.length; i++) {
        sum = Math.min(arr[i], sum + arr[i])
        min = Math.min(sum, min)
      }
      // console.log(min)
    }

    mostMin([1, -5, -5, 8, 3, -4, 15, -8])
    //删除字符串中的所有相邻重复项
    // 输入："abbaca"   运用了栈的思想
    // 输出："ca"
    function removeDuplicates(str = 'abbaca') {
      let arr = [];
      for (let i = 0; i < str.length; i++) {
        if (i === 0) {
          arr.push(str.charAt(i))
        } else {
          if (arr[arr.length - 1] === str.charAt(i)) {
            arr.pop()
          } else {
            arr.push(str.charAt(i))
          }
        }
      }
      return arr.join(',')
    }

    removeDuplicates('abbaca')
    // 只包含'(', ')', '[', ']', '{', '}' 的字符串，判断是否有效。
    var isValid = function (s) {
      var rightSymbols = [];
      for (var i = 0; i < s.length; i++) {
        if (s[i] == "(") {
          rightSymbols.push(")");
        } else if (s[i] == "{") {
          rightSymbols.push("}");
        } else if (s[i] == "[") {
          rightSymbols.push("]");
        } else if (rightSymbols.pop() != s[i]) {
          return false;
        }
      }
      return !rightSymbols.length;
    };
    //数组中只出现一次的数字
    // let arr = [1, 2, 3, 4, 3, 2, 1]
    // const p = arr.reduce((a, b) => {
    //     return a ^ b
    // })
    //求数组的最大深度
    let dep = 1
    // function getDep(arr = [         这种方法不可取  因为不知道深度较深的子数组是不是排在前面
    //     [1], 1, [1, [3], 2], 2, 3, 4
    // ]) {
    //     let indexArr = []
    //     if (Array.isArray(arr)) {
    //         indexArr.push(dep++)
    //     }
    //     for (const item of arr) {
    //         if (Array.isArray(item)) {
    //             // dep++
    //             return getDep(item)
    //         }
    //     }
    // }
    // getDep()
    // console.log(dep)
    function getDep(arr = [
      [1], 1, [1, [3], 2], 2, 3, 4
    ]) {
      let hasChildArr = false
      hasChildArr = arr.some(function (item) {
        return Array.isArray(item)
      })
      if (hasChildArr) {
        dep++
        getDep(arr.flat())
      } else {
        return dep
      }
    }

    getDep()
    //数组拉平
    // function flat(arr = [
    //     [1], 1, [1, [3], 2], 2, 3, 4
    // ]) {
    //     let flatArr = [];
    //     let hasChildArr = false;
    //     for (let a of arr) {
    //         if (Array.isArray(a)) {
    //             hasChildArr = true
    //             flatArr.push(...a)
    //         } else {
    //             flatArr.push(a)
    //         }
    //     }
    //     if (!hasChildArr) {
    //         console.log(flatArr)
    //     } else {
    //         flat(flatArr)
    //     }
    // }
    // function flat(arr = [1, 2, [3, 4, 5, [6, 7, 8], 9], 10, [11, 12]]) {
    //     let flatArr = []
    //     arr.forEach(item => {
    //         if (Array.isArray(item)) {
    //             flatArr.concat(flat(item))
    //         } else {
    //             flatArr.push(item)
    //         }
    //     })
    //     console.log(flatArr)
    // }
    function flat(arr = [1, 2, [3, 4, 5, [6, 7, 8], 9], 10, [11, 12]]) {
      return arr.reduce(function (prev, cur, index, arr) {
        return Array.isArray(cur) ? prev.concat(flat(cur)) : [...prev, cur]
      }, [])
    }

    // console.log(flat())
    let arr1 = [1, 2, [3, 4, 5, [6, 7, 8], 9], 10, [11, 12]].toString().split(',').map((val) => {
      return parseInt(val)
    })

    //单例模式的两种实现
    function SingleTon() {
      if (SingleTon.instance) {
        return SingleTon.instance
      }
      this.name = '徐娟'
      // console.log(this)
      SingleTon.instance = this
    }
    class SingletonApple {
      constructor(name, creator, products) {
        this.name = name;
        this.creator = creator;
        this.products = products;
      }
      //静态方法
      static getInstance(name, creator, products) {
        if (!this.instance) {
          this.instance = new SingletonApple(name, creator, products);
        }
        return this.instance;
      }
    }

    // let appleCompany = SingletonApple.getInstance('苹果公司', '乔布斯', ['iPhone', 'iMac', 'iPad', 'iPod']);
    // let copyApple = SingletonApple.getInstance('苹果公司', '阿辉', ['iPhone', 'iMac', 'iPad', 'iPod'])

    // console.log(appleCompany === copyApple); //true
    // console.log(new SingleTon() === new SingleTon())
    let single = (function single() {
      let instance

      function Single() { }

      return function () {
        if (instance) {
          return instance
        }
        instance = new Single()
        return instance
      }
    })()
    // console.log(single() === single())
    //命令模式
    class Receiver { // 接收者类
      execute() {
        // console.log('接收者执行请求');
      }
    }

    class Command { // 命令对象类
      constructor(receiver) {
        this.receiver = receiver;
      }

      execute() { // 调用接收者对应接口执行
        //  console.log('命令对象->接收者->对应接口执行');
        this.receiver.execute();
      }
    }

    class Invoker { // 发布者类
      constructor(command) {
        this.command = command;
      }

      invoke() { // 发布请求，调用命令对象
        //  console.log('发布者发布请求');
        this.command.execute();
      }
    }

    const warehouse = new Receiver(); // 仓库
    const order = new Command(warehouse); // 订单
    const client = new Invoker(order); // 客户
    client.invoke();
    //手写promise
    let MyPromise = (function () {
      function resolve(res) {
        //如果存在状态就直接return
        if (this['[[PromiseStatus]]'] !== 'pending') return
        this['[[PromiseStatus]]'] = 'resolved'
        this['[[PromiseValue]]'] = res
        if (this.callBacks.length > 0) {
          let timer = setTimeout(() => {
            this.callBacks.forEach(
              //   {
              //   onFulfilled
              // } => {
              //   onFulfilled(res)  //报错箭头函数的参数不能用解构???
              // }
              value => {
                // console.log(value,'value1')
                value.onFulfilled(res)
              }
            );
            clearTimeout(timer)
          }, 0);
        }
      }

      function reject(res) {
        if (this['[[PromiseStatus]]'] !== 'pending') return
        this['[[PromiseStatus]]'] = 'rejected'
        this['[[PromiseValue]]'] = res
        if (this.callBacks.length > 0) {
          let timer = setTimeout(() => {
            this.callBacks.forEach(value => {
              // console.log(value,'value2')
              value.onRejected(res)
            })
            clearTimeout(timer)
          }, 0);
        }
      }

      return function (fn) {
        this['[[PromiseStatus]]'] = 'pending'
        this['[[PromiseValue]]'] = undefined
        this.callBacks = [] // 每个元素的结构：{ onFulfilled(){}, onRejected(){}}
        try { //立刻同步执行 如果执行器抛出异常，promise对象变为 rejected 状态
          fn(resolve.bind(this), reject.bind(this))
        } catch (e) {
          // console.log(e, 'eeeeeeeeeeee')
          reject.bind(this)(e)
        }
      }
    })()
    MyPromise.prototype.then = function (onFulfilled, onRejected) {
      // console.log(onFulfilled, onRejected, 'fulfilled&&rejected0')
      onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =>
        value //当then里面的函数不传的时候  为下一个then能接受到参数准备的
      onRejected = typeof onRejected === 'function' ? onRejected : err => { //就是为了防止callbacks调用foreach报错
        throw err
      }
      // console.log(onFulfilled, onRejected, 'fulfilled&&rejected1')
      let that = this
      return new MyPromise(function (resolve, reject) {
        //1. 如果抛出异常，return 的promise就会失败，reason 就是 error
        //2. 如果回调函数返回的不是promise，return的promise就会成功，value就是返回的值
        //3.如果回调函数返回的是promise，return的promise的结果就是这个promise的结果
        function handle(callback) { //处理上一个then的返回值
          try {
            const result = callback(that['[[PromiseValue]]'])
            if (result instanceof MyPromise) {
              result.then(
                value => resolve(value), //当result成功时，让return的promise也成功
                reason => reject(reason) //当result失败时，让return的promise也失败
              )
              // result.then(resolve, reject)
            } else {
              resolve(result)
            }
          } catch (error) {
            // 如果抛出异常，return 的promise就会失败，reason 就是 error
            reject(error)
          }
        }

        if (that['[[PromiseStatus]]'] === 'pending') {
          that.callBacks.push({
            onFulfilled(value) {
              handle(onFulfilled) //修改promise的状态为onFulfilled状态
            },
            onRejected(reason) {
              handle(onRejected) //修改promise的状态为onRejected状态
            }
          })
        } else if (that['[[PromiseStatus]]'] === 'resolved') {
          setTimeout(() => {
            handle(onFulfilled)
          }, 0);
        } else {
          setTimeout(() => {
            handle(onRejected)
          }, 0);
        }
      })
    }
    MyPromise.prototype.catch = function (onRejected) {
      return this.then(undefined, onRejected)
    }
    MyPromise.prototype.finally = function (callback) {
      let P = this.constructor;
      return this.then(
        value => P.resolve(callback()).then(() => value),
        reason => P.resolve(callback()).then(() => {
          throw reason
        })
      );
    };
    // 向 Promise.prototype 增加 finally()
    // Promise.prototype.finally = function (onFinally) {
    //   return this.then(
    //     /* onFulfilled */
    //     res => Promise.resolve(onFinally()).then(() => res),
    //     /* onRejected */
    //     err => Promise.resolve(onFinally()).then(() => {
    //       throw err;
    //     })
    //   );
    // };
    MyPromise.resolve = function (result) {
      return new MyPromise(function (resolve, reject) {
        resolve(result)
      })
    }
    MyPromise.reject = function (result) {
      return new MyPromise(function (resolve, reject) {
        reject(result)
      })
    }
    MyPromise.all = function (promiseArr = []) {
      return new Promise((resolve, reject) => {
        let index = 0;
        let arr = []
        for (let i = 0; i < promiseArr.length; i++) {
          promiseArr[i].then(result => {
            index++
            arr[i] = result
            if (index === promiseArr.length) {
              resolve(arr)
            }
          }, reason => {
            reject(reason)
          })
        }
      })
    }
    // Promise.race = function (promises) {
    //   if (!Array.isArray(promises)) {
    //     throw new TypeError('You must pass array')
    //   }

    //   return new Promise(function (resolve, reject) {
    //     function resolver(value) {
    //       resolve(value)
    //     }

    //     function rejecter(reason) {
    //       reject(reason)
    //     }

    //     for (var i = 0; i < promises.length; i++) {
    //       promises[i].then(resolver, rejecter)
    //     }
    //   })
    // }

    MyPromise.race = function (promises) {
      return new Promise((resolve, reject) => {
        for (let i = 0; i < promises.length; i++) {
          promises[i].then(resolve, reject)
        };
      })
    }
    let p = new MyPromise(function (resolve, reject) {
      resolve(1)
    }).then(() => {
      return 6 //识别到是个数字就改变了PromiseValue
    }).finally(() => {
      //  console.log('finally1')
    }).then().then(res => {
      //  console.log(res, 'res')
    }).catch(e => {
      //  console.log(e, 'error')
    }).finally(() => {
      // console.log('finally2')
    })

    //手写instanceOf
    function instance(left, right) {
      // if (left._proto_ = right.prototype) {
      //     return true
      // }
      left = left._proto_;
      right = right.prototype;
      while (true) {
        if (left === null) {
          return false
        }
        if (left === right) {
          return true
        }
        left = left._proto_
      }
    }

    //二叉树相关
    //构造一个二叉树
    function BinaryTree() {
      function Node(val) {
        this.value = val
        this.left = null
        this.right = null
      }

      this.root = null
      this.append = function (val) {
        function insertNode(val, root) {
          if (val > root.value) {
            if (root.right === null) {
              root.right = new Node(val)
            } else {
              insertNode(val, root.right)
            }
          }
          // else {                   //相同数值的节点能插进去
          //     if (root.left === null) {
          //         root.left = new Node(val)
          //     } else {
          //         insertNode(val, root.left)
          //     }
          // }
          if (val < root.value) { //相同的数值的节点不能插进去
            if (root.left === null) {
              root.left = new Node(val)
            } else {
              insertNode(val, root.left)
            }
          }
        }

        if (this.root === null) {
          this.root = new Node(val)
        } else {
          insertNode(val, this.root)
        }
      }
    }

    let Binary = new BinaryTree()
    Binary.append(8)
    Binary.append(6)
    Binary.append(7)
    Binary.append(9)
    Binary.append(4)
    Binary.append(2)
    Binary.append(10)
    Binary.append(11)
    Binary.append(5)
    Binary.append(4)
    Binary.append(4)
    Binary.append(4)
    Binary.append(4)
    Binary.append(4)
    Binary.append(4)
    Binary.append(4)
    Binary.append(4)
    // console.log(Binary.root, '二叉树')
    //求二叉树的节点数
    // let nodeNum = 0
    // function getNodenum(root) {
    //     if (root === null) return
    //     nodeNum++
    //     getNodenum(root.right)
    //     getNodenum(root.left)
    //     return nodeNum
    // }
    function getNodenum(root) {
      if (root === null) {
        return 0
      }
      let leftNum = getNodenum(root.left)
      let rightNum = getNodenum(root.right)
      return leftNum + rightNum + 1
    }

    // console.log(getNodenum(Binary.root), '二叉树的节点数')

    //求二叉树的最大深度
    function maxDepth(root) {
      if (root === null) {
        return 0
      }
      let leftDepth = maxDepth(root.left)
      let rightDepth = maxDepth(root.right)
      return Math.max(leftDepth, rightDepth) + 1
    }

    function getBinaryTreeHeigth(node) {
      if (!node) {
        return 0;
      }
      const queue = [node];
      let deep = 0;
      while (queue.length) {
        deep++;
        for (let i = 0; i < queue.length; i++) {
          const cur = queue.pop();
          if (cur.l) {
            queue.unshift(cur.l);
          }
          if (cur.r) {
            queue.unshift(cur.r);
          }
        }
      }
      return deep;
    }

    // console.log(maxDepth(Binary.root), '二叉树最大深度')
    //二叉树的最小深度
    // 1.如果根节点为空，则最小深度为0
    // 2.如果只有一个根节点(根节点的左右子树为空)，则最小深度为1
    // 3.如果左子树为空，右子树不为空，最小深度为1+右子树的最小深度
    // 4.如果右子树为空，左子树不为空，最小深度为1+左子树的最小深度
    // 5.如果左右子树都不为空，则最小深度为1+左右子树最小深度中的较小值
    var minDepth = function (root) {
      if (!root) {
        return 0;
      }
      if (!root.left) {
        return minDepth(root.right) + 1;
      }
      if (!root.right) {
        return minDepth(root.left) + 1;
      }
      return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    };
    //  console.log(minDepth(Binary.root), '二叉树最小深度')

    //二叉树的前中后序遍历
    function preTraverse(root) {
      if (root === null) {
        return
      }
      // console.log(root.value, '前序遍历')
      preTraverse(root.left)
      preTraverse(root.right)
    }

    preTraverse(Binary.root)

    function middleTraverse(root) {
      if (root === null) {
        return
      }
      middleTraverse(root.left)
      // console.log(root.value, '中序遍历')
      middleTraverse(root.right)
    }

    middleTraverse(Binary.root)

    function lastTraverse(root) {
      if (root === null) {
        return
      }
      lastTraverse(root.left)
      lastTraverse(root.right)
      //  console.log(root.value, '后序遍历')
    }

    lastTraverse(Binary.root)

    //分层遍历（非递归）  有待进一步研究
    function bfs(root) {
      let queue = [],
        result = []
      if (root !== null) {
        queue.push(root)
      }
      let pointer = 0
      while (pointer < queue.length) {
        let temp = queue[pointer++]
        result.push(temp.value)
        temp.left && queue.push(temp.left)
        temp.right && queue.push(temp.right)
      }
      return result
    }

    // console.log(bfs(Binary.root), '分层遍历')

    //二叉树的第k层的节点数
    function getknum(root, k) {
      if (root === null) {
        return 0
      }
      if (root !== null && k === 1) {
        return 1
      }
      return getknum(root.left, k - 1) + getknum(root.right, k - 1)
    }

    // console.log(getknum(Binary.root, 3), '第k层的节点数')

    //求二叉树第K层的叶子节点个数
    function getksonnum(root, k) {
      if (root === null) {
        return 0
      }
      if (root !== null && k === 1) {
        if (root.left === null && root.right === null) {
          return 1
        } else {
          return 0
        }
      }
      return getksonnum(root.left, k - 1) + getksonnum(root.right, k - 1)
    }

    // console.log(getksonnum(Binary.root, 3), '第k层的叶子节点数')

    //反转二叉树
    function reverseRoot(root) {
      if (root === null) {
        return
      }
      let temp
      temp = root.left
      root.left = root.right
      root.right = temp
      reverseRoot(root.right)
      reverseRoot(root.left)
    }

    //求二叉树的直径<<转化为求左子树的最大深度与右子树的最大深度和>>
    function longerlength(root) {
      let path = 0
      getlongerlength(root)
      return path

      function getlongerlength(root) {
        if (root == null) {
          return
        }
        let left = longerlength(root.left)
        let right = longerlength(root.right)
        path = Math.max(path, left + right)
        return Math.max(left, right) + 1
      }
    }

    //给定一棵二叉搜索树，请找出其中的第k小的结点。(中序遍历+ k小)

    // 剑指 Offer 34. 二叉树中和为某一值的路径
    // 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
    // 示例:
    // 给定如下二叉树，以及目标和 sum = 22，

    //               5
    //              / \
    //             4   8
    //            /   / \
    //           11  13  4
    //          /  \    / \
    //         7    2  5   1
    // 返回:

    // [
    //    [5,4,11,2],
    //    [5,8,4,5]
    // ]

    var pathSum = function (root, sum) {
      var res = [];
      // 存放每条路径的数组
      var path = [];
      if (!root) return [];

      function helper(root, target) {
        if (root == null) return;
        path.push(root.val);
        target -= root.val;
        // 对于每一个节点都要判断，如果target减为0并且为叶子节点（左右子树均为空）的时候满足要求，就存入结果数组中
        if (target == 0 && root.left == null && root.right == null) {
          // 这里存放的是path的拷贝，否则path会随着元素的变化而变化
          res.push([...path]);
        }
        helper(root.left, target);
        helper(root.right, target);
        // 注意这里一定要弹出当前元素，这是回溯算法关键的一点
        path.pop();
      }
      helper(root, sum);
      return res;
    };

    // console.log(FindPath(Binary.root, 21), '二叉树的路径')

    //查找二叉树的最小值
    function findMin(root) {
      if (root === null) {
        return
      }
      if (root.left === null) {
        return root.value
      }
      return findMin(root.left)
    }

    // console.log(findMin(Binary.root), '二叉树的最小值')

    //查找二叉树的最大值
    function findMax(root) {
      if (root === null) {
        return
      }
      if (root.right === null) {
        return root.value
      }
      return findMax(root.right)
    }

    // console.log(findMax(Binary.root), '二叉树的最大值')

    //判断是否为平衡二叉树
    //所谓的平衡二叉树，就是指数中任一结点的左右子树深度相差不超过1。
    var isBalanced = function (root) {
      function getHeight(node) {
        if (node === null) return 0;
        return Math.max(getHeight(node.left), getHeight(node.right)) + 1;
      }

      if (root === null) return true;
      return isBalanced(root.left) && isBalanced(root.right) &&
        Math.abs(getHeight(root.left) - getHeight(root.right)) < 2;
    };

    //实现一个链表
    function LinkList() {
      function Node(value) {
        this.value = value
        this.next = null
      }

      this.head = null
      this.length = 0
      LinkList.prototype.append = function (data) {
        if (this.head === null) {
          this.head = new Node(data)
        } else {
          let current = this.head
          while (current.next) {
            current = current.next
          }
          current.next = new Node(data)
        }
        this.length++
      }
      LinkList.prototype.find = function (data) {
        let current = this.head
        do {
          if (current.value === data) {
            return current
          }
          current = current.next
        } while (current);
      }
      LinkList.prototype.fixed = function (data, newdata) {
        let current = this.find(data)
        current.data = newdata
      }
      LinkList.prototype.prefind = function (data) { }
      LinkList.prototype.delete = function (data) {
        if (data === this.head.value) {
          this.head = this.head.next
        } else {
          let current = this.head
          while (current) {
            if (current.next.value === data) {
              current.next = current.next.next
              break
            }
            current = current.next
          }
        }
      }
      LinkList.prototype.toString = function () {
        let result = ''
        let current = this.head
        if (this.head === null) {
          return result
        } else {
          while (current) {
            result += current.value + '=>'
            current = current.next
          }
          result = result + 'null'
          return result
        }
      }
    }

    let link = new LinkList()
    link.append(1)
    link.append(2)
    link.append(3)
    link.append(3)
    link.append(4)
    link.append(4)
    link.append(5)
    // link.delete('a')
    // link.delete(1)
    // link.delete(1)
    // console.log(link.toString(), '链表的打印')
    // console.log(link.find('a'), '链表的查找')

    // console.log(intersection([4, 9, 5], [9, 4, 9, 8, 4], [8, 4]))
    //合并两个有序链表
    // 将两个升序链表合并为一个新的升序链表并返回。 新链表是通过拼接给定的两个链表的所有节点组成的。
    // 示例：
    // 输入： 1 - > 2 - > 4, 1 - > 3 - > 4
    // 输出： 1 - > 1 - > 2 - > 3 - > 4 - > 4
    function mergeTwoLists(l1, l2) {
      if (l1 === null) {
        return l2
      }
      if (l2 === null) {
        return l1
      }
      if (l1.val <= l2.val) {
        l1.next = mergeTwoLists(l1.next, l2)
        return l1
      } else {
        l2.next = mergeTwoLists(l2.next, l1)
        return l2
      }
    }

    //判断一个单链表是否有环
    //标记法
    // let hasCycle = function (head) {
    //     while (head) {
    //         if (head.flag) return true
    //         head.flag = true
    //         head = head.next
    //     }
    //     return false
    // };
    //利用 JSON.stringify() 不能序列化含有循环引用的结构
    // let hasCycle = function (head) {
    //     let flag = false
    //     try {
    //         JSON.stringify(head)
    //     } catch (error) {
    //         flag = true
    //     }
    //     return flag
    // };
    // 解法三： 快慢指针（ 双指针法）
    // 设置快慢两个指针， 遍历单链表， 快指针一次走两步， 慢指针一次走一步， 如果单链表中存在环， 则快慢指针终会指向同一个节点， 否则直到快指针指向 null 时， 快慢指针都不可能相遇
    let hasCycle = function (head) {
      if (!head || !head.next) {
        return false
      }
      let fast = head.next.next,
        slow = head.next
      while (fast !== slow) {
        if (!fast || !fast.next) return false
        fast = fast.next.next
        slow = slow.next
      }
      return true
    };
    //反转链表
    // 输入: 1 - > 2 - > 3 - > 4 - > 5 - > NULL
    // 输出: 5 - > 4 - > 3 - > 2 - > 1 - > NULL
    // var reverseList = function (head) {
    //     if (!head || !head.next) return head
    //     var next = head.next
    //     // 递归反转
    //     var reverseHead = reverseList(next)
    //     // 变更指针
    //     next.next = head
    //     head.next = null
    //     return reverseHead
    // };
    var reverseList = function (head) {
      let prev = null;
      let curr = head;
      while (curr != null) {
        let next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
      }
      return prev;
    };
    // var reverseList = function (head) {
    //     let reverse = (prev, curr) => {
    //         if (!curr) return prev;
    //         let next = curr.next;
    //         curr.next = prev;
    //         return reverse(curr, next);
    //     }
    //     return reverse(null, head);
    // };
    // console.log(reverseList(link).toString(), '链表的反转')
    //求链表的中间结点
    //遍历将节点放在数组中， 然后取中间值
    var middleNode = function (head) {
      if (!head) return []
      var arr = []
      while (head) {
        arr.push(head)
        head = head.next
      }
      return arr[Math.ceil((arr.length - 1) / 2)]
    };
    // 利用双指针，快指针走两步，慢指针走一步，快指针走完，慢指针则为中间值
    // const getMiddleNode = function (head) {
    // if (!head) return null;
    // let fast = head.next.next,
    // slow = head.next;
    // while (fast && fast.next) {
    // fast = fast.next.next;
    // slow = slow.next;
    // }
    // return slow;
    // };
    //删除链表倒数第 n 个结点
    // 这道题要用双指针来实现。先用first指针前进n，然后让second从head开始和first一起前进，直到first到了末尾，
    // 此时second的下一个节点就是要删除的节点。（另外，若first一开始前进n就已经不在链表中了，说明要删除的节点正是head节点，
    // 那么直接返回head的下一个节点接口。）
    var removeNthFromEnd = function (head, n) {
      let first = head,
        second = head;
      while (n > 0) {
        first = first.next
        n--
      }
      if (!first) return head.next; // 删除的是头节点
      while (first.next) {
        first = first.next;
        second = second.next;
      }
      second.next = second.next.next;
      return head
    };
    //编写一个程序，找到两个单链表相交的起始节点
    // 两次遍历， 先遍历一个链表， 给链表中的每个节点都增加一个标志位， 然后遍历另外一个链表， 遍历到第一个已被标志过的节点为两链表相交的起始节点。
    // 若遍历完都没有发现已被标志过的节点， 则两链表不相交， 返回 null
    var getIntersectionNode = function (headA, headB) {
      while (headA) {
        headA.flag = true
        headA = headA.next
      }
      while (headB) {
        if (headB.flag) return headB
        headB = headB.next
      }
      return null
    };
    //双指针法
    // var getIntersectionNode = function (headA, headB) {
    //     // 清除高度差
    //     let pA = headA,
    //         pB = headB
    //     while (pA || pB) {
    //         if (pA === pB) return pA
    //         pA = pA === null ? headB : pA.next
    //         pB = pB === null ? headA : pB.next
    //     }
    //     return null
    // };

    //判断一个链表是否为回文链表
    var isPalindrome = function (head) {
      if (head === null || head.next === null) return true;
      let mid = head;
      let pre = null;
      let reversed = null;
      // end每次走两格，这个循环的时间复杂度为O(n/2)
      while (head !== null && head.next !== null) {
        // 这个赋值要在mid被修改前提前
        pre = mid
        // 遍历链表
        mid = mid.next
        head = head.next.next
        // 反转前面部分的节点，并用reversed保存
        pre.next = reversed
        reversed = pre
      }
      // 奇数mid往后走一位
      if (head) mid = mid.next
      while (mid) {
        if (reversed.val !== mid.val) return false
        reversed = reversed.next
        mid = mid.next
      }
      return true
    };

    //排序链表
    var sortList = function (head) {
      function ListNode(val) {
        this.next = null
        this.val = val
      }

      function merge(left, right) { //方法1:合并两个有序链表
        let res = new ListNode(0);
        let pre = res; //因为pre一直跟着链表移动所以需要 用一个res记录链表的起点
        while (left && right) {
          if (left.val <= right.val) {
            pre.next = left;
            left = left.next;
          } else {
            pre.next = right;
            right = right.next;
          }
          pre = pre.next;
        }
        pre.next = left ? left : right;
        return res.next;
      }

      function merge(l1, l2) { //方法2:合并两个有序链表
        if (l1 === null) {
          return l2
        }
        if (l2 === null) {
          return l1
        }
        if (l1.val <= l2.val) {
          l1.next = merge(l1.next, l2)
          return l1
        }
        if (l1.val > l2.val) {
          l2.next = merge(l1, l2.next)
          return l2
        }
      }

      function mergeSort(head) {
        if (!head || !head.next) {
          return head
        }
        let left //链表的中点前一部分
        let right //链表中点后一部分
        //  let mid //中间点
        //慢指针走一步  快指针走两步  快指针到达中点时 慢指针的位置就是我们认为的中点
        let fast = head //开始快慢指针均位于起点  
        let slow = head
        while (fast.next && fast.next.next) {
          slow = slow.next
          fast = fast.next.next
        }
        //slow即是中间点
        right = slow.next
        slow.next = null
        left = head //不能写left = slow因为slow一直在移动
        return merge(mergeSort(left), mergeSort(right))
      }
      return mergeSort(head)
    }

    //哈希表
    function HashTable() {
      this.table = []
      let loseHashCode = function (key) {
        let hash = 0
        for (let i = 0; i < key.length; i++) {
          hash += key.charCodeAt(i)
        }
        return hash % 37
      }
      this.put = function (key, value) {
        this.table[loseHashCode(key), value]
      }
      this.get = function (key) {
        return this.table[loseHashCode[key]]
      }
      this.remove = function (key) {
        this.table[loseHashCode[key]] = undefined
      }
    }

    //图
    function Queue() {
      //栈中的属性
      this.items = []
      //1.压入栈push()
      Queue.prototype.enqueue = function (...element) {
        this.items.push(...element)
      }
      //2.从队列中删除前端元素
      Queue.prototype.dequeue = function () {
        return this.items.shift()
      }
      //3.查看一下前端元素
      Queue.prototype.front = function () {
        return this.items[0]
      }
      //4.判断栈是否为空
      Queue.prototype.isEmpty = function () {
        return this.items.length === 0
      }
      //5.获取栈中元素的个数
      Queue.prototype.size = function () {
        return this.items.length
      }
      //6.toString方法
      Queue.prototype.toString = function () {
        return this.items.toString().split(',').join(' ')
      }
    }

    function Graph() {
      //属性： 顶点（数组）/边（字典）
      this.vertexes = [] //顶点
      this.edges = new Map() //边
      //方法
      //增加对应顶点的方法
      Graph.prototype.addVertex = function (v) {
        this.vertexes.push(v)
        this.edges.set(v, [])
      }
      Graph.prototype.addEdge = function (v1, v2) {
        this.edges.get(v1).push(v2)
        this.edges.get(v2).push(v1)
      }
      //实现toString 方法
      Graph.prototype.toString = function () {
        //定义字符转，保存最终的结构
        let resultString = ""
        for (let i = 0; i < this.vertexes.length; i++) {
          resultString += this.vertexes[i] + '->'
          let vEdges = this.edges.get(this.vertexes[i])
          for (let j = 0; j < vEdges.length; j++) {
            resultString += vEdges[j] + ' '
          }
          resultString += "\n"
        }
        return resultString
      }
      //图的遍历
      //初始化状态颜色
      Graph.prototype.initializeColor = function () {
        let colors = []
        for (let i = 0; i < this.vertexes.length; i++) {
          colors[this.vertexes[i]] = 'white'
        }
        return colors
      }
      //广度优先搜索算法(BFS)  基于队列完成
      Graph.prototype.bfs = function (initV, handler) {
        //1.初始化颜色
        let colors = this.initializeColor()
        //2.创建队列
        let queue = new Queue()
        //3.将顶点加入队列中
        queue.enqueue(initV)
        //4.循环从队列中取出元素
        while (!queue.isEmpty()) {
          // 4.1从队列取出一个顶点
          let v = queue.dequeue()
          //4.2 获取和顶点相连的另外顶点
          let vList = this.edges.get(v)
          //4.3 将v的颜色设置为灰色
          colors[v] = 'gray'
          //4.4  遍历所有的顶点，并且加入到队列中
          for (let i = 0; i < vList.length; i++) {
            let e = vList[i]
            if (colors[e] == 'white') {
              colors[e] = 'gray'
              queue.enqueue(e)
            }
          }
          //4.5 访问顶点
          handler(v)
          //4.6 将顶点设置为黑色
          colors[v] = 'black'
        }
      }
      //广度优先搜索算法（DFS）
      Graph.prototype.dfs = function (initV, handler) {
        let colors = this.initializeColor()
        //递归访问
        this.dfsVisit(initV, colors, handler)
      }
      Graph.prototype.dfsVisit = function (v, colors, handler) {
        //1.将颜色设置为灰色
        colors[v] = 'gray'
        //2.处理V节点
        handler(v)
        //3.访问v相连的顶点
        let vList = this.edges.get(v)
        for (let i = 0; i < vList.length; i++) {
          let e = vList[i]
          if (colors[e] === 'white') {
            this.dfsVisit(e, colors, handler)
          }
        }
        //4.将v设置为黑色
        colors[v] = 'black'
      }
    }

    //封装jsonp
    function jsonp(url, params, callback, outTime) {
      let body = document.body
      let fnName = "_jsonpFn" + Math.random().toString().replace('.', '')
      let script = document.createElement('script')
      window[fnName] = function (data) {
        callback(data)
        delete window[fnName]
        body.removeChild(script)
      }
      let str = ''
      for (const key of params) {
        str += key + "=" + params[key] + "&"
      }
      str += 'callback=' + fnName
      script.src = url + '?' + str
      body.insertBefore(script, document.body.firstChild)
      if (outTime) {
        let timer = window.setTimeout(() => {
          body.removeChild(script)
          clearTimeout(timer)
        }, outTime)
      }
    }

    function jsonpromise(url) {
      let json;
      let s = document.createElement('script');
      s.src = url + '?callback=fn';
      window.fn = function (data) {
        json = data;
      }
      //当script被插入文档中时，src中的资源就会开始加载
      document.body.appendChild(s);

      return new Promise((resolve, reject) => {
        /* throw('err in promise'); */
        s.onload = function (e) {
          resolve(json);
        }
        s.onerror = function () {
          reject(json);
        }
      });
    }
    jsonpromise('http://localhost:8082').then(data => {
      // console.log(data);
      throw ('err before then');
    }).catch(err => {
      //可以捕捉到then里的err befor then也可以捕捉到new Promise里的err in promise。
      // console.log(err)
    })

    //JS 实现两个大数相加？
    // let a = "9007199254740991";
    // let b = "1234567899999999999";
    function addBigNum(a, b) {
      //取两个数字的最大长度
      let maxLength = Math.max(a.length, b.length);
      //用0去补齐长度
      a = a.padStart(maxLength, 0); //"0009007199254740991"
      b = b.padStart(maxLength, 0); //"1234567899999999999"
      //定义加法过程中需要用到的变量
      let t = 0;
      let f = 0; //"进位"
      let sum = "";
      for (let i = maxLength - 1; i >= 0; i--) {
        t = parseInt(a[i]) + parseInt(b[i]) + f;
        f = Math.floor(t / 10);
        sum = t % 10 + sum;
      }
      if (f == 1) {
        sum = "1" + sum;
      }
      return sum;
    }

    //判断回文字符串
    // function palindrome(str) {
    //     return str === str.split('').reverse().join('')
    // }
    // function palindRome(str) {
    //     var len = str.length;
    //     var str1 = "";
    //     for (var i = len - 1; i >= 0; i--) {
    //         str1 += str[i];
    //     }
    //     console.log(str1 == str)
    // }
    // palindRome("abcba"); //true
    // palindRome("abcbac"); //false
    function palindrome(str) {
      if (str === '') {
        return true
      }
      if (str.length === 1) {
        return true
      }
      if (str[str.length - 1] === str[0]) {
        return palindrome(str.slice(1, str.length - 1))
      } else {
        return false
      }
    }

    // console.log(palindrome('abfba'), '回文字符串')
    //生成随机长度的字符串
    function randomString(n) {
      var str = 'abcdefghijklmnopqrstuvwxyz0123456789';
      var tmp = '';
      for (var i = 0; i < n; i++) {
        tmp += str.charAt(Math.round(Math.random() * str.length));
      }
      return tmp;
    }

    //统计字符串中次数最多字母
    // var str = 'aaabbbccck';
    // var arr = str.split(''); // 转换为数组
    // arr.sort(); // 对数组进行排序
    // str = arr.join(''); // 转换为字符串
    // var re = /(\w)\1+/g; // 将相同的内容分割为一组
    // var value = '';
    // var num = 0;
    // str.replace(re, function ($0, $1) { // replace 字符串替换  re规定字符串要替换的模式  $0父级，$1 第一个孩子
    //     if ($0.length > num) {
    //         num = $0.length;
    //         value = $1;
    //     }
    // });
    // alert('最多的字符:' + value + ',个数:' + num);
    function findMaxDuplicateChar(str) {
      if (str.length == 1) {
        return str;
      }
      var charObj = {};
      for (var i = 0; i < str.length; i++) {
        if (!charObj[str.charAt(i)]) {
          charObj[str.charAt(i)] = 1;
        } else {
          charObj[str.charAt(i)] += 1;
        }
      }
      var maxChar = '',
        maxValue = 1;
      for (var k in charObj) {
        if (charObj[k] >= maxValue) {
          maxChar = k;
          maxValue = charObj[k];
        }
      }
      return maxChar + '：' + maxValue;
    }

    //二分查找
    //递归实现
    function binary_search2(arr = [1, 2, 3, 4, 5, 6, 7, 8, 9], low, high, key = 7) {
      if (low > high) return -1;
      let mid = Math.floor((low + high) / 2)
      if (arr[mid] === key) {
        return mid
      } else if (key < arr[mid]) {
        return binary_search2(arr, low, mid - 1, key)
      } else {
        return binary_search2(arr, mid + 1, high, key)
      }
    }

    //非递归实现
    function binary_search(arr, key) {
      var low = 0,
        high = arr.length - 1;
      while (low <= high) {
        var mid = parseInt((high + low) / 2);
        if (key == arr[mid]) {
          return mid;
        } else if (key > arr[mid]) {
          low = mid + 1;
        } else if (key < arr[mid]) {
          high = mid - 1;
        }
      }
      return -1;
    }

    //console.log(binary_search2([1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 8, 7), '二分法查找')
    // 解析 URL Params 为对象
    // let url = 'http://www.domain.com/?user=anonymous&id=123&id=456&city=%E5%8C%97%E4%BA%AC&enabled';
    // parseParam(url)
    /* 结果
    { user: 'anonymous',
      id: [ 123, 456 ], // 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型
      city: '北京', // 中文需解码
      enabled: true, // 未指定值得 key 约定为 true
    }
    */
    function parseParam(url) {
      const paramsStr = /.+\?(.+)$/.exec(url)[1]; // 将 ? 后面的字符串取出来
      const paramsArr = paramsStr.split('&'); // 将字符串以 & 分割后存到数组中
      let paramsObj = {};
      // 将 params 存到对象中
      paramsArr.forEach(param => {
        if (/=/.test(param)) { // 处理有 value 的参数
          let [key, val] = param.split('='); // 分割 key 和 value
          val = decodeURIComponent(val); // 解码
          val = /^\d+$/.test(val) ? parseFloat(val) : val; // 判断是否转为数字
          if (paramsObj.hasOwnProperty(key)) { // 如果对象有 key，则添加一个值
            paramsObj[key] = [].concat(paramsObj[key], val);
          } else { // 如果对象没有这个 key，创建 key 并设置值
            paramsObj[key] = val;
          }
        } else { // 处理没有 value 的参数
          paramsObj[param] = true;
        }
      })
      return paramsObj;
    }

    //实现一个简单的模板渲染
    let template = '我是{{name}}，年龄{{age}}，性别{{sex}}';
    let data = {
      name: '姓名',
      age: 18
    }
    //  console.log(render(template, data)); // 我是姓名，年龄18，性别undefined
    // function render(template, data) {
    //     let reg = /\{\{(\w+)\}\}/
    //     if (reg.test(template)) { //表示有没有替换的模板
    //         let name = reg.exec(template)[1]
    //         template = template.replace(reg, data[name])
    //         render(template, data)
    //     } else {
    //         return template
    //     }
    // }
    function render(template, data) {
      return template.replace(new RegExp('{{(.*?)}}', 'g'), ($0, $1) => {
        //  console.log($0, $1)
        data[$1.trim()]
      });
    }

    //请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）
    // a = '34';
    // b = '1234567'; // 返回 2
    // a = '35';
    // b = '1234567'; // 返回 -1
    // a = '355';
    // b = '12354355'; // 返回 5
    // isContain(a, b);
    function isContain(a, b) {
      let len1 = a.length
      let len2 = b.length
      for (let i = 0; i < b.length; i++) {
        if (b.slice(i, i + len1) === a) {
          return i
        }
      }
      return -1
    }

    // console.log(isContain('355','12354355'),'字符串的位置')
    //实现千分位
    // 保留三位小数
    // parseToMoney(1234.56); // return '1,234.56'
    // parseToMoney(123456789); // return '123,456,789'
    // parseToMoney(1087654.321); // return '1,087,654.321'
    // 12.(pattern)： 匹配 pattern 并获取这一匹配。 所获取的匹配可以从产生的 Matches 集合得到， 在VBScript 中使用 SubMatches 集合， 在JScript 中则使用 0… 0… 9 属性。 要匹配圆括号字符， 请使用 '('
    // 或 ')'。
    // 13.( ? : pattern)： 匹配 pattern 但不获取匹配结果， 也就是说这是一个非获取匹配， 不进行存储供以后使用。 这在使用 "或"
    // 字符( | ) 来组合一个模式的各个部分是很有用。 例如， 'industr(?:y|ies) 就是一个比 '
    // industry | industries ' 更简略的表达式。
    // 14.( ? =
    //     pattern)： 正向预查， 在任何匹配 pattern 的字符串开始处匹配查找字符串。 这是一个非获取匹配， 也就是说， 该匹配不需要获取供以后使用。 例如， 'Windows (?=95|98|NT|2000)'
    // 能匹配 "Windows 2000"
    // 中的 "Windows"，
    // 但不能匹配 "Windows 3.1"
    // 中的 "Windows"。
    // 预查不消耗字符， 也就是说， 在一个匹配发生后， 在最后一次匹配之后立即开始下一次匹配的搜索， 而不是从包含预查的字符之后开始。
    // 15.( ? !
    //     pattern)： 负向预查， 在任何不匹配 pattern 的字符串开始处匹配查找字符串。 这是一个非获取匹配， 也就是说， 该匹配不需要获取供以后使用。 例如 'Windows (?!95|98|NT|2000)'
    // 能匹配 "Windows 3.1"
    // 中的 "Windows"，
    // 但不能匹配 "Windows 2000"
    // 中的 "Windows"。
    // 预查不消耗字符， 也就是说， 在一个匹配发生后， 在最后一次匹配之后立即开始下一次匹配的搜索， 而不是从包含预查的字符之后开始
    function parseToMoney(num) {
      num = parseFloat(num.toFixed(3));
      let [integer, decimal] = String.prototype.split.call(num, '.');
      integer = integer.replace(/\d{1,3}(?=(\d{3})+$)/g, '$&,');
      return integer + '.' + (decimal ? decimal : '');
    }

    //无重复字符的最长子串长度
    var lengthOfLongestSubstring = function (s = 'pwwkew') {
      let max = 0 //记录子串的最大长度
      let str = '' //记录子串的滑动窗口
      for (let j = 0; j < s.length; j++) {
        if (str.indexOf(s.charAt(j)) === -1) {
          str += s.charAt(j)
          max = Math.max(max, str.length)
        } else {
          // console.log(str)  //这里特殊处理能求出最长的子串是那个
          str = str.slice(str.indexOf(s.charAt(j)) + 1) + s.charAt(j)
        }
      }
      return max
    }
    //console.log(lengthOfLongestSubstring(), '无重复字符的最长子串')
    //字节&leetcode155：最小栈（包含getMin函数的栈）
    // 设计一个支持 push， pop， top 操作， 并能在常数时间内检索到最小元素的栈。
    // push(x)—— 将元素 x 推入栈中。
    // pop()—— 删除栈顶的元素。
    // top()—— 获取栈顶元素。
    // getMin()—— 检索栈中的最小元素。
    var MinStack = function () {
      this.items = []
      this.min = null
    };
    // 进栈
    MinStack.prototype.push = function (x) {
      if (!this.items.length) this.min = x
      this.min = Math.min(x, this.min)
      this.items.push(x)
    };
    // 出栈
    MinStack.prototype.pop = function () {
      let num = this.items.pop()
      this.min = Math.min(...this.items)
      return num
    };
    // 获取栈顶元素
    MinStack.prototype.top = function () {
      if (!this.items.length) return null
      return this.items[this.items.length - 1]
    };
    // 检索栈中的最小元素
    MinStack.prototype.getMin = function () {
      return this.min
    };
    //两数之和
    // 给定一个整数数组 nums 和一个目标值 target， 请你在该数组中找出和为目标值的那 两个 整数， 并返回他们的数组下标。
    // 你可以假设每种输入只会对应一个答案。 但是， 你不能重复利用这个数组中同样的元素。
    // 示例:
    //     给定 nums = [2, 7, 11, 15], target = 9
    // 因为 nums[0] + nums[1] = 2 + 7 = 9
    // 所以返回[0, 1]
    function getSumIndex(nums, target) {
      let map = new Map()
      for (let i = 0; i < nums.length; i++) {
        let a = target - nums[i]
        if (map.has(a)) {
          return [map.get(a), i]
        } else {
          map.set(nums[i], i)
        }
      }
    }

    // console.log(getSumIndex([2, 7, 11, 15], 9), '两数之和')
    //阿里算法题：编写一个函数计算多个数组的交集
    // accumulator 正如翻译的那样，它是 reduce 方法多次执行的累积结果，accumulator 的初始值分两种情况：
    // 若有提供 initialValue 初始值，第一次循环时 accumulator 的值便为 initialValue，后续循环时 accumulator 为上次循环的返回值。
    // 若未提供initialValue，第一次循环时 accumulator 的值为数组第一项arr[0]，后续循环时为上次循环的返回值。
    // 3.currentValue [ˈkɜːrənt] [ˈvæljuː] 当前值
    // 这个应该不难理解，数组循环当前处理的值。currentValue 的初始值也受到initialValue的影响：
    // 若有提供 initialValue 初始值，第一次循环currentValue 的值为数组第一项arr[0]，后续变化随索引递增变化。
    // 若未提供initialValue，第一次循环由于arr[0]成了accumulator 的值，所以currentValue 只能从arr[1]开始，后续变化随索引递增。
    function intersection() {
      let arr = Array.from(arguments)
      return arr.reduce(function (total, cur, index, arr) {
        //  console.log(total, cur, '.....')
        return cur.filter(function (item) {
          return total.includes(item)
        })
      })
    }


    //最长公共前缀
    // 输入: ["flower", "flow", "flight"]
    // 输出: "fl"
    //常规方法 第一个与第二个比较 得到一个公共前缀 再依次跟后面的比较
    // function lengthOfLongestSubstrings (strs) {
    //   if (strs.length === 0 || !strs) {
    //     return ''
    //   }
    //   let prev = strs[0]
    //   for (let i = 1; i < strs.length; i++) {
    //     let j = 0
    //     for (; j < strs[i].length; j++) {
    //       if (strs[i][j] !== prev[j]) {
    //         break
    //       }
    //     }
    //     prev = prev.substring(0, j)
    //   }
    //   return prev
    // }
    //最小字符串跟最大字符串的差异就是公共前缀
    function lengthOfLongestSubstrings(strs) {
      let min = strs[0],
        max = strs[0] //最小字符串 最大字符串
      for (let i = 0; i < strs.length; i++) {
        if (strs[i] < min) {
          min = strs[i]
        }
      }
      for (let i = 0; i < strs.length; i++) {
        if (strs[i] > max) {
          max = strs[i]
        }
      }
      for (let i = 0; i < min.length; i++) {
        if (min[i] !== max[i]) {
          return min.substring(0, i)
        }
      }
    }

    //归并分治的思想  有点类似于归并排序
    var longestCommonPrefix = function (strs) {
      if (strs.length === 0 || strs[0].length === 0) {
        return "";
      }
      return divide(strs, 0, strs.length - 1);
    }

    function divide(strs, l, r) {
      if (l === r) {
        return strs[l];
      } else {
        let mid = Math.floor((l + r) / 2);
        let leftPre = divide(strs, l, mid),
          rightPre = divide(strs, mid + 1, r);
        return compare(leftPre, rightPre);
      }
    }

    function compare(left, right) {
      let min = Math.min(left.length, right.length);
      for (let i = 0; i < min; i++) {
        if (left.charAt(i) !== right.charAt(i)) {
          return left.substring(0, i);
        }
      }
      return left.substring(0, min);
    }
    // console.log(lengthOfLongestSubstrings(['abshfkshfkhs', 'abcsdkfhkshfk', 'abeifgsgfs']), '最长公共前缀');
    //最长公共子序列
    var longestCommonSubsequence = function (text1, text2) {
      let n = text1.length;
      let m = text2.length;
      // Array.from(obj, mapFn)
      // obj指的是数组对象、类似数组对象或者是set对象，map指的是对数组中的元素进行处理的方法。
      let dp = Array.from(new Array(n + 1), () => new Array(m + 1).fill(0));
      for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
          if (text1[i - 1] === text2[j - 1]) { //末尾字符相同则最长公共子序列一定有这个数
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]); //末尾字符不相同则可能最长公共子序列可能有这个数
          }
        }
      }
      return dp[n][m];
    };
    // console.log(longestCommonSubsequence('abcdefg', 'bcdg'), '公共子序列');

    // 打印出最长公共子序列
    function lcs(str1, str2) {
      var len1 = str1.length,
        len2 = str2.length;
      var dp = [];
      for (var i = 0; i <= len1; i++) {
        dp[i] = [];
        for (var j = 0; j <= len2; j++) {
          if (i == 0 || j == 0) {
            dp[i][j] = 0;
            continue;
          }
          if (str1[i - 1] == str2[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
          } else {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
          }
        }
      }
      var result = printLCS(dp, str1, str2, len1, len2);
      return result;
    }
    // 打印公共子序列
    function printLCS(dp, str1, str2, i, j) {
      if (i == 0 || j == 0) {
        return "";
      }
      if (str1[i - 1] == str2[j - 1]) {
        return printLCS(dp, str1, str2, i - 1, j - 1) + str1[i - 1];
      } else if (dp[i][j - 1] > dp[i - 1][j]) {
        return printLCS(dp, str1, str2, i, j - 1);
      } else {
        return printLCS(dp, str1, str2, i - 1, j);
      }
    }
    // console.log(lcs('abcda', 'bcdda')); // bcda

    //手写map
    Array.prototype.myMap = function (fn) {
      let arr = []
      for (let i = 0; i < this.length; i++) {
        arr.push(fn(this[i], i, this))
      }
      return arr
    }

    //手写reduce
    Array.prototype.myReduce = function (fn, init) {
      let res = init ? init : 0;
      for (let i = init ? 1 : 0; i < this.length; i++) {
        res = fn(res, this[i], i, this)
      }
      return res
    }

    //手写一个filter
    Array.prototype.filter = function (fn) {
      let arr = []
      for (let i = 0; i < this.length; i++) {
        if (fn(this[i])) {
          arr.push(this[i], i, this)
        }
      }
      return arr
    }



    //15. 三数之和
    // 给你一个包含 n 个整数的数组 nums， 判断 nums 中是否存在三个元素 a， b， c，
    // 使得 a + b + c = 0？ 请你找出所有满足条件且不重复的三元组。
    // 注意： 答案中不可以包含重复的三元组。
    // 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
    // 满足要求的三元组集合为：
    //     [
    //         [-1, 0, 1],
    //         [-1, -1, 2]
    //     ]
    var threeSum = function (nums) {
      const result = [];
      nums.sort((a, b) => a - b);
      for (let i = 0; i < nums.length; i++) {
        // 跳过重复数字
        if (i && nums[i] === nums[i - 1]) {
          continue;
        }
        let left = i + 1;
        let right = nums.length - 1;
        while (left < right) {
          const sum = nums[i] + nums[left] + nums[right];
          if (sum > 0) {
            right--;
          } else if (sum < 0) {
            left++;
          } else {
            result.push([nums[i], nums[left++], nums[right--]]);
            // 跳过重复数字
            while (nums[left] === nums[left - 1]) {
              left++;
            }
            // 跳过重复数字
            while (nums[right] === nums[right + 1]) {
              right--;
            }
          }
        }
      }
      return result;
    }

    // 输入一个正整数数组， 把数组里所有数字拼接起来排成一个数，
    // 打印能拼接出的所有数字中最小的一个。 例如输入数组 {
    //   3， 32， 321
    // }，
    // 则打印出这三个数字能排成的最小数字为321323。
    function PrintMinNumber(numbers) {
      var result = "";
      for (let i = 0; i < numbers.length; i++) {
        for (let j = i + 1; j < numbers.length; j++) {
          let s1 = numbers[i] + '' + numbers[j]
          let s2 = numbers[j] + '' + numbers[i]
          if (s1 > s2) {
            let temp = numbers[i]
            numbers[i] = numbers[j]
            numbers[j] = temp
          }
        }
      }
      for (let m = 0; m < numbers.length; m++) {
        result = result + numbers[m];
      }
      return result;
    }

    // function PrintMinNumber(numbers) {
    //   if (!numbers || numbers.length === 0) {
    //     return "";
    //   }
    //   return numbers.sort(compare).join('');
    // }

    // function compare(a, b) {
    //   const front = "" + a + b;
    //   const behind = "" + b + a;
    //   return front - behind;
    // }

    // 在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回-1（需要区分大小写）。
    // function FirstNotRepeatingChar(str) {
    //   if (!str) {
    //     return -1;
    //   }
    //   let countMap = {};
    //   const array = str.split('');
    //   const length = str.length;
    //   for (let i = 0; i < length; i++) {
    //     const current = array[i];
    //     let count = countMap[current];
    //     if (count) {
    //       countMap[current] = count + 1;
    //     } else {
    //       countMap[current] = 1;
    //     }
    //   }
    //   for (let i = 0; i < length; i++) {
    //     if (countMap[array[i]] === 1) {
    //       return i;
    //     }
    //   }
    //   return -1;
    // }
    function FirstNotRepeatingChar(str) {
      // write code here
      for (var i = 0; i < str.length; i++) {
        if (str.indexOf(str[i]) == str.lastIndexOf(str[i])) {
          return i;
        }
      }
      return -1;
    }
    //输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分
    function reOrderArray(array) {
      if (Array.isArray(array)) {
        let start = 0;
        let end = array.length - 1;
        while (start < end) {
          while (array[start] % 2 === 1) {
            start++;
          }
          while (array[end] % 2 === 0) {
            end--;
          }
          if (start < end) {
            [array[start], array[end]] = [array[end], array[start]]
          }
        }
      }
      return array;
    }
    // 和为S的连续正数序列——js
    // 假设序列的开始数字为a,结束数字为a+i，那么有(a+i-a+1)*(a+a+i)/2=sum

    // 也就是(i+1)(2a+i)=2*sum

    // 那么我们只需要找出这样的a和i就行了，最后再根据a和i得出序列。
    // function FindContinuousSequence(sum) {
    //             let half = sum >> 1
    //             let start = 0 //连续子序列的起始值
    //             while (half--) {
    //                 start++
    //                 let i = 1  //连续子序列的个数
    //                 while ((start + start + i - 1) * i / 2 < sum) {
    //                     i++
    //                 }
    //                 if ((start + start + i - 1) * i / 2 === sum) {
    //                     console.log(start, i)  //找出了起始值及个数 
    //                 }
    //             }
    //         }
    function FindContinuousSequence(sum) {
      let a = 0,
        half = sum >> 1;
      const res = [];
      while (half--) {
        a++;
        let i = 1;
        while ((i + 1) * (2 * a + i) < 2 * sum) {
          i++;
        }
        if ((i + 1) * (2 * a + i) === 2 * sum) {
          const tmp = [];
          tmp.push(a);
          tmp.push(i);
          res.push(tmp);
        }
      }
      for (let i = 0; i < res.length; i++) {
        let num = res[i][1],
          k = 1;
        const tmp = [];
        tmp.push(res[i][0]);
        while (num--) {
          tmp.push(res[i][0] + k);
          k++;
        }
        res[i] = tmp;
      }
      return res;
    }

    //输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的
    //看了题目了，很像leetcode的第一题【两数之和】，但是题目中有一个明显不同的条件就是数组是有序的，可以使用使用大小指针求解，不断逼近结果，最后取得最终值。
    function FindNumbersWithSum(array, sum) {
      if (array && array.length > 0) {
        let left = 0;
        let right = array.length - 1;
        while (left < right) {
          const s = array[left] + array[right];
          if (s > sum) {
            right--;
          } else if (s < sum) {
            left++;
          } else {
            return [array[left], array[right]]
          }
        }
      }
      return [];
    }

    //在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。
    var reversePairs = function (nums) {
      if (nums.length < 1) return 0
      let total = 0
      /*
        合并排序函数
      */
      let merge = function (left, right) {
        let l_index = 0,
          r_index = 0
        let res = []
        while (l_index < left.length && r_index < right.length) { // 两个数组 元素两两对比, 把小的依次加入res  直到其中有数组的元素全部加入到res
          if (left[l_index] > right[r_index]) { // 右边小, 把右边的加入res
            res.push(right[r_index])
            r_index++
            total += left.length - l_index // --------------比并归排序多了这行---------------------------
          } else { // 左边小或等, 把左边的加入res
            res.push(left[l_index])
            l_index++
          }
        }
        while (l_index < left.length) { // 把剩下的继续加入res
          res.push(left[l_index++])
        }
        while (r_index < right.length) {
          res.push(right[r_index++])
          total += left.length - l_index // ----------------比并归排序多了这行-----------------------------
        }
        return res
      }
      /*
        分割的递归函数, 把数组都分割成 单个元素的  再返回合并后的排序函数
      */
      let arrSplit = function (arr) {
        if (arr.length === 1) return arr
        let middle = ~~(arr.length / 2)
        let left = arr.slice(0, middle)
        let right = arr.slice(middle)
        return merge(arrSplit(left), arrSplit(right))
      }
      arrSplit(nums)
      return [total, nums, arrSplit(nums)]
    };
    // console.log(reversePairs([1, 6, 4, 9, 2]), '找出数组的逆序对')
    // console.log(reversePairs([1, 4, 6, 9, 2]), '找出数组的逆序对')
    // console.log(reversePairs([1, 6, 4]), '找出数组的逆序对')

    // 给定一个包含 n 个整数的数组nums，判断 nums 中是否存在四个元素a，b，c，d ，使得 a + b + c + d = 0 ？找出所有满足条件且不重复的四元组。

    // 注意：答案中不可以包含重复的四元组。
    // 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

    // 满足要求的四元组集合为：
    // [
    //   [-1, 0, 0, 1],
    //   [-2, -1, 1, 2],
    //   [-2, 0, 0, 2]
    // ]
    var fourSum = function (nums, target) {
      if (nums.length < 4) {
        return [];
      }
      nums.sort((a, b) => a - b);
      const result = [];
      for (let i = 0; i < nums.length - 3; i++) {
        if (i > 0 && nums[i] === nums[i - 1]) {
          continue;
        }
        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
          break;
        }
        for (let j = i + 1; j < nums.length - 2; j++) {
          if (j > i + 1 && nums[j] === nums[j - 1]) {
            continue;
          }
          let left = j + 1,
            right = nums.length - 1;
          while (left < right) {
            const sum = nums[i] + nums[j] + nums[left] + nums[right];
            if (sum === target) {
              result.push([nums[i], nums[j], nums[left], nums[right]]);
            }
            if (sum <= target) {
              while (nums[left] === nums[++left]);
            } else {
              while (nums[right] === nums[--right]);
            }
          }
        }
      }
      return result;
    };

    //堆排序

    // function heapSort(items) {
    //   // 构建大顶堆
    //   buildHeap(items, items.length - 1)
    //   // 设置堆的初始有效序列长度为 items.length - 1
    //   let heapSize = items.length - 1
    //   for (var i = items.length - 1; i > 1; i--) {
    //     // 交换堆顶元素与最后一个有效子元素
    //     swap(items, 1, i);
    //     // 有效序列长度减 1
    //     heapSize--;
    //     // 堆化有效序列(有效序列长度为 currentHeapSize，抛除了最后一个元素)
    //     heapify(items, heapSize, 1);
    //   }
    //   return items;
    // }

    // // 原地建堆
    // // items: 原始序列
    // // heapSize: 有效序列长度
    // function buildHeap(items, heapSize) {
    //   // 从最后一个非叶子节点开始，自上而下式堆化
    //   for (let i = Math.floor(heapSize / 2); i >= 1; --i) {
    //     heapify(items, heapSize, i);
    //   }
    // }
    // function heapify(items, heapSize, i) {
    //   // 自上而下式堆化
    //   while (true) {
    //     var maxIndex = i;
    //     if (2 * i <= heapSize && items[i] < items[i * 2]) {
    //       maxIndex = i * 2;
    //     }
    //     if (2 * i + 1 <= heapSize && items[maxIndex] < items[i * 2 + 1]) {
    //       maxIndex = i * 2 + 1;
    //     }
    //     if (maxIndex === i) break;
    //     swap(items, i, maxIndex); // 交换 
    //     i = maxIndex;
    //   }
    // }
    // function swap(items, i, j) {
    //   let temp = items[i]
    //   items[i] = items[j]
    //   items[j] = temp
    // }

    // // 测试
    // var items = [, 1, 9, 2, 8, 3, 7, 4, 6, 5]
    // heapSort(items)
    // // [empty, 1, 2, 3, 4, 5, 6, 7, 8, 9]


    function headSort(arr) {
      buildHeap(arr); //构建堆
      var len = arr.length;
      for (var i = len - 1; i > 0; i--) {
        swap(arr, 0, i); //交换堆的第一个元素和最后一个元素
        heapify(arr, i); //调整堆
      }
      return arr;
    }

    function buildHeap(arr) {
      var len = arr.length;
      if (len == 0)
        return;
      for (var i = Math.floor(len / 2); i > 0; i--) {
        heapify(arr, i);
      }
    }

    function heapify(arr, i) {
      var left = 2 * i + 1;
      var right = 2 * i + 2;
      var largest = i;
      var len = arr.length;
      if (left < len && arr[left] > arr[largest]) { //先判断左节点还否超出
        largest = left;
      }
      if (right < len && arr[right] > largest) { //有节点是否超出 找出最大的子节点
        largest = right;
      }
      if (largest != i) {
        swap(arr, i, largest); //交换 largrst为i
        heapify(arr, largest); //递归调整
      }
    }

    function swap(arr, i, j) {
      var temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    //函数组合  compose函数
    /**
     * @param  funcs 存储按照顺序执行的函数(数组) => [fn1, fn3, fn2, fn4]
     * @param  args 存储第一个函数执行需要传递的实参信息(数组) => [5]
     */
    // function compose(...funcs) {
    //   return function anonymous(...args) {
    //     if (funcs.length === 0) return args;
    //     if (funcs.length === 1) return funcs[0](...args);
    //     // funcs 里有 多个函数时
    //     return funcs.reduce((n, func) => {
    //       // 第一次执行：
    //       // n：第一个函数执行的实参 func：第一个函数
    //       // 第二次执行：
    //       // n的值：上一次func执行后的返回值，作为实参传递给下一个函数执行 func：第二个函数
    //       return Array.isArray(n) ? func(...n) : func(n);
    //     }, args)
    //   }
    // }

    // let res = compose(fn1, fn3, fn2, fn4)(5)

    // // 执行过程：
    // console.log(compose()(5)); //=>5
    // console.log(compose(fn1)(5)); //=>5+10 = 15
    // console.log(compose(fn1, fn3)(5)); //=>fn1(5)=15  fn3(15)=150
    // console.log(compose(fn1, fn3, fn2)(5)); //=>fn1(5)=15  fn3(15)=150 fn2(150)=140
    // console.log(compose(fn1, fn3, fn2, fn4)(5)); //=>fn1(5)=15  fn3(15)=150 fn2(150)=140 fn4(140)=14
    function compose(...funcs) {
      return function (x) {
        return funcs.reduce(function (arg, fn) {
          return fn(arg);
        }, x);
      };
    }

    function compose(...fns) {
      return subArgs => {
        return fns.reverse().reduce((total, func, index) => {
          return func(total);
        }, subArgs);
      }
    }



    //实现json.parse
    // var json = '{"name":"cxk", "age":25}';
    // var obj = eval("(" + json + ")");

    //计数二进制子串
    // 给定一个字符串 s， 计算具有相同数量0和1的非空(连续) 子字符串的数量， 并且这些子字符串中的所有0和所有1都是组合在一起的。

    // 重复出现的子串要计算它们出现的次数。
    // 输入: "00110011"
    // 输出: 6
    // 解释: 有6个子串具有相同数量的连续1和0：“ 0011”，“ 01”，“ 1100”，“ 10”，“ 0011” 和“ 01”。

    // 请注意， 一些重复出现的子串要计算它们出现的次数。

    // 另外，“ 00110011” 不是有效的子串， 因为所有的0（ 和1） 没有组合在一起。
    // 输入: "10101"
    // 输出: 4
    // 解释: 有4个子串：“ 10”，“ 01”，“ 10”，“ 01”， 它们具有相同数量的连续1和0。
    // export default (str) => {
    //   // 建立数据结构，堆栈，保存数据
    //   let r = []
    //   // 给定任意子输入都返回第一个符合条件的子串
    //   let match = (str) => {
    //     let j = str.match(/^(0+|1+)/)[0]
    //     let o = (j[0] ^ 1).toString().repeat(j.length)
    //     let reg = new RegExp(`^(${j}${o})`)
    //     if (reg.test(str)) {
    //       return RegExp.$1
    //     } else {
    //       return ''
    //     }
    //   }
    //   // 通过for循环控制程序运行的流程
    //   for (let i = 0, len = str.length - 1; i < len; i++) {
    //     let sub = match(str.slice(i))
    //     if (sub) {
    //       r.push(sub)
    //     }
    //   }
    //   return r
    // }
    let countBinarySubstrings = function (s) {
      let n = 0,
        arr = s.match(/([1]+)|([0]+)/g)
      for (let i = 0; i < arr.length - 1; i++) {
        n += Math.min(arr[i].length, arr[i + 1].length)
      }
      return n
    }

    //电话号码排列组合
    // 给定一个仅包含数字 2 - 9 的字符串， 返回所有它能表示的字母组合。
    // 给出数字到字母的映射如下（ 与电话按键相同）。 注意 1 不对应任何字母。
    // 示例:
    //   输入： "23"
    // 输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
    //回溯法求排列组合
    var letterCombinations = function (digits) {
      if (!digits) {
        return [];
      }
      var len = digits.length;
      var map = new Map();
      map.set('2', 'abc');
      map.set('3', 'def');
      map.set('4', 'ghi');
      map.set('5', 'jkl');
      map.set('6', 'mno');
      map.set('7', 'pqrs');
      map.set('8', 'tuv');
      map.set('9', 'wxyz');
      var result = [];

      function _generate(i, str) {
        // terminator
        if (i == len) {
          result.push(str);
          return;
        }
        // process
        // drill down
        var tmp = map.get(digits[i]);
        for (var r = 0; r < tmp.length; r++) {
          _generate(i + 1, str + tmp[r]);
        }
      }
      _generate(0, '');
      return result;
    };
    // console.log(letterCombinations('456'),'回溯法求排列组合')
    //组合总和
    // 给定一个无重复元素的数组 candidates 和一个目标数 target， 找出 candidates 中所有可以使数字和为 target 的组合。

    // candidates 中的数字可以无限制重复被选取。

    // 说明：

    // 所有数字（ 包括 target） 都是正整数。
    // 解集不能包含重复的组合。
    // 示例 1:

    //   输入: candidates = [2, 3, 6, 7], target = 7,
    //   所求解集为: [
    //     [7],
    //     [2, 2, 3]
    //   ]
    // 示例 2:

    //   输入: candidates = [2, 3, 5], target = 8,
    //   所求解集为: [
    //     [2, 2, 2, 2],
    //     [2, 3, 3],
    //     [3, 5]
    //   ]
    var combinationSum = function (candidates, target) { //回溯算法的应用
      let res = [] //存放输出结果
      let temp = [] //存放临时结果
      function backTrack(temp, target, index) {
        if (target === temp.reduce(function (a, b) {
          return a + b
        }, 0)) {
          res.push(temp)
        }
        if (target < temp.reduce(function (a, b) { //reduce遍历空数组一定需要一个初始值
          return a + b
        }, 0)) {
          return
        }
        for (let i = index; i < candidates.length; i++) {
          temp.push(candidates[i])
          backTrack(temp.slice(), target, i) //slice对于一维基本类型数组是深拷贝
          temp.pop()
        }
      }
      backTrack(temp, target, 0)
      return res
    };
    //console.log(combinationSum([2, 3, 5], 8),'回溯算法求组合')

    //验证一个数是否是素数
    //质数又称素数。一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。
    // 如果这个数是 2 或 3，一定是素数；
    // 如果是偶数，一定不是素数；
    // 如果这个数不能被3~它的平方根中的任一数整除，m必定是素数。而且除数可以每次递增2（排除偶数）
    function isPrime(num) {
      // 不是数字或者数字小于2
      if (typeof num !== "number" || !Number.isInteger(num)) { // Number.isInterget 判断是否为整数
        return false;
      }

      if (num === 2 || num === 3) {
        return true;
      };
      if (num % 2 === 0) {
        return false;
      };
      //依次判断是否能被奇数整除，最大循环为数值的开方
      var squareRoot = Math.sqrt(num);
      //因为2已经验证过，所以从3开始；且已经排除偶数，所以每次加2
      for (var i = 3; i <= squareRoot; i += 2) {
        if (num % i === 0) {
          return false;
        }
      }
      return true;
    }

    //求最大公约数
    function greatestCommonDivisor(a, b) {
      let divisor = 2,
        res = 1;
      if (a < 2 || b < 2) {
        return 1;
      };
      while (a >= divisor && b >= divisor) {
        if (a % divisor === 0 && b % divisor === 0) {
          res = divisor;
        }
        divisor++;
      }
      return res;
    };

    //加油站
    // 在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

    // 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i + 1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

    // 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 - 1。

    // 说明:

    // 如果题目有解，该答案即为唯一答案。
    // 输入数组均为非空数组，且长度相同。
    // 输入数组中的元素均为非负数。
    // 输入:
    // gas = [1, 2, 3, 4, 5]
    // cost = [3, 4, 5, 1, 2]

    // 输出: 3

    // 解释:
    // 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
    // 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
    // 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
    // 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
    // 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
    // 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
    // 因此，3 可为起始索引。
    // 示例 2:

    // 输入:
    // gas = [2, 3, 4]
    // cost = [3, 4, 3]

    // 输出: -1

    // 解释:
    // 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
    // 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
    // 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
    // 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
    // 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
    // 因此，无论怎样，你都不可能绕环路行驶一周。

    var canCompleteCircuit = function (gas, cost) {
      //思路：贪心算法，每个加油站我都把加油站的油加到车里；
      //首先找到所有能作为起点的加油站（也就是当前加油站存储的油量支持我走到下一站 gas[i] >= cost[i]），位置放到originalingStation中
      //遍历每个起点加油站，看它作为起点是否能走一圈，storage存储量，consumption消耗量，while循环，存储量要一直大于等于消耗量，而且最多走一圈（不然会出现死循环）
      //等到条件不满足退出while时，判断当前是否安稳走了一圈，若是直接返回位置即可，若不是找下一个出发点
      //若出发点都不满足（for循环走到头），则返回-1
      let originalingStation = [];
      const len = gas.length;
      for (let i = 0; i < len; i++) {
        if (gas[i] >= cost[i]) originalingStation.push(i);
      }

      const originalLen = originalingStation.length;
      if (!originalingStation.length) return -1;
      for (let i = 0; i < originalLen; i++) {
        let x = originalingStation[i];
        let storage = gas[x], //存储量
          consumption = cost[x]; //消耗量
        let j = (x >= len - 1) ? 0 : x + 1;
        while (storage >= consumption && j !== x) {
          storage += gas[j];
          consumption += cost[j];
          j = (j >= len - 1) ? 0 : j + 1;
        }
        if (j === x && storage >= consumption) return j;
      }
      return -1;
    };

    //Object.create的基本原理
    function create(obj) {
      function F() {

      }
      F.prototype = obj
      return new F()
    }

    //实现一个基本的 Event Bus
    // 组件通信，一个触发与监听的过程
    class EventEmitter {
      constructor() {
        // 存储事件
        this.events = this.events || new Map()
      }
      // 监听事件
      addListener(type, fn) {
        if (!this.events.get(type)) {
          this.events.set(type, fn)
        }
      }
      // 触发事件
      emit(type) {
        let handle = this.events.get(type)
        handle.apply(this, [...arguments].slice(1))
      }
    }

    // // 测试
    // let emitter = new EventEmitter()
    // // 监听事件
    // emitter.addListener('ages', age => {
    //   console.log(age)
    // })
    // // 触发事件
    // emitter.emit('ages', 18)  // 18

    //rem 基本设置
    // 提前执行，初始化 resize 事件不会执行
    setRem()
    // 原始配置
    function setRem() {
      let doc = document.documentElement
      let width = doc.getBoundingClientRect().width
      let rem = width / 75 //75是设计图宽度
      doc.style.fontSize = rem + 'px'
    }
    // 监听窗口变化
    addEventListener("resize", setRem)

    //实现一个简单的路由
    // <a id="black" href="#/black">black</a>
    // <a id="red" href="#/red">red</a>
    // <a id="yellow" href="#/yellow">yellow</a>
    //hash模式
    function Router() {
      this.route = {};
      this.currentUlr = '';
      this.init();
    }
    Router.prototype.router = function (path, cb) {
      this.route[path] = cb || function () { };
    }

    Router.prototype.freshRoute = function () {
      this.currentUlr = window.location.hash.slice(1);
      this.route[this.currentUlr] && this.route[this.currentUlr]();
    }

    Router.prototype.init = function () {
      window.addEventListener('load', this.freshRoute.bind(this), false);
      window.addEventListener('hashchange', this.freshRoute.bind(this), false);
    }

    var router = new Router();
    router.router('/black', function () {
      document.querySelector('body').style.backgroundColor = 'black';
    })
    router.router('/red', function () {
      document.querySelector('body').style.backgroundColor = 'red';
    })
    router.router('/yellow', function () {
      document.querySelector('body').style.backgroundColor = 'yellow';
    })

    //history模式
    // // baseUrl 是根路径
    // var app = document.getElementById("app"), baseUrl = "/router/";

    //   function RouterClass(opts) {
    //     this.routes = {};
    //     this.curUrl = "";
    //     this.mode = "";
    //     if (opts) {
    //       this.mode = opts.mode;
    //       if (this.mode === 'history') {
    //         this.eventHistoryRouter();
    //       } else {
    //         this.eventHashRouter();
    //       }
    //     } else {
    //       this.eventHashRouter();
    //     }
    //   }

    //   RouterClass.prototype.route = function (path, callback) {
    //     this.routes[path] = callback || function () { }
    //   }

    //   // 监听hash模式路由
    //   RouterClass.prototype.eventHashRouter = function () {
    //     // 监听load事件，防止刷新页面数据丢失
    //     window.addEventListener("load", this.hashRouter.bind(this));
    //     window.addEventListener("hashchange", this.hashRouter.bind(this))
    //   }

    //   //hash模式
    //   RouterClass.prototype.hashRouter = function () {
    //     this.curUrl = window.location.hash.slice(1) || '/';
    //     // console.log(this.curUrl);
    //     this.routes[this.curUrl]();
    //   }

    //   // history模式
    //   RouterClass.prototype.historyRouter = function () {
    //     this.curUrl = window.location.pathname;
    //     this.routes[this.curUrl]();
    //   }

    //   // 监听history模式
    //   RouterClass.prototype.eventHistoryRouter = function () {
    //     window.addEventListener("load", this.historyRouter.bind(this));
    //     // 监听回退事件  打个比方：就是你点浏览器那个返回的箭头按钮时触发的事件
    //     window.addEventListener("popstate", this.historyRouter.bind(this));
    //   }

    //   // push模式页面跳转
    //   RouterClass.prototype.push = function (url) {
    //     if (this.mode === 'history') {
    //       window.history.pushState({}, null, url);
    //       this.routes[url]();
    //     } else {
    //       url = "#" + url;
    //       window.location.href = url;
    //     }
    //   }

    //   //replace模式页面跳转
    //   RouterClass.prototype.replace = function (url) {
    //     if (this.mode === 'history') {
    //       window.history.replaceState({}, null, url);
    //       this.routes[url]();
    //     } else {
    //       url = "#" + url;
    //       window.location.replace(url);
    //     }
    //   }

    //   var Router = new RouterClass({
    //     mode: "history"  //hash:带#号,history:不带#号
    //   });

    //   // 构造一个函数，根据url 改变 #app 中的内容，对页面进行渲染
    //   Router.route(baseUrl, function () {
    //     app.innerHTML = "首页"
    //   })
    //   Router.route(baseUrl + 'news', function () {
    //     app.innerHTML = "新闻页面"
    //   })
    //   Router.route(baseUrl + 'product', function () {
    //     app.innerHTML = "产品页面"
    //   })


    //打乱数组 leetcode
    var Solution = function (nums) {
      this.nums = nums;
    };
    Solution.prototype.reset = function () {
      return this.nums;
    };
    Solution.prototype.shuffle = function () {
      let num = this.nums.slice();
      //数组里面为非数字  不能用sort
      for (let i = 0; i < num.length; i++) {
        let index = Math.floor((i + 1) * Math.random());
        [num[index], num[i]] = [num[i], num[index]]

      }
      return num;
    };
    //arr是无序不重复的数组1到1000个数,从中随机取出一个数X,随机放入其中.请使用最快的方法找出这个数是多少?用代码表达
    // 需要了解的知识点： 异或。 同为0， 不同为该非0数， 即1 ^ 1 = 0, 5 ^ 0 = 5;

    // （
    // 三种解决方案）

    // 第一种

    // 0 ^ 1 ^ 2 ^ x ^ …… ^ 99 ^ 0 ^ 1………… 99 = x

    // 核心代码段

    // for（ int i = 1;
    // i < arr.length;
    // i++）

    // arr[0] = arr[0] ^ arr[i] //此时从arr[0]被重新赋值

    // for (int i = 0; i < arr.length - 1; i++)

    //   arr[0] = arr[0] ^ i //此时得到重复的值

    // 第二种

    // for(int i=0;i<arr.length;i++)

    //     for(int j=i+1;j<arr.length;j++)

    //             if(arr[i]==arr[j])

    //                     return arr[i];

    //     第三种

    //     由于0到99加起来是一个固定的值。所以可以用数组的和减去这个固定的值，得到重复值

    //     int sum = 0;

    //     for(int i=0;i<99;i++)

    //        sum = sum+i; //累加0到99

    //     for(int i =1;i<arr.length-1;i++)

    //         arr[0] = arr[0]+arr[i];//得到数组中所有数字的和


    //     两者相减，得到异常值

    //         int muti = arr[0] - sum;

    // muti 即为所找出的异常值

    //用原生方法实现拖动一个红色矩形方块
    // let dragDom = document.getElementById('drag');
    // let disX1, disX2, disY1, disY2
    // dragDom.onmousedown = function (e) {
    //     console.log(e, window.event, '兼容性')
    //     let ev = e || window.event
    //     //console.log(e, 'mousedown')
    //     // console.log(e.clientX,'点击的位置在视口中的横坐标')
    //     // console.log(e.clientY,'点击的位置在视口中的纵坐标')
    //     // console.log(dragDom.offsetLeft,'dom的位置在视口中的横坐标')
    //     // console.log(dragDom.offsetTop,'dom的位置在视口中的纵坐标')
    //     disX1 = ev.clientX - dragDom.offsetLeft;  //点击位置相对于dom的坐标
    //     disY1 = ev.clientY - dragDom.offsetTop;
    //     dragDom.onmousemove = function (e) {
    //         // console.log(e,'onmousemove')
    //         let ev = e || window.event
    //         disX2 = ev.clientX - dragDom.offsetLeft;  //点击位置相对于dom的坐标
    //         disY2 = ev.clientY - dragDom.offsetTop;
    //         dragDom.style.top = dragDom.offsetTop + disY2 - disY1 + 'px'
    //         dragDom.style.left = dragDom.offsetLeft + disX2 - disX1 + 'px'
    //     }
    // }

    // document.onmouseup = function () {
    //     dragDom.onmousemove = null;
    //     dragDom.onmouseup = null;
    // }


    //拖拽元素的时候，被拖拽元素会触发以下事件dragstart,drag,dragend
    //当拖拽的元素拖到一个目标元素上时，目标元素会触发以下事件dragenter,dragover,dragleave,drop
    // let dragDom = document.getElementById('drag');
    // let disX1, disX2, disY1, disY2
    // dragDom.ondragstart = function (e) {
    //   let ev = e || window.event
    //   // console.log(e.clientX,'点击的位置在视口中的横坐标')
    //   // console.log(e.clientY,'点击的位置在视口中的纵坐标')
    //   // console.log(dragDom.offsetLeft,'dom的位置在视口中的横坐标')
    //   // console.log(dragDom.offsetTop,'dom的位置在视口中的纵坐标')
    //   disX1 = ev.clientX - dragDom.offsetLeft;  //点击位置相对于dom的坐标
    //   disY1 = ev.clientY - dragDom.offsetTop;
    //   // console.log(e,'ondragstart')
    // }
    // dragDom.ondrag = function (e) {
    //   let ev = e || window.event
    //   console.log(e, 'drag')
    // }
    // dragDom.ondragend = function (e) {
    //   let ev = e || window.event
    //   disX2 = ev.clientX - dragDom.offsetLeft;  //点击位置相对于dom的坐标
    //   disY2 = ev.clientY - dragDom.offsetTop;
    //   dragDom.style.top = dragDom.offsetTop + disY2 - disY1 + 'px'
    //   dragDom.style.left = dragDom.offsetLeft + disX2 - disX1 + 'px'
    //   // console.log(e,'ondragend')
    // }

    // dom.style.left    初始空值，必须在html行内样式定义值才有值，在css样式定义仍为空值
    // 可读写，是字符串，读写是必须加px，否则无效
    // js设置之后，有值
    // 设置非整数值，会保持原样，例如 style.left = 8.22px, 输出style.left，仍然为8.22px
    // dom.offsetLeft  初始有值，只读，不可写，是数字
    // 通过style.left设置的非整数值，会四舍五入，例如 style.left = 8.22px, 属性offsetLeft, 会为 8
    // 包括 content, padding, border的完整盒子宽度，使用时要注意
    // 转换 dom.style.left = dom.offsetLeft + 'px'

    //最长回文子串
    //1.动态规划法
    // 状态定义
    // dp[i, j]：字符串s从索引i到j的子串是否是回文串
    // true： s[i, j] 是回文串
    // false：s[i, j] 不是回文串
    // 转移方程
    // dp[i][j] = dp[i + 1][j - 1] && s[i] == s[j]
    // s[i] == s[j]：说明当前中心可以继续扩张，进而有可能扩大回文串的长度
    // dp[i + 1][j - 1]：true
    // 说明s[i, j]的 ** 子串s[i + 1][j - 1] ** 也是回文串
    // 说明，i是从最大值开始遍历的，j是从最小值开始遍历的
    // 特殊情况
    // j - i < 2：意即子串是一个长度为0或1的回文串
    // 总结
    // dp[i][j] = s[i] == s[j] && (dp[i + 1][j - 1] || j - i < 2)

    function longestPalindrome(s) {
      let n = s.length;
      let res1 = ''
      let res2 = ''
      //dynamic planning
      // let dp = Array.from(new Array(n), value => {
      //     return new Array(n).fill(0)
      // }) 
      let dp1 = Array.from(new Array(n), value =>
        new Array(n).fill(0)
      )
      let dp2 = Array.from(new Array(n), value =>
        new Array(n).fill(0)
      )
      //错误遍历
      for (let i = 0; i < n; i++) {
        for (let j = i; j < n; j++) {
          if (i === 7 && j === 10) {
            //  console.log(s[i], s[j], dp1[i + 1][j - 1],
            //     '..........................') //此时dp1[i + 1][j - 1]为0 所以i要从大到小 j要从小到大
          }
          dp1[i][j] = s[i] == s[j] && (j - i < 2 || dp1[i + 1][j - 1]);
          if (dp1[i][j] && j - i + 1 > res1.length) {
            res1 = s.substring(i, j + 1);
            // console.log(res1, i, j, 'res1')
          }
        }
      }
      //正确遍历
      for (let i = n - 1; i >= 0; i--) {
        for (let j = i; j < n; j++) {
          dp2[i][j] = s[i] == s[j] && (j - i < 2 || dp2[i + 1][j - 1]);
          if (dp2[i][j] && j - i + 1 > res2.length) {
            res2 = s.substring(i, j + 1);
            //  console.log(res2, i, j, 'res2')
          }
        }
      }
      //  console.log(dp1, dp2, res1, res2, 'dp')

    }

    //2.中心扩展法
    //       思路
    // 回文串一定是对称的
    // 每次选择一个中心，进行中心向两边扩展比较左右字符是否相等
    // 中心点的选取有两种
    // aba，中心点是b
    // aa，中心点是两个a之间
    // 所以共有两种组合可能
    // left：i，right：i
    // left：i，right：i+1
    var longestPalindrome = function (s) {
      if (!s || s.length < 2) {
        return s;
      }
      let start = 0,
        end = 0;
      let n = s.length;
      // 中心扩展法
      let centerExpend = (left, right) => {
        while (left >= 0 && right < n && s[left] == s[right]) {
          left--;
          right++;
        }
        return right - left - 1;
      }
      for (let i = 0; i < n; i++) {
        let len1 = centerExpend(i, i);
        let len2 = centerExpend(i, i + 1);
        // 两种组合取最大回文串的长度
        let maxLen = Math.max(len1, len2);
        if (maxLen > end - start) {
          // 更新最大回文串的首尾字符索引
          start = i - ((maxLen - 1) >> 1); //相当于/2然后Math.floor
          end = i + (maxLen >> 1);
        }
      }
      return s.substring(start, end + 1);
    };


    //     实现LRU算法:LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择内存中最近最久未使用的页面予以淘汰。
    // 使用案例
    // vue 2.6 keep - alive的实现原理和缓存策略法
    // 多点登录，限制一个账号允许登录 5 个端，那么第 6 个端登录时，就需要挤掉最早登录的那个端。
    // 实现一个LRU过期算法的KV cache, 所有KV过期间隔相同, 满足如下性质:

    // 最多存储n对KV;
    // 如果大于n个, 则随意剔除一个已经过期的KV;
    // 如果没有过期的KV, 则按照LRU的规则剔除一个KV;
    // 查询时如果已经过期, 则返回空;
    //1.es5实现的简单LRU算法
    // var LRUCache = function (capacity) {
    //   this.cache = new Map();
    //   this.capacity = capacity;
    // };

    // LRUCache.prototype.get = function (key) {
    //   if (this.cache.has(key)) {
    //     // 存在即更新
    //     let temp = this.cache.get(key);
    //     this.cache.delete(key);
    //     this.cache.set(key, temp);
    //     return temp;
    //   }
    //   return -1;
    // };

    // LRUCache.prototype.put = function (key, value) {
    //   if (this.cache.has(key)) {
    //     // 存在即更新（删除后加入）
    //     this.cache.delete(key);
    //   } else if (this.cache.size >= this.capacity) {
    //     // 不存在即加入
    //     // 缓存超过最大值，则移除最近没有使用的
    //     this.cache.delete(this.cache.keys().next().value);
    //   }
    //   this.cache.set(key, value);
    // };
    //2.es6实现的LRU算法
    class LRUCache {
      constructor(capacity, intervalTime) {
        this.cache = new Map();
        this.capacity = capacity;
        this.intervalTime = intervalTime;
      }
      get(key) {
        if (!this.cache.has(key)) {
          return null
        }
        const tempValue = this.cache.get(key)
        this.cache.delete(key);
        if (Date.now() - tempValue.time > this.intervalTime) {
          return null
        }
        this.cache.set(key, {
          value: tempValue.value,
          time: Date.now()
        })
        return tempValue.value
      }
      put(key, value) {
        if (this.cache.has(key)) {
          this.cache.delete(key)
        }
        if (this.cache.size >= capacity) { //满了
          const keys = this.cache.keys()
          this.cache.delete(keys.next().value)
        }
        this.cache.set(key, {
          value,
          time: Date.now()
        })
      }
    }
    //复制代码巧妙地利用了Map结构的key是有序的这个特点。普通Object的key是无序的。

    // 如何监控网页崩溃？
    // 基于 Service Worker 的崩溃统计方案
    // 随着 PWA 概念的流行，大家对 Service Worker 也逐渐熟悉起来。基于以下原因，我们可以使用 Service Worker 来实现网页崩溃的监控：

    // Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；
    // Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；
    // 网页可以通过navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。

    // 基于以上几点，我们可以实现一种基于心跳检测的监控方案：

    // p1：网页加载后，通过postMessageAPI 每5s给 sw 发送一个心跳，表示自己的在线，sw 将在线的网页登记下来，更新登记时间；
    // p2：网页在beforeunload时，通过postMessageAPI 告知自己已经正常关闭，sw 将登记的网页清除；
    // p3：如果网页在运行的过程中 crash 了，sw 中的running状态将不会被清除，更新时间停留在奔溃前的最后一次心跳；
    // sw：Service Worker 每10s查看一遍登记中的网页，发现登记时间已经超出了一定时间（比如 15s）即可判定该网页 crash 了。

    // 6.求代码输出，并说出为什么
    // var obj = {
    //     '2':3,
    //     '3':4,
    //     'length':2,
    //     'splice':Array.prototype.splice,
    //     'push':Array.prototype.push
    // }
    // obj.push(1)
    // obj.push(2)
    // obj.push(3)
    // console.log(obj)
    // obj有长度，相当于类数组，调用数组的push，
    // 会在数组的最后加一项，第一次调用，相当于长度变为3，
    // 那么下标为2的那一项被赋值为1，下标是2，当其作为对象的key值的时候，
    // 会隐式调用toString方法转为字符串2，则和obj本来有的key '2'相同，
    // 原来的key为2的value就被覆盖了。以此类推后面的2个push。

    //PresentationRequest

    //最长回文子序列
    //给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。
    var longestPalindromeSubseq = function (s) {
      const dp = Array.from(new Array(s.length), () => new Array(s.length).fill(0))
      const len = s.length
      for (let i = len - 1; i >= 0; i--) {
        for (let j = i; j < len; j++) {
          if (i == j) {
            dp[j][j] = 1
            continue
          }
          if (s[i] == s[j]) {
            dp[i][j] = dp[i + 1][j - 1] + 2
          } else {
            dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])
          }
        }
      }
      return dp[0][len - 1]
    };

    //写一个正则，根据name取cookie中的值。
    function get(name) {
      var reg = new RegExp(name + '=([^;]*)?(;|$)');
      //var reg = new RegExp(name + '=[^;]*;');   我认为正则这么写
      var res = reg.exec(document.cookie);
      if (!res || !res[1]) return '';
      try {
        if (/(%[0-9A-F]{2}){2,}/.test(res)) { //utf8编码
          return decodeURIComponent(res);
        } else { //unicode编码
          return unescape(res);
        }
      } catch (e) {
        return unescape(res);
      }
    }

    // function getCookie(cookieName) {
    //     var allcookies = document.cookie;
    //     var cookiePos = allcookies.indexOf(cookieName); //索引的长度
    //     if (cookiePos != -1) {
    //         // 把cookie_pos放在值的开始，只要给值加1即可。
    //         cookiePos += cookieName.length + 1;
    //         var cookieEnd = allcookies.indexOf(";", cookiePos);

    //         if (cookieEnd == -1) {
    //             cookieEnd = allcookies.length;
    //         }
    //         var value = decodeURI(allcookies.substring(cookiePos, cookieEnd));
    //     }
    //     return value;
    // }

    //杨辉三角
    // 输入: 5
    // 输出:
    // [
    //      [1],
    //     [1,1],
    //    [1,2,1],
    //   [1,3,3,1],
    //  [1,4,6,4,1]
    // ]
    var generate = function (numRows) {
      let res = []
      for (let i = 1; i <= numRows; i++) {
        let temp = []
        for (let j = 0; j < i; j++) {
          if (j === 0 || j === i - 1) {
            temp.push(1)
          } else {
            temp.push(res[i - 2][j - 1] + res[i - 2][j])
          }
        }
        res.push(temp)
      }
      return res
    }
    // console.log(generate(6), '杨辉三角')

    // 给定两个数组，编写一个函数来计算它们的交集。

    // 示例 1:

    // 输入: nums1 = [1, 2, 2, 1], nums2 = [2, 2]
    // 输出: [2, 2]
    // 示例 2:

    // 输入: nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]
    // 输出: [4, 9]
    // 说明：

    // 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
    // 我们可以不考虑输出结果的顺序。
    // 进阶:

    // 如果给定的数组已经排好序呢？你将如何优化你的算法？
    // 如果 nums1 的大小比 nums2 小很多，哪种方法更优？
    // 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？
    //双指针法
    var intersect = function (nums1, nums2) {
      nums1 = nums1.sort((a, b) => a - b);
      nums2 = nums2.sort((a, b) => a - b);
      let i = 0;
      let j = 0;
      let res = [];
      while (i < nums1.length && j < nums2.length) {
        if (nums1[i] < nums2[j]) {
          i++;
        } else if (nums1[i] > nums2[j]) {
          j++;
        } else {
          res.push(nums1[i]);
          i++;
          j++;
        }
      }
      return res;
    };
    //哈希表
    var intersect = function (nums1, nums2) {
      let hash = new Map()
      let res = []
      for (let i = 0; i < nums1.length; i++) {
        if (hash.has(nums1[i])) {
          hash.set(nums1[i], hash.get(nums1[i]) + 1)
        } else {
          hash.set(nums1[i], 1)
        }
      }

      for (let i = 0; i < nums2.length; i++) {
        let temp = nums2[i]
        let hashKey = hash.get(temp)
        if (hash.has(temp)) {
          res.push(temp)
          if (hashKey > 1) {
            hash.set(temp, hashKey - 1)
          } else {
            hash.delete(temp)
          }
        }
      }

      return res
    };

    //有效三角形的个数
    // 给定一个包含非负整数的数组， 你的任务是统计其中可以组成三角形三条边的三元组个数。

    // 示例 1:

    //   输入: [2, 2, 3, 4]
    // 输出: 3
    // 解释:
    //   有效的组合是:
    //   2, 3, 4(使用第一个 2)
    // 2, 3, 4(使用第二个 2)
    // 2, 2, 3
    // 注意:

    //   数组长度不超过1000。
    // 数组里整数的范围为[0, 1000]。
    var triangleNumber = function (nums) {
      nums.sort((a, b) => a - b);
      let value = 0;
      for (let i = nums.length; i > 0; i--) {
        let left = 0;
        let right = i - 1;
        while (left < right) {
          if (nums[left] + nums[right] > nums[i]) {
            value = value + (right - left);
            right = right - 1;
          } else {
            left = left + 1;
          }
        }
      }
      return value;
    };

    //两种以上方式实现已知或者未知宽度的垂直水平居中。
    // // 1
    // .wraper {
    //   position: relative;
    //   .box {
    //     position: absolute;
    //     top: 50 % ;
    //     left: 50 % ;
    //     width: 100 px;
    //     height: 100 px;
    //     margin: -50 px 0 0 - 50 px;
    //   }
    // }
    // // 2
    // .wraper {
    //   position: relative;
    //   .box {
    //     position: absolute;
    //     top: 50 % ;
    //     left: 50 % ;
    //     transform: translate(-50 % , -50 % );
    //   }
    // }
    // // 3
    // .wrapper{
    // display: flex;
    // justify-content: center;
    // align-items: center;
    // }
    // // 4
    // .wraper {
    //   display: table;
    //   .box {
    //     display: table - cell;
    //     vertical - align: middle;
    //   }
    // }

    //给定一个升序整型数组[0,1,2,4,5,7,13,15,16],找出其中连续出现的数字区间，输出为["0->2","4->5","7","13","15->16"]
    function summaryRanges(arr) {
      let res = []
      let left = arr[0]
      for (let i = 0; i < arr.length; i++) {
        if (arr[i + 1] - arr[i] !== 1) {
          if (left === arr[i]) {
            res.push(left + '')
          } else {
            res.push(left + '->' + arr[i])
          }
          left = arr[i + 1]
        }
      }
      return res
    }
    // console.log(summaryRanges([0,1,2,4,5,7,13,15,16]))

    //数组中的第K个最大元素
    // 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

    // 示例 1:

    // 输入: [3,2,1,5,6,4] 和 k = 2
    // 输出: 5
    // 示例 2:

    // 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
    // 输出: 4
    // 说明:

    // 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。
    // 方法1冒泡排序冒泡k轮
    //var findKthLargest_bubbleSort = function (nums, k) {
    //   let len = nums.length
    //   for (let i = len - 1; i > len - k - 1; i--) {
    //     for (let j = 0; j < i; j++) {
    //       if (nums[j] > nums[j + 1]) {
    //         let temp = nums[j]
    //         nums[j] = nums[j + 1]
    //         nums[j + 1] = temp
    //       }
    //     }
    //   }
    //   return nums[len - k]
    // };
    // 方法2参考快排序的快速查找
    var findKthLargest = function (nums, k) {
      let to = 0,
        from = nums.length - 1,
        key = nums[to]; //确定一个基准值
      //运用了快速排序思想 但是不都排完
      function sort(to, from) {
        let i = to,
          j = from;
        while (i < j) {
          while (nums[i] > key && i < j) { //找到第一个比key小的值
            i++
          }
          while (nums[j] <= key && i < j) { //找到第一个比key大的值
            j--
          }
          [nums[i], nums[j]] = [nums[j], nums[i]] //比key大的数放在左边  比key小的数放在右边
        }
        [nums[to], nums[j]] = [nums[j], nums[to]] //把key放在中间
        if (j === k - 1) { //j左边的始终比结果大 右边的始终比结果小
          return nums[j]
        }
        if (j > k - 1) {
          return sort(to, j - 1)
        } else {
          return sort(j + 1, from)
        }
      }
      return sort(to, from)
    };

    //方法3js构造大顶堆 - 堆排序
    var findKthLargest = function (nums, k) {
      function swap(arr, i, j) {
        var temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
      }

      function heapify(arr, x, length) {
        var l = 2 * x + 1;
        var r = 2 * x + 2;
        var largest = x;
        if (l < length && arr[l] > arr[largest]) {
          largest = l;
        }
        if (r < length && arr[r] > arr[largest]) {
          largest = r;
        }
        if (largest != x) {
          swap(arr, x, largest);
          // 递归交换以下的是否也建好堆.
          heapify(arr, largest, length);
        }
      }
      var size = nums.length;
      // 建立堆
      for (var i = parseInt(size / 2) + 1; i >= 0; i--) {
        heapify(nums, i, size);
      }
      // 排序
      for (var j = size - 1; j >= size - k; j--) {
        // 得到本次的最大，将最大的与最后一个交换位子
        swap(nums, 0, j);
        heapify(nums, 0, j);
      }
      return nums[size - k];
    }

    //最大间距
    // 给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

    // 如果数组元素个数小于 2，则返回 0。

    // 示例 1:

    // 输入: [3,6,9,1]
    // 输出: 3
    // 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
    // 示例 2:

    // 输入: [10]
    // 输出: 0
    // 解释: 数组元素个数小于 2，因此返回 0。
    //解法二：桶 + 鸽笼原理
    var maximumGap = function (nums) {
      let n = nums.length;
      if (n < 2) return 0;
      let min = Math.min(...nums);
      let max = Math.max(...nums);
      if (max - min == 0) return 0;
      let gap = Math.ceil((max - min) / (n - 1));
      let bucketsMin = new Array(n - 1).fill(Number.MAX_SAFE_INTEGER);
      let bucketsMax = new Array(n - 1).fill(-1);
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] == min || nums[i] == max) continue;
        let idx = parseInt((nums[i] - min) / gap);
        bucketsMin[idx] = Math.min(nums[i], bucketsMin[idx]);
        bucketsMax[idx] = Math.max(nums[i], bucketsMax[idx]);
      }
      let maxGap = 0;
      let pre = min;
      for (let i = 0; i < n - 1; i++) {
        if (bucketsMax[i] == -1) continue;
        maxGap = Math.max(maxGap, bucketsMin[i] - pre);
        pre = bucketsMax[i];
      }
      maxGap = Math.max(maxGap, max - pre);
      return maxGap;
    };
    //解法三：基数排序
    var maximumGap = function (nums) {
      let n = nums.length;
      if (n < 2) return 0;
      let maxDigit = Math.max(...nums).toString().length;
      let radixSort = (arr, maxDigit) => {
        let digit = 1;
        let mod = 10;
        let bucket = new Array(10);
        for (let i = 0; i < maxDigit; i++) {
          for (let j = 0; j < arr.length; j++) {
            let index = Math.floor(arr[j] / digit) % mod;
            if (bucket[index] == null) bucket[index] = [];
            bucket[index].push(arr[j]);
          }
          let pos = 0;
          for (let r = 0; r < bucket.length; r++) {
            let val = null;
            if (bucket[r]) {
              while ((val = bucket[r].shift()) != null) {
                arr[pos++] = val;
              }
            }
          }
          digit *= 10;
        }
      }
      radixSort(nums, maxDigit);
      let max = -1;
      for (let j = 1; j < n; j++) {
        let val = nums[j] - nums[j - 1];
        if (val > max) {
          max = val;
        }
      }
      return max;
    };

    //JavaScript深入之创建对象的多种方式以及优缺点
    //1.工厂模式
    function createPerson(name) {
      let o = new Object();
      o.name = name
      o.getName = function () {
        console.log(this.name)
      }
      return o
    }
    // 缺点：对象无法识别，因为所有的实例都指向一个原型
    //2. 构造函数模式
    function Person(name) {
      this.name = name;
      this.getName = function () {
        console.log(this.name);
      };
    }
    var person1 = new Person('kevin');
    // 优点： 实例可以识别为一个特定的类型l
    // 缺点： 每次创建实例时， 每个方法都要被创建一次
    //2.1 构造函数模式优化
    function Person(name) {
      this.name = name;
      this.getName = getName;
    }

    function getName() {
      console.log(this.name);
    }
    var person1 = new Person('kevin');
    // 优点： 解决了每个方法都要被重新创建的问题
    // 缺点： 这叫啥封装……
    // 3. 原型模式
    function Person(name) {

    }
    Person.prototype.name = 'keivn';
    Person.prototype.getName = function () {
      console.log(this.name);
    };
    var person1 = new Person();
    // 优点： 方法不会重新创建
    // 缺点： 1. 所有的属性和方法都共享 2. 不能初始化参数
    //3.1 原型模式优化
    function Person(name) {

    }
    Person.prototype = {
      name: 'kevin',
      getName: function () {
        console.log(this.name);
      }
    };
    var person1 = new Person();
    // 优点： 封装性好了一点
    // 缺点： 重写了原型， 丢失了constructor属性
    // 3.2 原型模式优化

    function Person(name) {

    }

    Person.prototype = {
      constructor: Person,
      name: 'kevin',
      getName: function () {
        console.log(this.name);
      }
    };

    var person1 = new Person();
    // 优点： 实例可以通过constructor属性找到所属构造函数
    // 缺点： 原型模式该有的缺点还是有
    // 4. 组合模式
    // 构造函数模式与原型模式双剑合璧。
    function Person(name) {
      this.name = name;
    }
    Person.prototype = {
      constructor: Person,
      getName: function () {
        console.log(this.name);
      }
    };
    // var person1 = new Person();
    // 优点： 该共享的共享， 该私有的私有， 使用最广泛的方式
    // 缺点： 有的人就是希望全部都写在一起， 即更好的封装性

    //实现async await
    // babel 对于 async await 配合 generator 函数，做的非常巧妙，这里面的思想我们也要去学习，如何递归的处理一个串行的 promise 链？
    // 这个技巧在axios 的源码里也有应用。平常经常用的拦截器，本质上就是一串 promise 的串行执行。
    // 当然，如果你还有余力的话，也可以继续深入的去看 generator 函数的 babel 编译源码。不强制要求，毕竟 generator 函数在开发中已经用的非常少了。
    // const getData = () => new Promise(resolve => setTimeout(() => resolve("data"), 1000))
    // function* testG() {
    //     // await被编译成了yield
    //     const data = yield getData()
    //     console.log('data: ', data);
    //     const data2 = yield getData()
    //     console.log('data2: ', data2);
    //     return 'success'
    // }
    // var gen = testG()
    // var dataPromise = gen.next()
    // console.log(dataPromise,'dataPromise')

    // dataPromise.value.then((value1) => {
    //     // data1的value被拿到了 继续调用next并且传递给data
    //     var data2Promise = gen.next(value1)
    //     // console.log('data: ', data);
    //     // 此时就会打印出data
    //     data2Promise.value.then((value2) => {
    //         // data2的value拿到了 继续调用next并且传递value2
    //         gen.next(value2)

    //         // console.log('data2: ', data2);
    //         // 此时就会打印出data2
    //     })
    // })
    // const getData = () => new Promise(resolve => setTimeout(() => resolve("data"), 1000))
    // function* testG() {
    //     // await被编译成了yield
    //     const data = yield getData()
    //     console.log('data: ', data);
    //     const data2 = yield getData()
    //     console.log('data2: ', data2);
    //     return 'success'
    // }
    // function asyncToGenerator(generator) {
    //     return function () {
    //         let gen = generator.apply(this, arguments)
    //         return new Promise((resolve, reject) => {
    //             function step(key, arg) {  //key对应generator的next throw方法
    //                 let generatorResult  //储存generator的执行结果
    //                 try {
    //                     generatorResult = gen[key][arg]
    //                 } catch (error) {
    //                     reject(error)
    //                 }
    //                 let { value, done } = generatorResult
    //                 if (!done) {
    //                     return Promise.resolve(value).then(val => {
    //                         step('next', val)
    //                     }, error => {
    //                         step('throw', error)
    //                     })
    //                 } else {
    //                     resolve(value)
    //                 }
    //             }
    //             step('next')
    //         })
    //     }
    // }
    // asyncToGenerator(testG)()

    function asyncToGenerator(generatorFunc) {
      // 返回的是一个新的函数
      return function () {

        // 先调用generator函数 生成迭代器
        // 对应 var gen = testG()
        const gen = generatorFunc.apply(this, arguments)

        // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的
        // var test = asyncToGenerator(testG)
        // test().then(res => console.log(res))
        return new Promise((resolve, reject) => {

          // 内部定义一个step函数 用来一步一步的跨过yield的阻碍
          // key有next和throw两种取值，分别对应了gen的next和throw方法
          // arg参数则是用来把promise resolve出来的值交给下一个yield
          function step(key, arg) {
            let generatorResult

            // 这个方法需要包裹在try catch中
            // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误
            try {
              generatorResult = gen[key](arg)
            } catch (error) {
              return reject(error)
            }

            // gen.next() 得到的结果是一个 { value, done } 的结构
            const {
              value,
              done
            } = generatorResult

            if (done) {
              // 如果已经完成了 就直接resolve这个promise
              // 这个done是在最后一次调用next后才会为true
              // 以本文的例子来说 此时的结果是 { done: true, value: 'success' }
              // 这个value也就是generator函数最后的返回值
              return resolve(value)
            } else {
              // 除了最后结束的时候外，每次调用gen.next()
              // 其实是返回 { value: Promise, done: false } 的结构，
              // 这里要注意的是Promise.resolve可以接受一个promise为参数
              // 并且这个promise参数被resolve的时候，这个then才会被调用
              return Promise.resolve(
                // 这个value对应的是yield后面的promise
                value
              ).then(
                // value这个promise被resove的时候，就会执行next
                // 并且只要done不是true的时候 就会递归的往下解开promise
                // 对应gen.next().value.then(value => {
                //    gen.next(value).value.then(value2 => {
                //       gen.next() 
                //
                //      // 此时done为true了 整个promise被resolve了 
                //      // 最外部的test().then(res => console.log(res))的then就开始执行了
                //    })
                // })
                function onResolve(val) {
                  step("next", val)
                },
                // 如果promise被reject了 就再次进入step函数
                // 不同的是，这次的try catch中调用的是gen.throw(err)
                // 那么自然就被catch到 然后把promise给reject掉啦
                function onReject(err) {
                  step("throw", err)
                },
              )
            }
          }
          step("next")
        })
      }
    }

    //一般的对象(object不是array)不能用for of遍历怎么解决
    function* objectEntries() {
      let propKeys = Object.keys(this);
      // console.log(propKeys,Reflect.ownKeys(this))  Reflect.ownKeys会把Symbol.iterator遍历出来
      for (let propKey of propKeys) {
        yield [propKey, this[propKey]];
      }
    }
    let jane = {
      first: 'Jane',
      last: 'Doe'
    };
    jane[Symbol.iterator] = objectEntries;
    for (let [key, value] of jane) {
      // console.log(`${key}: ${value}`);
    }

    //Koa的洋葱中间件，Redux的中间件，Axios的拦截器让你迷惑吗？实现一个精简版的就彻底搞懂了。
    //Axios的拦截器的基本原理:先构造一个对象 存放拦截器
    // axios.interceptors = {
    //   request: [],
    //   response: []
    // };

    // // 注册请求拦截器
    // axios.useRequestInterceptor = (resolved, rejected) => {
    //   axios.interceptors.request.push({
    //     resolved,
    //     rejected
    //   });
    // };

    // // 注册响应拦截器
    // axios.useResponseInterceptor = (resolved, rejected) => {
    //   axios.interceptors.response.push({
    //     resolved,
    //     rejected
    //   });
    // };

    // // 运行拦截器
    // axios.run = config => {
    //   const chain = [{
    //     resolved: axios,
    //     rejected: undefined
    //   }];

    //   // 把请求拦截器往数组头部推
    //   axios.interceptors.request.forEach(interceptor => {
    //     chain.unshift(interceptor);
    //   });

    //   // 把响应拦截器往数组尾部推
    //   axios.interceptors.response.forEach(interceptor => {
    //     chain.push(interceptor);
    //   });

    //   // 把config也包装成一个promise
    //   let promise = Promise.resolve(config);

    //   // 暴力while循环解忧愁
    //   // 利用promise.then的能力递归执行所有的拦截器
    //   while (chain.length) {
    //     const {
    //       resolved,
    //       rejected
    //     } = chain.shift();
    //     promise = promise.then(resolved, rejected);
    //   }

    //   // 最后暴露给用户的就是响应拦截器处理过后的promise
    //   return promise;
    // };

    //koa中间件原理
    class Koa {
      constructor() {
        this.middlewares = [];
      }
      use(middleware) {
        this.middlewares.push(middleware);
      }
      start({
        req
      }) {
        const composed = composeMiddlewares(this.middlewares);
        const ctx = {
          req,
          res: undefined
        };
        return composed(ctx);
      }
    }

    function composeMiddlewares(middlewares) {
      return function wrapMiddlewares(ctx) {
        // 记录当前运行的middleware的下标
        let index = -1;

        function dispatch(i) {
          // index向后移动
          index = i;

          // 找出数组中存放的相应的中间件
          const fn = middlewares[i];

          // 最后一个中间件调用next 也不会报错
          if (!fn) {
            return Promise.resolve();
          }

          return Promise.resolve(
            fn(
              // 继续传递ctx
              ctx,
              // next方法，允许进入下一个中间件。
              () => dispatch(i + 1)
            )
          );
        }
        // 开始运行第一个中间件
        return dispatch(0);
      };
    }

    //二叉树的右视图
    //深度优先搜索&&广度优先搜索
    var rightSideView = function (root) {
      if (!root) return []
      let arr = []
      dfs(root, 0, arr)

      function dfs(root, step, res) {
        if (root) {
          if (res.length === step) {
            res.push(root.val) // 当数组长度等于当前 深度 时, 把当前的值加入数组
          }
          // console.log(step, '-------', res)
          dfs(root.right, step + 1, res) // 先从右边开始, 当右边没了, 再轮到左边
          dfs(root.left, step + 1, res)
        }
      }
      return arr
    };

    var rightSideView = function (root) {
      if (!root) return []
      let queue = [root] // 队列 把树顶加入队列
      let arr = [] // 用来存储每层最后个元素值
      while (queue.length > 0) {
        let len = queue.length
        while (len) {
          let node = queue.shift() // 取出队列第一个元素
          if (len === 1) arr.push(node.val) // 当是 当前一层的最后一个元素时，把值加入arr
          if (node.left) queue.push(node.left) // 继续往队列添加元素
          if (node.right) queue.push(node.right)
          len--
        }
      }
      return arr
    };

    //享元模式
    //享元模式把共有的数据和方法提取出来，目的是为了提高程序的执行效率，进一步提升系统的性能。享元模式有助于减少内存消耗，在大型系统开发中应用非常广泛。

    //对称二叉树
    //给定一个二叉树，检查它是否是镜像对称的。
    //方法一:层序遍历二叉树，判断每一层的二叉树节点的值是否对称。
    var isSymmetric = function (root) {
      if (root === null) return true;
      let node = root;
      let queue = [node];

      function help(arr) {
        let left = 0,
          right = arr.length - 1;
        while (left < right) {
          if (arr[left] === null || arr[right] === null) {
            if (arr[left] !== arr[right]) {
              return false;
            }
          } else {
            if (arr[left].val !== arr[right].val) {
              return false;
            }
          }
          left++;
          right--;
        }
        return true;
      }
      while (queue.length > 0) {
        if (!help(queue)) {
          return false;
        }
        let len = queue.length;
        for (let i = 0; i < len; i++) {
          node = queue.shift();
          if (node !== null) {
            queue.push(node.left);
            queue.push(node.right);
          }
        }
      }
      return true
    };

    //方法二 递归DFS。

    var isSymmetric = function (root) {
      if (root === null) return true;
      return help(root.left, root.right);

      function help(left, right) {
        if (left === null && right === null) {
          return true;
        }
        if (left === null || right === null) {
          return false;
        }
        return left.val === right.val && help(left.left, right.right) && help(left.right, right.left);
      }
    };

    //方法三 BFS

    var isSymmetric = function (root) {
      let queue = [root, root];
      while (queue.length > 0) {
        let l = queue.shift();
        let r = queue.shift();
        if (l === null && r === null) continue;
        if (l === null || r === null) return false;
        if (l.val !== r.val) return false;
        queue.push(l.left);
        queue.push(r.right);
        queue.push(l.right);
        queue.push(r.left);
      }
      return true
    };

    //格雷编码
    /**
     * @param {number} n
     * @return {number[]}
     */
    var grayCode = function (n) {
      const strToNum = str => {
        let num = 0
        let len = str.length
        for (let i = 0; i < len; i++) {
          if (str[i] === '1') {
            num += 2 ** (n - i - 1)
          }
        }
        return num
      }

      let res = [0]
      let arr = Array(n).fill(0)
      let set = new Set()
      set.add(arr.join(''))
      while (res.length < 2 ** n) {
        let temp = arr.slice()
        for (let i = 0; i < n; i++) {
          temp[i] ^= 1 // 异或操作，1变0，0变1 
          let str = temp.join('')
          if (set.has(str)) {
            temp[i] = arr[i] // 若已存在，则变回去
          } else {
            set.add(str)
            res.push(strToNum(str))
            arr = temp
            break;
          }
        }
      }

      return res
    };

    //二叉搜索树的最近公共祖先
    var lowestCommonAncestor = function (root, p, q) {
      var val = root.val
      var pVal = p.val
      var qVal = q.val
      if (pVal > qVal) {
        var tmp = qVal
        qVal = pVal
        pVal = tmp
      }

      //第一种情况：左子树一个，右字数一个
      if (pVal < val && qVal > val) {
        return root
      }
      //第二种情况：都在左子树
      if (pVal < val && qVal < val) {
        return lowestCommonAncestor(root.left, p, q)
      }

      //第三种情况：都在右子树
      if (pVal > val && qVal > val) {
        return lowestCommonAncestor(root.right, p, q)
      }
      //第四种情况：有一个值等于root的值
      if (pVal === val || qVal === val) {
        return root
      }

    };

    // 重建二叉树
    //输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
    var buildTree = function (preorder, inorder) {
      if (!preorder) {
        return null
      }
      if (preorder.length === 0) {
        return null
      }
      if (preorder.length === 1) {
        return new TreeNode(preorder[0])
      }
      let root = preorder[0] //根节点的值
      let index = inorder.indexOf(root) //中序遍历中间点的位置
      let preLeft = preorder.slice(1, index + 1) //左子树的前序遍历
      let preRight = preorder.slice(index + 1) //右子树的前序遍历
      let inLeft = inorder.slice(0, index) //左子树的中序遍历
      let inRight = inorder.slice(index + 1) //右子树的中序遍历                              
      let node = new TreeNode(root)
      node.left = buildTree(preLeft, inLeft)
      node.right = buildTree(preRight, inRight)
      return node
    };

    //二叉树的层级遍历
    //DFS
    var levelOrder = function (root) {
      if (!root) return []
      let res = []
      dfs(root, 0, res)
      return res
    };

    function dfs(root, step, res) {
      if (root) {
        if (!res[step]) res[step] = []
        res[step].push(root.val)
        dfs(root.left, step + 1, res)
        dfs(root.right, step + 1, res)
      }
    }
    //BFS

    var levelOrder = function (root) {
      if (!root) return []
      let queue = [root]
      let res = []
      while (queue.length > 0) {
        let len = queue.length
        let arr = []
        while (len) {
          let node = queue.shift()
          arr.push(node.val)
          if (node.left) queue.push(node.left)
          if (node.right) queue.push(node.right)
          len--
        }
        res.push(arr)
      }
      return res
    };

    // 求二叉树的遍历
    //给定一棵二叉树的前序遍历和中序遍历，求其后序遍历
    // let pre;
    // let vin;

    // while ((pre = readline()) != null) {
    //   vin = readline();
    //   print(getHRD(pre, vin));
    // }

    // function getHRD(pre, vin) {
    //   if (!pre) {
    //     return '';
    //   }
    //   if (pre.length === 1) {
    //     return pre;
    //   }
    //   const head = pre[0];
    //   const splitIndex = vin.indexOf(head);
    //   const vinLeft = vin.substring(0, splitIndex);
    //   const vinRight = vin.substring(splitIndex + 1);
    //   const preLeft = pre.substring(1, splitIndex + 1);
    //   const preRight = pre.substring(splitIndex + 1);
    //   return getHRD(preLeft, vinLeft) + getHRD(preRight, vinRight) + head;
    // }

    //二叉树的镜像
    function Mirror(root) {
      if (root) {
        const temp = root.right;
        root.right = root.left;
        root.left = temp;
        Mirror(root.right);
        Mirror(root.left);
      }
    }

    //二叉树的后续遍历
    // 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
    // 1.后序遍历：分成三部分：最后一个节点为根节点，第二部分为左子树的值比根节点都小，第三部分为右子树的值比根节点都大。

    // 2.先检测左子树，左侧比根节点小的值都判定为左子树。

    // 3.除最后一个节点外和左子树外的其他值为右子树，右子树有一个比根节点小，则返回false。

    // 4.若存在，左、右子树，递归检测左、右子树是否复合规范。
    function VerifySquenceOfBST(sequence) {
      if (sequence && sequence.length > 0) {
        var root = sequence[sequence.length - 1]
        for (var i = 0; i < sequence.length - 1; i++) {
          if (sequence[i] > root) {
            break;
          }
        }
        for (let j = i; j < sequence.length - 1; j++) {
          if (sequence[j] < root) {
            return false;
          }
        }
        var left = true;
        if (i > 0) {
          left = VerifySquenceOfBST(sequence.slice(0, i));
        }
        var right = true;
        if (i < sequence.length - 1) {
          right = VerifySquenceOfBST(sequence.slice(i, sequence.length - 1));
        }
        return left && right;
      }
    }
    // 小和问题
    // 在一个数组中， 每一个数左边比当前数小的数累加起来， 叫做这个数组的小和。 求一个数组
    // 的小和。
    // 例子：
    // [1, 3, 4, 2, 5]
    // 1左边比1小的数， 没有；
    // 3左边比3小的数， 1；
    // 4左边比4小的数， 1、 3；
    // 2左边比2小的数， 1；
    // 5左边比5小的数， 1、 3、 4、 2；
    // 所以小和为1 + 1 + 3 + 1 + 1 + 3 + 4 + 2=16
    // 如果直接用两层for循环扫一遍，时间复杂度O(n * n) ，这个题目可以利用归并排序把时间复杂度降到O(nlogn)
    let smallNumber = 0

    function smallSum(arr) {
      if (arr.length <= 1) {
        return arr
      }
      let mid = arr.length >> 1
      let left = arr.slice(0, mid)
      let right = arr.slice(mid)
      return merge(smallSum(left), smallSum(right))

      function merge(left, right) {
        let i = 0;
        let j = 0;
        let arr = []
        while (i <= left.length - 1 && j <= right.length - 1) {
          if (left[i] < right[j]) {
            arr.push(left[i])
            smallNumber += arr.reduce(function (a, b) {
              return a + b
            }, 0)
            i++
          } else {
            arr.push(right[j])
            j++
          }
        }
        while (i <= left.length - 1) {
          smallNumber += arr.reduce(function (a, b) {
            return a + b
          }, 0)
          arr.push(left[i])
          i++
        }
        while (j <= right.length - 1) {
          // smallNumber += arr.reduce(function (a, b) {
          //     return a + b
          //   }, 0)
          arr.push(right[j])
          j++
        }
        return arr
      }
    }
    // smallSum([1, 3, 4])   //有bug
    // console.log(smallNumber, '小和')

    //实现 strStr()
    // 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
    //KMP算法  http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html     二进制字符串匹配（普通字符串匹配更推荐 BM 算法
    //BM算法   http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html

    function getNext(str) {
      const len = str.length,
        next = new Array(len).fill(0); //默认下一跳回到0
      for (let i = 0; i < len; i++) {
        const subStr = str.slice(0, i);
        for (let j = 0; j < i - 1; j++) {
          //判断前缀和后缀的情况，存储当j位不匹配时，下一跳的位置，自动更新保证最大值
          console.log(subStr, subStr.slice(0, j + 1), subStr.slice(i - j - 1), '--------------------')
          if (subStr.slice(0, j + 1) === subStr.slice(i - j - 1)) {
            next[i] = j + 1;
          }
        }
      }
      return next;
    }
    // function getNext(source) {   //'ABCDABD'
    //   let next = new Array(source.length).fill(0)
    //   let i = 1
    //   let j = 0
    //   while (i < source.length) {
    //     if (source.charAt(i) === source.charAt(j)) {
    //       next[i] = ++j
    //     } else if (source.charAt(i) === source.charAt(0)) {
    //       j = 1
    //       next[i] = next[i - 1]
    //     } else {
    //       next[i] = j = 0
    //     }
    //     i++
    //   }
    //   return next
    // }
    /**
     * @param sourceStr 主字符串
     * @param searchStr 模式字符串
     * */
    function KMP(sourceStr, searchStr) {
      const sourceLen = sourceStr.length,
        searchLen = searchStr.length,
        next = getNext(searchStr);
      //i为源字符串的指针，j为目标字符串的指针
      let i = 0,
        j = 0;

      while (i < sourceLen && j < searchLen) {
        if (sourceStr[i] === searchStr[j]) {
          ++i;
          ++j;
        } else {
          //这里用于判断当前指针的位置，如果指针已经在0了，表示模式字符串的第一位都不匹配，主字符串的指针往后移一位
          if (j === 0) {
            ++i;
            continue;
          }
          j = next[j - 1];
        }
      }

      if (j === searchLen) {
        return i - j;
      } else {
        return -1;
      }
    }
    // console.log(getNext('ABCDABD'));
    // console.log(KMP('BBC ABCDAB ABCDABCDABDE', 'ABCDABD'));

    //二叉树的序列化与反序列化
    //二叉树的序列化
    function Serialize(root, arr = []) {
      if (!root) {
        arr.push('#')
        return
      }
      arr.push(root.value)
      Serialize(root.left, arr)
      Serialize(root.right, arr)
      return arr.join(',')
    }
    //二叉树的反序列化
    function Deserialize(s) {
      if (!s) {
        return null;
      }
      return deserialize(s.split(','));
    }

    function deserialize(arr) {
      let node = null;
      const current = arr.shift();
      if (current !== '#') {
        node = {
          val: current
        }
        node.left = deserialize(arr);
        node.right = deserialize(arr);
      }
      return node;
    }

    //按之字型打印二叉树
    function Print(pRoot) {
      const lists = [];

      if (pRoot === null) {
        return lists;
      }

      const stack1 = [];
      const stack2 = [];

      stack2.push(pRoot);
      let i = 1;
      while (stack1.length !== 0 || stack2.length !== 0) {
        const list = [];

        // 为奇数层
        if ((i & 1) === 1) {
          while (stack2.length !== 0) {
            const tmp = stack2[stack2.length - 1];
            stack2.pop();
            list.push(tmp.val);
            if (tmp.left !== null) stack1.push(tmp.left);
            if (tmp.right !== null) stack1.push(tmp.right);
          }
        }
        // 为偶数层
        else {
          while (stack1.length !== 0) {
            const tmp = stack1[stack1.length - 1];
            stack1.pop();
            list.push(tmp.val);
            if (tmp.right !== null) stack2.push(tmp.right);
            if (tmp.left !== null) stack2.push(tmp.left);
          }
        }
        ++i;
        lists.push(list);
      }
      return lists;
    }

    //删除链表中重复的节点
    // 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，
    // 重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
    // function deleteDuplication(head) {
    //   if (!head || !head.next) {
    //     return head
    //   } else if (head.value === head.next.value) { //如果从第一项开始重复
    //     head = head.next.next
    //     return deleteDuplication(head)
    //   } else { //如果第一项不重复
    //     head.next = deleteDuplication(head.next)
    //     return head
    //   }
    //   return head
    // }
    function deleteDuplication(pHead) {
      if (!pHead || !pHead.next) {
        return pHead;
      } else if (pHead.value === pHead.next.value) {
        let tempNode = pHead.next;
        while (tempNode && pHead.value === tempNode.value) {
          tempNode = tempNode.next;
        }
        return deleteDuplication(tempNode);
      } else {
        pHead.next = deleteDuplication(pHead.next);
        return pHead;
      }
    }
    console.log(deleteDuplication(link), '删除链表中重复的值')

    //从尾到头打印链表
    //输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
    function printListFromTailToHead(head) {
      const array = [];
      while (head) {
        array.unshift(head.val);
        head = head.next;
      }
      return array;
    }

    //链表倒数第k个节点
    //输入一个链表，输出该链表中倒数第k个结点。
    // 解题思路
    // 老方法：p,q两个指针，让p先走k步，然后p,q一起走，直到p为null

    // 代码

    var getKthFromEnd = function (head, k) {
      let p = head,
        q = head;

      let i = 0;
      while (p) {
        if (i >= k) {
          q = q.next;
        }
        p = p.next;
        i++;
      }
      return i < k ? null : q;
    };

    //反转链表
    var reverseList = function (head) {
      if (!head || !head.next) return head
      var prev = null,
        curr = head
      while (curr) {
        // 用于临时存储 curr 后继节点
        var next = curr.next
        // 反转 curr 的后继指针
        curr.next = prev
        // 变更prev、curr 
        // 待反转节点指向下一个节点 
        prev = curr
        curr = next
      }
      head = prev
      return head
    };

    //输入两个链表，找出它们的第一个公共结点。   参考上面:找到两个单链表相交的起始节点
    // 1.先找到两个链表的长度length1、length2

    // 2.让长一点的链表先走length2-length1步，让长链表和短链表起点相同

    // 3.两个链表一起前进，比较获得第一个相等的节点

    // 时间复杂度O(length1+length2) 空间复杂度O(0)
    function FindFirstCommonNode(pHead1, pHead2) {
      if (!pHead1 || !pHead2) {
        return null;
      }
      // 获取链表长度
      let length1 = getLength(pHead1);
      let length2 = getLength(pHead2);
      // 长链表先行
      let lang, short, interval;
      if (length1 > length2) {
        lang = pHead1;
        short = pHead2;
        interval = length1 - length2;
      } else {
        lang = pHead2;
        short = pHead1;
        interval = length2 - length1;
      }
      while (interval--) {
        lang = lang.next;
      }
      // 找相同节点
      while (lang) {
        if (lang === short) {
          return lang;
        }
        lang = lang.next;
        short = short.next;
      }
      return null;
    }

    function getLength(head) {
      let current = head;
      let result = 0;
      while (current) {
        result++;
        current = current.next;
      }
      return result;
    }

    //约瑟夫环问题
    // 0,1,...,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字
    // 解法1: 用链表模拟环
    // 用链表模拟一个环
    // 模拟游戏场景
    // 记录头节点的前一个节点current， 以保证我们找到的要删除的节点是current.next
    // 每次循环m次找到目标节点删除， 直到链表只剩下一个节点
    // 时间复杂度O(m * n) 空间复杂度O(n)
    function LastRemaining_Solution(n, m) {
      if (n < 1 || m < 1) {
        return -1;
      }
      const head = {
        val: 0
      }
      let current = head;
      for (let i = 1; i < n; i++) {
        current.next = {
          val: i
        }
        current = current.next;
      }
      current.next = head;

      while (current.next != current) {
        for (let i = 0; i < m - 1; i++) {
          current = current.next;
        }
        current.next = current.next.next;
      }
      return current.val;
    }

    //求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
    function Sum_Solution(n) {
      return n && (n + Sum_Solution(n - 1));
    }

    //最小路径和
    // 给定一个包含非负整数的 m x n 网格， 请找出一条从左上角到右下角的路径， 使得路径上的数字总和为最小。
    // 说明： 每次只能向下或者向右移动一步。
    // 示例:
    //   输入: [
    //     [1, 3, 1],
    //     [1, 5, 1],
    //     [4, 2, 1]
    //   ]
    // 输出: 7
    // 解释: 因为路径 1→ 3→ 1→ 1→ 1 的总和最小。
    // 思路
    // 状态定义：
    // 设dp[i][j]为走到当前位置的最小路径和
    // 递推公式：
    // 只能向下或向右走，意味着当前格子只能由上边或者左边走过来
    // dp[i][j] = Min(dp[i-1][j],dp[i][j-1]) + grid[i][j]
    // 初始化
    // 第一行第n列和第一列第n行为均原数组值
    // 边界条件
    // 格子有边界，因此当i==0 或j==0时，i-1和j-1会越界
    // i = 0，j != 0时,dp[i][j] = dp[i][j-1]+grid[i][j]
    // i !=0，j == 0时,dp[i][j] = dp[i-1][j]+grid[i][j]
    // i !=0 && j != 0时,dp[i][j] = Min(dp[i-1][j],dp[i][j-1])+grid[i][j]
    // i == 0 && j == 0时,dp[i][j]=grid[i][j]
    // 返回值
    // dp最后一个元素值
    /**
     * @param {number[][]} grid
     * @return {number}
     */
    var minPathSum = function (grid) {
      var n = grid.length;
      var m = grid[0].length;
      var dp = Array.from(new Array(n), () => new Array(m));
      for (var i = 0; i < n; i++) {
        for (var j = 0; j < m; j++) {
          if (i != 0 && j != 0) {
            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
          } else if (i == 0 && j != 0) {
            dp[i][j] = dp[i][j - 1] + grid[i][j];
          } else if (i != 0 && j == 0) {
            dp[i][j] = dp[i - 1][j] + grid[i][j];
          } else if (i == 0 && j == 0) {
            dp[i][j] = grid[i][j];
          }
        }
      }
      return dp[n - 1][m - 1];
    };
    //打家劫舍
    // 你是一个专业的小偷， 计划偷窃沿街的房屋。 每间房内都藏有一定的现金， 
    //影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
    //如果两间相邻的房屋在同一晚上被小偷闯入， 系统会自动报警。

    // 给定一个代表每个房屋存放金额的非负整数数组， 计算你在不触动警报装置的情况下， 能够偷窃到的最高金额。

    // 示例 1:

    //   输入: [1, 2, 3, 1]
    // 输出: 4
    // 解释: 偷窃 1 号房屋(金额 = 1)， 然后偷窃 3 号房屋(金额 = 3)。
    // 偷窃到的最高金额 = 1 + 3 = 4。
    // 示例 2:

    //   输入: [2, 7, 9, 3, 1]
    // 输出: 12
    // 解释: 偷窃 1 号房屋(金额 = 2), 偷窃 3 号房屋(金额 = 9)， 接着偷窃 5 号房屋(金额 = 1)。
    // 偷窃到的最高金额 = 2 + 9 + 1 = 12。
    //方法一  一维动态规划
    var rob = function (nums) {
      var len = nums.length;
      if (len < 2) {
        return nums[len - 1] ? nums[len - 1] : 0;
      }
      var current = [nums[0], Math.max(nums[0], nums[1])];
      for (var k = 2; k < len; k++) {
        current[k] = Math.max(current[k - 2] + nums[k], current[k - 1]);
      }
      return current[len - 1];
    };
    //方法二
    // 第i个偷
    // dp[i][1]，增加维度，二维1代表偷当前i房
    // 第i个不偷
    // dp[i][0]，增加维度，二维0代表不偷当前i房
    // DP方程
    // 第i个不偷
    // dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1])
    // 不知道i-1是否能偷，偷也不违背相邻原则
    // 第i个偷
    // dp[i][1] = nums[i] + Math.max(dp[i-1][0]+0) = nums[i] + dp[i-1][0]
    // 第i房偷，则先加nums[i]之金额，且第i-1就一定不能偷，否则违背相邻原则
    // 至于dp[i-2]则不需重复考虑，因其已在dp[i-1]的子问题当中了
    // 总结状态转移方程为
    // dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]);
    // dp[i][1] = dp[i-1][0] + nums[i];
    var rob = function (nums) {
      var n = nums.length;
      if (n == 0) {
        return 0;
      } else if (n == 1) {
        return nums[0];
      }
      var dp = Array.from(new Array(n), () => new Array(n).fill(0));
      dp[0][0] = 0;
      dp[0][1] = nums[0];
      for (var i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
        dp[i][1] = dp[i - 1][0] + nums[i];
      }
      return Math.max(dp[n - 1][0], dp[n - 1][1]);
    };

    //213. 打家劫舍 II
    // 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

    // 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

    // 示例 1:

    // 输入: [2,3,2]
    // 输出: 3
    // 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
    // 示例 2:

    // 输入: [1,2,3,1]
    // 输出: 4
    // 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
    //      偷窃到的最高金额 = 1 + 3 = 4 。
    /**
     * @param {number[]} nums
     * @return {number}
     */
    // 偷第一家，不能偷最后一家
    // 不偷第一家，能偷最后一家
    var rob = function (nums) {
      var n = nums.length;
      if (n == 1) {
        return nums[0];
      } else if (n == 0) {
        return 0;
      }

      function dpGO(nums) {
        var n = nums.length;
        var dp = Array.from(new Array(n), () => new Array(n));
        dp[0][0] = 0;
        dp[0][1] = nums[0];
        for (var i = 1; i < nums.length; i++) {
          dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
          dp[i][1] = nums[i] + dp[i - 1][0];
        }
        return Math.max(dp[n - 1][0], dp[n - 1][1]);
      }
      var need1 = dpGO(nums.slice(1));
      var need2 = dpGO(nums.slice(0, nums.length - 1));
      return Math.max(need1, need2);
    };

    //337. 打家劫舍 III
    // 在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

    // 计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

    // 示例 1:

    // 输入: [3,2,3,null,3,null,1]

    //      3
    //     / \
    //    2   3
    //     \   \ 
    //      3   1

    // 输出: 7 
    // 解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
    // 示例 2:

    // 输入: [3,4,5,1,3,null,1]

    //      3
    //     / \
    //    4   5
    //   / \   \ 
    //  1   3   1

    // 输出: 9
    // 解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

    // 递归 思路
    // 打不打劫根节点，会影响打劫一棵树的收益：
    // 打劫根节点，则不能打劫左右子节点，但是能打劫左右子节点的四个子树（如果有）。
    // 不打劫根节点，则能打劫左子节点和右子节点，收益是打劫左右子树的收益之和。
    const rob = (root) => { // 打劫以root为根节点的子树的最大收益
      if (root == null) return 0;
      // 打劫包括根节点的收益，保底是root.val
      let robIncludeRoot = root.val;
      if (root.left) {
        robIncludeRoot += rob(root.left.left) + rob(root.left.right);
      }
      if (root.right) {
        robIncludeRoot += rob(root.right.left) + rob(root.right.right);
      }
      // 打劫不包括根节点的收益
      const robExcludeRoot = rob(root.left) + rob(root.right);
      // 二者取其大
      return Math.max(robIncludeRoot, robExcludeRoot);
    };
    // 记忆化递归
    // 刚才哪里做了重复计算？
    // 我们计算了 root 的四个孙子子树，又计算了 root 的左右子树，而后者会把 root 的孙子子树重复计算一遍。
    // 我们把计算过的结果存到 map。下次遇到相同的子问题时直接拿过来用，不用做重复的计算。
    const rob = (root) => {
      const memo = new Map();

      const helper = (root) => {
        if (root == null) return 0;
        // memo中有缓存的结果，直接返回它
        if (memo.has(root)) return memo.get(root);

        let robIncludeRoot = root.val;
        if (root.left) {
          robIncludeRoot += helper(root.left.left) + helper(root.left.right);
        }
        if (root.right) {
          robIncludeRoot += helper(root.right.left) + helper(root.right.right);
        }

        const robExcludeRoot = helper(root.left) + helper(root.right);

        const res = Math.max(robIncludeRoot, robExcludeRoot);
        // 保存当前子树的计算结果
        memo.set(root, res);
        return res;
      };
      return helper(root);
    };

    //不同路径
    // 一个机器人位于一个 m x n 网格的左上角（ 起始点在下图中标记为“ Start”）。

    // 机器人每次只能向下或者向右移动一步。 机器人试图达到网格的右下角（ 在下图中标记为“ Finish”）。

    // 问总共有多少条不同的路径？
    // 示例 1:

    //   输入: m = 3, n = 2
    // 输出: 3
    // 解释:
    //   从左上角开始， 总共有 3 条路径可以到达右下角。
    // 1. 向右 - > 向右 - > 向下
    // 2. 向右 - > 向下 - > 向右
    // 3. 向下 - > 向右 - > 向右
    // 示例 2:

    //   输入: m = 7, n = 3
    // 输出: 28
    var uniquePaths = function (m, n) {
      let dp = Array.from(new Array(m), () => new Array(n).fill(1))
      //定义左上角的坐标为(0,0) 右下角的坐标(m-1,n-1)
      //dp[i][j] 表示(0,0)到坐标为(i,j)的走法
      for (i = 0; i <= m - 1; i++) {
        for (j = 0; j <= n - 1; j++) {
          if (i === 0 && j === 0) {
            dp[i][j] = 1
          } else if (i === 0 && j > 0) {
            dp[i][j] = 1
          } else if (i > 0 && j === 0) {
            dp[i][j] = 1
          } else {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
          }

        }
      }
      return dp[m - 1][n - 1]
    };

    //不同路径 II
    // 一个机器人位于一个 m x n 网格的左上角（ 起始点在下图中标记为“ Start”）。

    // 机器人每次只能向下或者向右移动一步。 机器人试图达到网格的右下角（ 在下图中标记为“ Finish”）。

    // 现在考虑网格中有障碍物。 那么从左上角到右下角将会有多少条不同的路径？
    // 输入: [
    //   [0, 0, 0],
    //   [0, 1, 0],
    //   [0, 0, 0]
    // ]
    // 输出: 2
    // 解释:
    //   3 x3 网格的正中间有一个障碍物。
    // 从左上角到右下角一共有 2 条不同的路径：
    // 1. 向右 - > 向右 - > 向下 - > 向下
    // 2. 向下 - > 向下 - > 向右 - > 向右
    // 既然是障碍物，说明此路不通，即经过此节点的路径数为0，所以当遇到障碍物时，设置dp[i][r] = 0即可
    // 那么第一行第一列数据初始化的时候就不能都是1了，因为有的地方有障碍物存在
    // 初始化dp二维数组的时候各个节点都不可达
    // 这样dp递推的时候，只需要在62题的基础上加上obstacleGrid[i][r]当前节点不为障碍物的条件即可
    // 而有障碍物的地方为0，加0也就等于没走

    /**
     * @param {number[][]} obstacleGrid
     * @return {number}
     */
    /**
     * @param {number[][]} obstacleGrid
     * @return {number}
     */
    var uniquePathsWithObstacles = function (obstacleGrid) {
      let dp = [];
      let xlen = obstacleGrid.length;
      if (xlen == 0) {
        return 0;
      }
      let ylen = obstacleGrid[0].length;
      if (ylen == 0) {
        return 1;
      }
      for (let i = 0; i < xlen; i++) {
        dp[i] = [];
      }
      dp[0][0] = 1;
      for (let i = 0; i < xlen; i++) {
        for (let j = 0; j < ylen; j++) {
          if (obstacleGrid[i][j] == 1) {
            dp[i][j] = 0;
            continue;
          }
          if (i == 0 || j == 0) {
            if (i == 0 && j == 0) {
              continue;
            }
            if (i == 0) {
              dp[i][j] = dp[0][j - 1];
            } else {
              dp[i][j] = dp[i - 1][0];
            }
          } else {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
          }
        }
      }
      return dp[xlen - 1][ylen - 1];
    };

    //买卖股票的最佳时机
    // 给定一个数组， 它的第 i 个元素是一支给定股票第 i 天的价格。

    // 如果你最多只允许完成一笔交易（ 即买入和卖出一支股票一次）， 设计一个算法来计算你所能获取的最大利润。

    // 注意： 你不能在买入股票前卖出股票。
    // 示例 1:

    //   输入: [7, 1, 5, 3, 6, 4]
    // 输出: 5
    // 解释: 在第 2 天（ 股票价格 = 1） 的时候买入， 在第 5 天（ 股票价格 = 6） 的时候卖出， 最大利润 = 6 - 1 = 5。
    // 注意利润不能是 7 - 1 = 6, 因为卖出价格需要大于买入价格； 同时， 你不能在买入前卖出股票。
    // 示例 2:

    //   输入: [7, 6, 4, 3, 1]
    // 输出: 0
    // 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
    var maxProfit = function (prices) {
      let curMin = prices[0]
      let sum = 0
      for (let i = 0; i < prices.length; i++) {
        if (prices[i] < curMin) {
          curMin = prices[i]
          continue;
        }
        sum = Math.max(prices[i] - curMin, sum)
      }
      return sum
    };

    //最长上升子序列
    // 给定一个无序的整数数组， 找到其中最长上升子序列的长度。

    // 示例:

    //   输入: [10, 9, 2, 5, 3, 7, 101, 18]
    // 输出: 4
    // 解释: 最长的上升子序列是[2, 3, 7, 101]， 它的长度是 4。

    // dp[i]：表示以nums[i]为当前最长递增子序列尾元素的长度
    var lengthOfLIS = function (nums) {
      let n = nums.length;
      if (n == 0) {
        return 0;
      }
      let dp = new Array(n).fill(1);
      let max = 0;
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
          if (nums[j] < nums[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
          }
        }
        max = Math.max(max, dp[i]);
      }
      return max;
    };

    //n皇后
    /**
     * @param {number} n
     * @return {string[][]}
     * n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
     * 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
     */

    /*
     * 回溯算法实际上一个类似枚举的搜索尝试过程，
     * 主要是在搜索尝试过程中寻找问题的解，
     * 当发现已不满足求解条件时，就“回溯”返回，
     * 尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，
     * 以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，
     * 就退回一步重新选择，这种走不通就退回再走的技术为回溯法，
     * 而满足回溯条件的某个状态的点称为“回溯点”。
     * 许多复杂的，规模较大的问题都可以使用回溯法，
     * 有“通用解题方法”的美称。
     * */

    /**
     * @param {number} n
     * @return {string[][]}
     */
    var solveNQueens = function (n) {
      const res = []
      const cols = new Set() // 垂直线的攻击位置
      const pies = new Set() // 向左对角线的攻击位置
      const nas = new Set() // 向右对角线的攻击位置
      // 递归生成皇后的位置
      const recurison = function (row, queens) {
        if (row >= n) {
          // 由于queens在reverse会被修改，所以这里clone一份
          res.push(queens.slice(0))
          return
        }
        // 遍历列
        for (let col = 0; col < n; col++) {
          // 判断是否在攻击范围，是则continue
          if (cols.has(col) || pies.has(col + row) || nas.has(col - row)) {
            continue
          }
          cols.add(col)
          pies.add(col + row)
          nas.add(col - row)
          queens.push(col)

          // drill down
          recurison(row + 1, queens)

          // reverse status
          queens.pop()
          cols.delete(col)
          pies.delete(col + row)
          nas.delete(col - row)
        }
      }
      // 生成棋盘
      const generateCheckerboard = function () {
        return res.map(queens => {
          return queens.map(q => {
            return Array(n).fill().map((k, i) => {
              return i === q ? 'Q' : '.'
            }).join('')
          })
        })
      }
      recurison(0, [])
      return generateCheckerboard()
    };


    //贪心算法
    //零钱兑换
    // 给定不同面额的硬币 coins 和一个总金额 amount。 编写一个函数来计算可以凑成总金额所需的最少的硬币个数。 如果没有任何一种硬币组合能组成总金额， 返回 - 1。

    // 示例 1:

    //   输入: coins = [1, 2, 5], amount = 11
    // 输出: 3
    // 解释: 11 = 5 + 5 + 1
    // 示例 2:

    //   输入: coins = [2], amount = 3
    // 输出: -1


    // 说明:
    //   你可以认为每种硬币的数量是无限的。

    var coinChange = function (coins, amount) {
      // 本题采用 自底向上 的动态规划解法
      /*
      首先，构造出amount+1的数组，
      之所以+1,是为了保障最后的金额（最初的原始金额）有位置可以存放
      例如：amount[11]存放着总金额11的最少金币组合
      */
      // 数组中每一项都事先赋为正无穷，便于与最小值的判断
      //dp[i] 代表金额i的最优解，即最小使用张数
      let dp = new Array(amount + 1).fill(Infinity);
      // 首先预先赋值为0，因为金额0的解法有0种
      dp[0] = 0;

      /*
      破题关键
      每种金额的解法至1金币始，循环到金额amount为止。
      每次外层for循环时，内部的for...of循环来判断是否可用现有的金币组合来组成amount金币量
      举例：amount为11，coins为[1,2,5]，则取以下解法的最小值
      coins为1时，amount[11] = 1(利用硬币金额1来解，故占一个金额的位置) + amount[11-1]（假设已知，且为最小值）
      coins为2时，amount[11] = 1(利用硬币金额2来解，故占一个金额的位置) + amount[11-2]（假设已知，且为最小值）
      coins为5时，amount[11] = 1(利用硬币金额5来解，故占一个金额的位置) + amount[11-5]（假设已知，且为最小值）
      */
      for (let i = 1; i <= amount; i++) {
        for (let coin of coins) {
          if (i - coin >= 0) {
            // dp[i]本身的解法 和 dp[当前的总金额i(即amount) - 遍历的icon] + 1(遍历的icon) 的解法的最小值
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
          }
        }
      }
      //console.log(dp,'零钱找零') 
      // 如果结果为无穷大，则无解
      return dp[amount] === Infinity ? -1 : dp[amount];
    };
    coinChange([1, 2, 5], 11)

    //柠檬水找零
    // 在柠檬水摊上，每一杯柠檬水的售价为 5 美元。
    // 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。
    // 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。
    // 注意，一开始你手头没有任何零钱。
    // 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。
    // 示例 1：
    // 输入：[5,5,5,10,20]
    // 输出：true
    // 解释：
    // 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
    // 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
    // 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
    // 由于所有客户都得到了正确的找零，所以我们输出 true。
    // 解法：贪心选择
    // 题意每张账单只能是5、10、20
    // 柠檬水均是5元一份
    // 店家自己没有零钱
    // 解法与思路
    // 当收到20时
    // 优先匹配店家手里的一张10和一张5，如有返回true
    // 店家手里的10--
    // 店家手里的5--
    // 如没有重新匹配3张15，如有返回true
    // 店家手里的5-=3
    // 如都没有返回false
    // 当收到10时
    // 优先匹配一张5如有返回true
    // 店家手里的5--，10++
    // 如没有返回false
    // 当收到5时
    // 店家手里的5++
    var lemonadeChange = function (bills) {
      var five = 0;
      var ten = 0;
      var len = bills.length;
      for (var i = 0; i < len; i++) {
        if (bills[i] == 5) {
          five++;
        } else if (bills[i] == 10) {
          if (five == 0) {
            return false
          };
          five--;
          ten++;
        } else if (bills[i] == 20) {
          if (ten > 0 && five > 0) {
            ten--;
            five--;
          } else if (five >= 3) {
            five -= 3;
          } else {
            return false;
          }
        }
      }
      return true;
    };

    //如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 
    function processString(s) {
      var arr = s.split('');
      var new_arr = arr.map((item) => {
        return item === item.toUpperCase() ? item.toLowerCase() : item.toUpperCase();
      });
      return new_arr.join('');
    }

    // K 个一组翻转链表
    // 给你一个链表， 每 k 个节点一组进行翻转， 请你返回翻转后的链表。
    // k 是一个正整数， 它的值小于或等于链表的长度。
    // 如果节点总数不是 k 的整数倍， 那么请将最后剩余的节点保持原有顺序。
    // 示例：
    // 给你这个链表： 1 - > 2 - > 3 - > 4 - > 5
    // 当 k = 2 时， 应当返回: 2 - > 1 - > 4 - > 3 - > 5
    // 当 k = 3 时， 应当返回: 3 - > 2 - > 1 - > 4 - > 5
    // 说明：
    // 你的算法只能使用常数的额外空间。
    // 你不能只是单纯的改变节点内部的值， 而是需要实际进行节点交换。
    // 限制k个
    // 用计数实现，实时更新链表需要反转部分的头、尾节点
    var reverseKGroup = function (head, k) {
      let cur = head;
      let count = 0;
      // 求k个待反转元素的首节点和尾节点
      while (cur != null && count != k) {
        cur = cur.next;
        count++;
      }
      // 足够k个节点，去反转
      if (count == k) {
        // 递归链接后续k个反转的链表头节点
        cur = reverseKGroup(cur, k);
        while (count != 0) {
          count--;
          // 反转链表
          let tmp = head.next;
          head.next = cur;
          cur = head;
          head = tmp;
        }
        head = cur;
      }
      return head;
    };

    //如何模拟实现 Array.prototype.splice

    //有序数组中的单一元素
    // 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
    // 示例 1:
    // 输入: [1, 1, 2, 3, 3, 4, 4, 8, 8]
    // 输出: 2
    // 示例 2:
    // 输入: [3, 3, 7, 7, 10, 11, 11]
    // 输出: 10
    // 注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
    function singleNonDuplicate(nums) {
      let start = 0
      let end = nums.length - 1
      while (start <= end) { //注意这个地方取等不取等和下面注释部分的关系
        let mid = start + (end - start) / 2
        let halvesAreEven = (end - mid) % 2 === 0 //除去中间项 两边元素的个数是奇数项还是偶数项
        if (nums[mid] === nums[mid + 1]) {
          if (halvesAreEven) {
            start = mid + 2
          } else {
            end = mid - 1
          }
        } else if (nums[mid] === nums[mid - 1]) {
          if (halvesAreEven) {
            end = mid - 2
          } else {
            start = mid + 1
          }
        } else {
          return nums[mid]
        }
      }
      //   console.log(start,end)
      //   return nums[end]
    }

    // 在每个树行中找最大值
    // 您需要在二叉树的每一行中找到最大的值。

    // 示例：

    // 输入:

    // 1
    //   / \
    // 3   2
    //   / \   \
    // 5   3   9

    // 输出: [1, 3, 9]

    var largestValues = function (root) {
      if (!root) return [];
      let ans = [];
      dfs(ans, root, 0);
      return ans;
    };

    function dfs(ans, root, layer) {
      if (!root) return;
      if (ans[layer] == null || ans[layer] < root.val) ans[layer] = root.val;
      if (root.left) dfs(ans, root.left, layer + 1);
      if (root.right) dfs(ans, root.right, layer + 1);
    }


    var largestValues = function (root) {
      if (!root) return [];
      let queue = [root];
      let ans = [];
      while (queue.length) {
        let len = queue.length;
        let currentMax = -Infinity;
        while (len--) {
          let node = queue.shift();
          currentMax = Math.max(currentMax, node.val);
          if (node.left) queue.push(node.left);
          if (node.right) queue.push(node.right);
        }
        ans.push(currentMax);
      }
      return ans;
    };


    // 给定正整数 n， 找到若干个完全平方数（ 比如 1, 4, 9, 16, ...）使得它们的和等于 n。 你需要让组成和的完全平方数的个数最少。
    // 示例 1:
    //   输入: n = 12
    // 输出: 3
    // 解释: 12 = 4 + 4 + 4.
    // 示例 2:
    //   输入: n = 13
    // 输出: 2
    // 解释: 13 = 4 + 9.
    var numSquares = function (n) {
      const dp = [...Array(n + 1)].map(_ => 0); // 数组长度为n+1，值均为0
      for (let i = 1; i <= n; i++) {
        dp[i] = i; // 最坏的情况就是每次+1
        for (let j = 1; i - j * j >= 0; j++) {
          dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程
        }
      }
      return dp[n];
    };

    // 阶乘后的零
    // 给定一个整数 n， 返回 n!结果尾数中零的数量。
    // 示例 1:
    //   输入: 3
    // 输出: 0
    // 解释: 3! = 6, 尾数中没有零。
    // 示例 2:
    //   输入: 5
    // 输出: 1
    // 解释: 5! = 120, 尾数中有 1 个零.
    // 说明: 你算法的时间复杂度应为 O(log n)。
    // 通过观察，我们发现如果想要结果末尾是0，必须是分解质因数之后，2 和 5 相乘才行，同时因数分解之后发现5的个数远小于2，
    //  因此我们只需要求解这n数字分解质因数之后一共有多少个5即可.
    var trailingZeroes = function (n) {
      if (n < 5) {
        return 0;
      } else {
        let k = Math.floor(n / 5);
        return k + trailingZeroes(k);
      }
    };

    var trailingZeroes = function (n) {
      let res = 0;
      while (n >= 5) {
        let k = Math.floor(n / 5);
        res += k;
        n = k;
      }
      return res;
    };

    //【leetcode系列】多数元素
    // 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n / 2 ⌋ 次的元素。
    //     var majorityElement = function(nums) {
    //     let count = 1;
    //     let majority = nums[0];
    //     for(let i = 1; i < nums.length; i++) {
    //         if (count === 0) {
    //             majority = nums[i];
    //         }
    //         if (nums[i] === majority) {
    //             count ++;
    //         } else {
    //             count --;
    //         }
    //     }
    //     return majority;
    // };

    // 作者：fe-lucifer
    // 链接：https://leetcode-cn.com/problems/majority-element/solution/169-duo-shu-yuan-su-tou-piao-suan-fa-python-js-by-/
    // 来源：力扣（LeetCode）
    // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    var majorityElement = function (nums) {
      let num, count = 0
      for (let i = 0; i < nums.length; i++) {
        if (num === nums[i]) {
          count++
        } else if (count === 0) {
          [num, count] = [nums[i], 1]
        } else {
          count--
        }
      }
      count = 0
      for (let num1 of nums) {
        if (num1 === num) {
          count++
        }
      }
      if (count > num.length / 2) {
        return num
      }
    };

    //【leetcode系列】229. 求众数 II
    // 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n / 3 ⌋ 次的元素。

    // 说明: 要求算法的时间复杂度为 O(n) ，空间复杂度为 O(1) 。

    // 示例 1:

    // 输入: [3, 2, 3]
    // 输出: [3]
    // 示例 2:

    // 输入: [1, 1, 1, 3, 4, 2, 2, 2]
    // 输出: [1, 2]

    //空间复杂度为O(n)不满足要求
    // var majorityElement = function(nums) {
    //     if (nums.length === 0) return []
    //     const map = new Map()
    //     const target = nums.length / 3
    //     for (let i = 0; i < nums.length; i++) {
    //         if (map.has(nums[i])) {
    //             map.set(nums[i], map.get(nums[i]) + 1)
    //         } else {
    //             map.set(nums[i], 1)
    //         }
    //     }
    //     const res = []
    //     for (let key of map.keys()) {
    //         if (map.get(key) > target) {
    //             res.push(key)
    //         }
    //     }
    //     return res
    // };

    //摩尔投票法
    var majorityElement = function (nums) {
      let num1 = null,
        num2 = null;
      let count1 = 0,
        count2 = 0;
      let length = nums.length;
      for (let num of nums) {
        if (num1 == num) {
          count1++;
        } else if (num2 == num) {
          count2++;
        } else if (count1 == 0) {
          [num1, count1] = [num, 1];
        } else if (count2 == 0) {
          [num2, count2] = [num, 1];
        } else {
          count1--;
          count2--;
        }
      }
      console.log(num1, num2, count1, count2, '摩尔计数法')
      count1 = 0, count2 = 0;
      for (const num of nums) {
        if (num === num1) {
          count1++;
        }
        if (num === num2) {
          count2++;
        }
      }
      let arr = [];
      if (count1 > length / 3) {
        arr.push(num1);
      }
      if (count2 > length / 3) {
        arr.push(num2);
      }
      return arr;
    };
    // majorityElement([1, 1, 1, 3, 4, 2, 2, 2])

    // 求根到叶子节点数字之和
    // var sumNumbers = function (root) {
    //   let res = []
    //   function list(root) {
    //     let str = ''
    //     if (!root.left && !root.right) {
    //       return
    //     }
    //     str += root.val
    //     if (root.left) {
    //       list(root.left)
    //     }
    //     if (root.right) {
    //       list(root.right)
    //     }
    //     res.push(str)
    //   }
    //   console.log(res)
    // };
    var sumNumbers = function (root) {
      if (!root) return 0
      let sum = 0
      recurse(root, 0)
      return sum

      function recurse(root, cur) {
        cur = cur * 10 + root.val
        if (!root.left && !root.right) sum += cur
        if (root.left) recurse(root.left, cur)
        if (root.right) recurse(root.right, cur)
      }
    };

    //删除排序数组中的重复项
    // 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
    // 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
    // 示例 1:
    // 给定数组 nums = [1, 1, 2],
    //   函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
    // 你不需要考虑数组中超出新长度后面的元素。
    // 示例 2:
    // 给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],
    //   函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
    // 你不需要考虑数组中超出新长度后面的元素。
    var removeDuplicates = function (nums) {
      if (nums.length < 2) {
        return nums
      }
      let left = 0 //慢指针
      let right = 1 //快指针
      while (right < nums.length) {
        if (nums[left] === nums[right]) {
          right++
        } else {
          nums[left + 1] = nums[right]
          left++
          right++
        }
      }
      return left + 1
    };

    // 1186. 删除一次得到子数组最大和
    // 给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。
    // 换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。
    // 注意，删除一个元素后，子数组 不能为空。
    // 请看示例：
    // 示例 1：
    // 输入：arr = [1, -2, 0, 3]
    // 输出：4
    // 解释：我们可以选出[1, -2, 0, 3]，然后删掉 - 2，这样得到[1, 0, 3]，和最大。
    // 示例 2：

    // 输入：arr = [1, -2, -2, 3]
    // 输出：3
    // 解释：我们直接选出[3]，这就是最大和。
    // 示例 3：
    // 输入：arr = [-1, -1, -1, -1]
    // 输出：-1
    // 解释：最后得到的子数组不能为空，所以我们不能选择[-1] 并从中删去 - 1 来得到 0。
    // 我们应该直接选择[-1]，或者选择[-1, -1] 再从中删去一个 - 1。
    function maximumSum(arr) {
      let len = arr.length
      let dp1 = new Array(len) //没删除元素前的连续数组最大值
      let dp2 = new Array(len) //删除元素后的连续最大值
      dp1[0] = arr[0]
      dp2[0] = -Infinity //我们不能选择[-1] 并从中删去 - 1 来得到 0 
      for (let i = 1; i < len; i++) {
        dp1[i] = Math.max(dp1[i - 1] + arr[i], arr[i])
        dp2[i] = Math.max(dp2[i - 1] + arr[i], dp1[i - 1]) //删除的项不在最后或者最后一项是删除的项
      }
      // let res = Number.MIN_VALUE  
      //MIN_VALUE 属性是 JavaScript 中可表示的最小的数（接近 0 ，但不是负数）。它的近似值为 5 x 10-324。
      let res = -Math.pow(10, 4)
      for (let i = 0; i < len; i++) {
        res = Math.max(res, Math.max(dp1[i], dp2[i]));
      }
      //console.log(dp1, dp2)
      return res;
    }


    //存在重复元素 II
    //给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。
    // var containsNearbyDuplicate = function (nums, k) {   //我的常规做法
    //   let exist = true
    //   for (let i = 0; i < nums.length; i++) {
    //     for (let j = i + 1; j < nums.length && j <= i + k; j++) {
    //       if (nums[i] === nums[j]) {
    //         return true
    //       }
    //     }
    //   }
    //   return false
    // };
    var containsNearbyDuplicate = function (nums, k) { //用map记录位置降低时间复杂度
      const map = new Map();
      for (let i = 0, n = nums.length; i < n; i++) {
        if (map.has(nums[i]) && i - map.get(nums[i]) <= k) {
          return true
        }
        map.set(nums[i], i)
      }
      return false;
    };

    // 75. 颜色分类
    // 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

    // 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

    // 注意:
    // 不能使用代码库中的排序函数来解决这道题。

    // 示例:

    // 输入: [2, 0, 2, 1, 1, 0]
    // 输出: [0, 0, 1, 1, 2, 2]
    // 进阶：

    // 一个直观的解决方案是使用计数排序的两趟扫描算法。
    // 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
    // 你能想出一个仅使用常数空间的一趟扫描算法吗？

    //计数排序
    // 计数排序就是简单的桶排序，一个桶代表数组中一个数出现的个数，
    // 所以需要一个和数组数字范围一样大的辅助数组，一般用在范围小于100的排序，时间复杂度为O(n)，
    // 空间复杂度为数组的数字范围。
    //它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 [1]  当然这是一种牺牲空间换取时间的做法，
    // function countingSort(arr, maxValue) {
    //   var bucket = new Array(maxValue + 1),
    //     sortedIndex = 0;
    //   arrLen = arr.length,
    //     bucketLen = maxValue + 1;

    //   for (var i = 0; i < arrLen; i++) {
    //     if (!bucket[arr[i]]) {
    //       bucket[arr[i]] = 0;
    //     }
    //     bucket[arr[i]]++;
    //   }
    //   console.log(bucket, 'bucket...............')
    //   for (var j = 0; j < bucketLen; j++) {
    //     while (bucket[j] > 0) {
    //       arr[sortedIndex++] = j;
    //       bucket[j]--;
    //     }
    //   }
    //   return arr;
    // }
    // console.log(sortColors([2, 0, 2, 1, 1, 0], 6))

    var sortColors = function (nums) {
      let left = 0,
        right = nums.length - 1,
        curr = 0;
      while (curr <= right) {
        if (nums[curr] === 0) {
          [nums[curr], nums[left]] = [nums[left], nums[curr]];
          //这里为什么可以自信的直接加1而不检测被调换过来的数字呢？我们可以假设被换过来的数字可能为1，2；但是如果这个数字是2，那么在之前的循环中已经被移动末尾了，所以这个数组只可能是1.
          left++;
          curr++;
          continue;
        }
        if (nums[curr] === 2) {
          [nums[curr], nums[right]] = [nums[right], nums[curr]];
          right--;
          continue;
        }
        if (nums[curr] === 1) {
          curr++;
          continue;
        }

      }
      return nums
    };
    //sortColors([2,0,1])


    // 73. 矩阵置零
    // 给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。
    // 示例 1:
    // 输入:
    // [
    //   [1, 1, 1],
    //   [1, 0, 1],
    //   [1, 1, 1]
    // ]
    // 输出:
    // [
    //   [1, 0, 1],
    //   [0, 0, 0],
    //   [1, 0, 1]
    // ]
    // 示例 2:

    // 输入:
    // [
    //   [0, 1, 2, 0],
    //   [3, 4, 5, 2],
    //   [1, 3, 1, 5]
    // ]
    // 输出:
    // [
    //   [0, 0, 0, 0],
    //   [0, 4, 5, 0],
    //   [0, 3, 1, 0]
    // ]
    // 进阶:

    // 一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
    // 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
    // 你能想出一个常数空间的解决方案吗？
    //O(m + n) 的额外空间
    var setZeroes = function (matrix) {
      let rowSet = new Set();
      let colSet = new Set();
      let rowLen = matrix.length
      let colLen = matrix[0].length;
      for (let i = 0; i < rowLen; i++) {
        for (let j = 0; j < colLen; j++) {
          if (matrix[i][j] == 0) {
            rowSet.add(i);
            colSet.add(j);
          }
        }
      }
      for (let i = 0; i < rowLen; i++) {
        for (let j = 0; j < colLen; j++) {
          if (rowSet.has(i) || colSet.has(j)) {
            matrix[i][j] = 0;
          }
        }
      }
      return matrix;
    };
    //常数空间复杂度
    var setZeroes = function (matrix) {
      let rowLen = matrix.length
      let colLen = matrix[0].length;
      for (let i = 0; i < rowLen; i++) {
        for (let j = 0; j < colLen; j++) {
          if (matrix[i][j] == 0) {
            for (let rowI = 0; rowI < rowLen; rowI++) {
              if (matrix[rowI][j] != 0) {
                matrix[rowI][j] = true;
              }
            }
            for (let colI = 0; colI < colLen; colI++) {
              if (matrix[i][colI] != 0) {
                matrix[i][colI] = true;
              }
            }
          }
        }
      }
      for (let i = 0; i < rowLen; i++) {
        for (let j = 0; j < colLen; j++) {
          if (typeof (matrix[i][j]) == 'boolean') {
            matrix[i][j] = 0;
          }
        }
      }
      return matrix;
    };

    // 78. 子集
    // 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

    // 说明：解集不能包含重复的子集。

    // 示例:

    // 输入: nums = [1, 2, 3]
    // 输出:
    // [
    //   [3],
    //   [1],
    //   [2],
    //   [1, 2, 3],
    //   [1, 3],
    //   [2, 3],
    //   [1, 2],
    //   []
    // ]
    //回溯法
    var subsets = function (nums) {
      let n = nums.length
      let res = []
      let temp = []
      let backtrack = function (temp, start) {
        //满足条件加入结果
        res.push(temp)
        //回溯
        for (let i = start; i < n; i++) {
          temp.push(nums[i])
          backtrack(temp.slice(), i + 1) //只能写i+1 不能写i++ ++i
          temp.pop()
        }
      }
      backtrack(temp, 0)
      return res
    };

    //字典排序（二进制排序） 子集
    //     要点：
    // 使用二进制映射数组元素出现的情况，1为出现，0为不出现，如 nums = [1,2,3]
    // 000 => []
    // 001 => [3]
    // 010 => [2]
    // 011 => [2,3]
    // 100 => [1]
    // 101 => [1,3]
    // 110 => [1,2]
    // 111 => [1,2,3]

    var subsets = function (nums) {
      if (nums.length === 0) return []
      let arr = [];
      let strMax = Array(nums.length).fill(1).join(''); //得到满1的二进制数
      let len = parseInt(strMax, 2); //循环次数为该二进制数对应的十进制
      let fill = '000000000000000000000000000000000000000'; //二进制补0
      for (let i = 0; i < len + 1; i++) {
        let str = (fill + i.toString(2)).slice(-nums.length); //二进制补0后裁剪
        let item = [];
        for (let j = 0; j < nums.length; j++) { //循环二进制字符串，为1则计入数组
          if (str[j] == 1) {
            item.push(nums[j])
          }
        }
        arr.push(item)
      }
      return arr;
    };

    // 190. 颠倒二进制位
    // 颠倒给定的 32 位无符号整数的二进制位。



    // 示例 1：

    // 输入: 00000010100101000001111010011100
    // 输出: 00111001011110000010100101000000
    // 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
    // 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
    // 示例 2：

    // 输入：11111111111111111111111111111101
    // 输出：10111111111111111111111111111111
    // 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
    // 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
    // 提示：

    // 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
    // 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 - 3，输出表示有符号整数 - 1073741825。

    var reverseBits = function (n) {
      return parseInt(n.toString(2).padStart(32, 0).split('').reverse().join(''), 2);
    };

    // 进阶:
    // 如果多次调用这个函数，你将如何优化你的算法？

    //算法运用
    //老鼠试毒  //鸡蛋掉落  //64匹马、8赛道，至少多少轮比赛找出速度最快的4匹马?
    // 题目
    // 面试题：有1000个一模一样的瓶子，其中有1瓶是毒药，老鼠喝了有毒的会在24h之后死亡。求最少需要多少老鼠才能在24h里找到有毒的那瓶。

    //单值二叉树
    var isUnivalTree = function (root) {
      if (!root) {
        return true
      }
      let val = root.val
      let flag = true

      function bfs(node) {
        if (node.val !== val) {
          flag = false
        }
        if (node.left) {
          bfs(node.left)
        }
        if (node.right) {
          bfs(node.right)
        }
      }
      if (root.left) {
        bfs(root.left)
      }
      if (root.right) {
        bfs(root.right)
      }
      return flag
    };

    // 移除元素
    // 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

    // 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

    // 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
    var removeElement = function (nums, val) {
      let left = 0
      let right = nums.length - 1
      while (left <= right) {
        if (nums[left] === val && nums[right] !== val) {
          [nums[left], nums[right]] = [nums[right], nums[left]]
          right--
          left++
        }
        if (nums[left] !== val) {
          left++
        }
        if (nums[right] === val) {
          right--
        }
      }
      return left
    };

    //三个有序数组的交集
    // 给出三个均为 严格递增排列 的整数数组 arr1，arr2 和 arr3。
    // 返回一个由 仅 在这三个数组中 同时出现 的整数所构成的有序数组。
    // 示例：
    // 输入: arr1 = [1, 2, 3, 4, 5], arr2 = [1, 2, 5, 7, 9], arr3 = [1, 3, 4, 5, 8]
    // 输出: [1, 5]
    // 解释: 只有 1 和 5 同时在这三个数组中出现.
    // function arraysIntersection(arr1, arr2, arr3) {
    //   let map = new Map()
    //   let res = []
    //   for (let i = 0; i < arr1.length; i++) {
    //     if (!map.has(arr1[i])) {
    //       map.set(arr1[i], 1)
    //     } else {
    //       map.set(arr1[i], map.get(arr1[i]) + 1)
    //     }
    //   }
    //   for (let i = 0; i < arr2.length; i++) {
    //     if (!map.has(arr2[i])) {
    //       map.set(arr2[i], 1)
    //     } else {
    //       map.set(arr2[i], map.get(arr2[i]) + 1)
    //     }

    //   }
    //   for (let i = 0; i < arr3.length; i++) {
    //     if (!map.has(arr3[i])) {
    //       map.set(arr3[i], 1)
    //     } else {
    //       map.set(arr3[i], map.get(arr3[i]) + 1)
    //     }
    //   }
    //   console.log(map)
    //   // const map = new Map([
    //   //   ['F', 'no'],
    //   //   ['T', 'yes'],
    //   // ]);
    //   // for(let key in map){   不能遍历map  可以用for of遍历
    //   //   console.log(key)
    //   //   if(map.get(key) ===3){
    //   //     res.push(key)
    //   //   }
    //   // }
    //   for (let [key, value] of map.entries()) {
    //     console.log(key)
    //     if (value === 3) {
    //       res.push(key)
    //     }
    //   }
    //   return res
    // }


    var arraysIntersection = function (arr1, arr2, arr3) {
      let x = y = z = 0,
        temp = [];
      while (x < arr1.length && y < arr2.length && z < arr3.length) {
        if (arr1[x] === arr2[y]) {
          if (arr1[x] === arr3[z]) {
            temp.push(arr1[x++]);
            y++;
            z++;
          } else {
            if (arr3[z] > arr1[x]) {
              x++;
              y++;
            } else {
              z++;
            }
          }
        } else {
          if (arr1[x] > arr2[y]) {
            y++;
          } else {
            x++;
          }
        }
      }
      return temp;
    };

    // console.log(arraysIntersection([1, 2, 3, 4, 5], [1, 2, 5, 7, 9], [1, 3, 4, 5, 8]))
    // 在排序数组中查找元素的第一个和最后一个位置
    // 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

    // 你的算法时间复杂度必须是 O(log n) 级别。

    // 如果数组中不存在目标值，返回[-1, -1]。

    // 示例 1:

    // 输入: nums = [5, 7, 7, 8, 8, 10], target = 8
    // 输出: [3, 4]
    // 示例 2:

    // 输入: nums = [5, 7, 7, 8, 8, 10], target = 6
    // 输出: [-1, -1]
    var searchRange = function (nums, target) {
      let res = [-1, -1];
      low = 0;
      high = nums.length - 1;
      left = 0,
        right = 0;
      if (!nums.length || nums[0] > target || nums[nums.length - 1] < target) {
        return res;
      }
      while (low < high) {
        var mid = (low + high) >> 1;
        if (nums[mid] === target) break;
        if (nums[mid] > target) {
          high = mid - 1;
        } else {
          low = mid + 1;
        }
      }
      if (nums[mid] != target) {
        return res;
      }
      left = right = mid;
      while (nums[left - 1] != target) {
        left -= 1;
      }
      while (nums[right + 1] != target) {
        right += 1;
      }
      return [left, right];
    };

    // 11. 盛最多水的容器
    // 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点(i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为(i, ai) 和(i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
    // 说明：你不能倾斜容器，且 n 的值至少为 2。
    // 图中垂直线代表输入数组[1, 8, 6, 2, 5, 4, 8, 3, 7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
    // 示例：
    // 输入：[1, 8, 6, 2, 5, 4, 8, 3, 7]
    // 输出：49

    // 46. 全排列
    // 给定一个 没有重复 数字的序列，返回其所有可能的全排列。

    // 示例:

    // 输入: [1, 2, 3]
    // 输出:
    // [
    //   [1, 2, 3],
    //   [1, 3, 2],
    //   [2, 1, 3],
    //   [2, 3, 1],
    //   [3, 1, 2],
    //   [3, 2, 1]
    // ]
    // var permute = function (nums) {  //有bug待查
    //   let res = []
    //   let temPath = []
    //   backTrack(temPath, 0)
    //   return res
    //   function backTrack(temPath, start) {
    //     if (temPath.length === 3) {
    //       res.push(temPath)
    //       return
    //     }
    //     for (let i = start === nums.length - 1 ? 0 : start; i < nums.length; i++) {
    //       if (temPath.includes(nums[i])) {
    //         continue
    //       }
    //       temPath.push(nums[i])
    //       backTrack(temPath.slice(), start + 1)
    //       temPath.pop()
    //     }
    //   }
    // };

    var permute = function (nums) {
      const list = [];
      backtrack(list, [])
      return list

      function backtrack(list, tempList) {
        if (tempList.length === nums.length) return list.push([...tempList]);
        for (let i = 0; i < nums.length; i++) {
          if (tempList.includes(nums[i])) continue;
          tempList.push(nums[i]);
          backtrack(list, tempList);
          tempList.pop();
        }
      }
    };

    // 爬楼梯
    // 假设你正在爬楼梯。 需要 n 阶你才能到达楼顶。
    // 每次你可以爬 1 或 2 个台阶。 你有多少种不同的方法可以爬到楼顶呢
    // dp[0] = 0 dp[1] = 1 dp[2] = 2
    // dp[n] = dp[n - 1] + dp[n - 2] // 到达第n阶楼梯有从n-1阶走一步和从第n-2阶走两步两种情况
    // var climbStairs = function (n) {
    //   let dp = [];
    //   dp[0] = 0, dp[1] = 1, dp[2] = 2;
    //   for (let i = 3; i <= n; i++) {
    //     dp[i] = dp[i - 2] + dp[i - 1];
    //   }
    //   return dp[n];
    // };

    // 221. 最大正方形
    // 在一个由 0 和 1 组成的二维矩阵内， 找到只包含 1 的最大正方形， 并返回其面积。

    // 示例:

    //   输入:

    // 1 0 1 0 0
    // 1 0 1 1 1
    // 1 1 1 1 1
    // 1 0 0 1 0

    // 输出: 4
    //我们使用dp[i][j]表示以matrix[i][j]为右下角的顶点的可以组成的最大正方形的边长。
    // 那么我们只需要计算所有的i，j组合，然后求出最大值即可。
    //我们用 dp(i, j)dp(i,j) 表示以 (i, j)(i,j) 为右下角，且只包含 11 的正方形的边长最大值。
    var maximalSquare = function (matrix) {
      if (matrix.length === 0) return 0;
      const dp = [];
      const rows = matrix.length;
      const cols = matrix[0].length;
      let max = Number.MIN_VALUE;

      for (let i = 0; i < rows + 1; i++) {
        if (i === 0) {
          dp[i] = Array(cols + 1).fill(0);
        } else {
          dp[i] = [0];
        }
      }

      for (let i = 1; i < rows + 1; i++) {
        for (let j = 1; j < cols + 1; j++) {
          if (matrix[i - 1][j - 1] === "1") {
            dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
            max = Math.max(max, dp[i][j]);
          } else {
            dp[i][j] = 0;
          }
        }
      }

      return max * max;
    };

    // 面试题14 - I.剪绳子
    // 给你一根长度为 n 的绳子， 请把绳子剪成整数长度的 m 段（ m、 n都是整数， n > 1 并且m > 1），
    // 每段绳子的长度记为 k[0], k[1]...k[m - 1]。 请问 k[0] * k[1] * ... * k[
    //   m - 1] 可能的最大乘积是多少？ 例如， 当绳子的长度是8时，
    // 我们把它剪成长度分别为2、 3、 3 的三段， 此时得到的最大乘积是18。
    // 示例 1：
    // 输入: 2
    // 输出: 1
    // 解释: 2 = 1 + 1, 1× 1 = 1
    // 示例 2:
    //   输入: 10
    // 输出: 36
    // 解释: 10 = 3 + 3 + 4, 3× 3× 4 = 36
    // 提示：
    // 2 <= n <= 58
    //动态规划
    var cuttingRope = function (n) {
      let dp = new Array(n + 1).fill(1) //dp[n]是n分成至少2个数的最大值
      dp[2] = 1
      for (let i = 3; i <= n; i++) {
        for (let j = 1; j < i; j++) {
          dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j])
        }
      }
      return dp[n]
    };
    //贪心
    // 8 拆分为 3+3+2，此时乘积是最大的。然后就推测出来一个整数，要拆成多个 2 和 3 的和，保证乘积最大。原理很容易理解，因为 2 和 3 可以合成任何数字，例如5=2+3，但是5 <
    // 2*3；例如6=3+3，但是6<3*3。所以根据贪心算法，就尽量将原数拆成更多的 3，然后再拆成更多的 2，保证拆出来的整数的乘积结果最大。 // 但上面的解法还有不足。如果整数 n 的形式是 3k+1，例如
    // 7。按照上面规则，会拆分成“3 + 3 + 1”。但是在乘法操作中，1 是没作用的。此时，应该将 1 和 3 变成 4，也就是“3 + 3 + 1”变成“3 + 4”。此时乘积最大。 // 综上所述，算法的整体思路是： // n 除 3
    // 的结果为 a，余数是 b // 当 b 为 0，直接将 a 个 3 相乘 // 当 b 为 1，将（a-1）个 3 相乘，再乘以 4 // 当 b 为 2，将 a 个 3 相乘，再乘以 2

    var cuttingRope = function (n) {
      if (n === 2) return 1;
      if (n === 3) return 2;
      // a的含义：n能拆成的3的个数
      const a = Math.floor(n / 3);
      const b = n % 3;

      // n是3的倍数
      if (b === 0) return Math.pow(3, a);
      // n是 3k + 1，例如7。拆成3、3、1。由于有1对结果无法有贡献，所以最后的3、1换成4
      if (b === 1) return Math.pow(3, a - 1) * 4;
      return Math.pow(3, a) * 2;
    };

    // 跳跃游戏
    // 给定一个非负整数数组， 你最初位于数组的第一个位置。

    // 数组中的每个元素代表你在该位置可以跳跃的最大长度。

    // 判断你是否能够到达最后一个位置。

    // 示例 1:

    //   输入: [2, 3, 1, 1, 4]
    // 输出: true
    // 解释: 我们可以先跳 1 步， 从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
    // 示例 2:

    //   输入: [3, 2, 1, 0, 4]
    // 输出: false
    // 解释: 无论怎样， 你总会到达索引为 3 的位置。 但该位置的最大跳跃长度是 0， 所以你永远不可能到达最后一个位置。
    var canJump = function (nums) {
      let max = 0; // 能够走到的数组下标

      for (let i = 0; i < nums.length; i++) {
        if (max < i) return false; // 当前这一步都走不到，后面更走不到了
        max = Math.max(nums[i] + i, max);
      }

      return max >= nums.length - 1
    };

    // 加油站
    // 在一条环路上有 N 个加油站， 其中第 i 个加油站有汽油 gas[i] 升。
    // 你有一辆油箱容量无限的的汽车， 从第 i 个加油站开往第 i + 1 个加油站需要消耗汽油 cost[i] 升。 你从其中的一个加油站出发， 开始时油箱为空。
    // 如果你可以绕环路行驶一周， 则返回出发时加油站的编号， 否则返回 - 1。
    // 说明:
    //   如果题目有解， 该答案即为唯一答案。
    // 输入数组均为非空数组， 且长度相同。
    // 输入数组中的元素均为非负数。
    // 示例 1:
    //   输入:
    //   gas = [1, 2, 3, 4, 5]
    // cost = [3, 4, 5, 1, 2]
    // 输出: 3
    // 解释:
    //   从 3 号加油站(索引为 3 处) 出发， 可获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
    // 开往 4 号加油站， 此时油箱有 4 - 1 + 5 = 8 升汽油
    // 开往 0 号加油站， 此时油箱有 8 - 2 + 1 = 7 升汽油
    // 开往 1 号加油站， 此时油箱有 7 - 3 + 2 = 6 升汽油
    // 开往 2 号加油站， 此时油箱有 6 - 4 + 3 = 5 升汽油
    // 开往 3 号加油站， 你需要消耗 5 升汽油， 正好足够你返回到 3 号加油站。
    // 因此， 3 可为起始索引。
    // 示例 2:
    //   输入:
    //   gas = [2, 3, 4]
    // cost = [3, 4, 3]
    // 输出: -1
    // 解释:
    //   你不能从 0 号或 1 号加油站出发， 因为没有足够的汽油可以让你行驶到下一个加油站。
    // 我们从 2 号加油站出发， 可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
    // 开往 0 号加油站， 此时油箱有 4 - 3 + 2 = 3 升汽油
    // 开往 1 号加油站， 此时油箱有 3 - 3 + 3 = 3 升汽油
    // 你无法返回 2 号加油站， 因为返程需要消耗 4 升汽油， 但是你的油箱只有 3 升汽油。
    // 因此， 无论怎样， 你都不可能绕环路行驶一周。

    var canCompleteCircuit = function (gas, cost) {
      var sum = 0,
        cur = 0,
        res = 0,
        i = 0
      while (i < gas.length) {
        sum += gas[i] - cost[i] //（1）记录整体耗油量
        cur += gas[i] - cost[i] // 记录当前路线耗油量
        if (cur < 0) { //根据官解当前路线不满足时，则向下查找，若当前路线下cur>0，则根据反证法证明该值正确
          cur = 0
          res = i + 1
        }
        i++
      }
      return sum >= 0 ? res : -1 // 根据（1）若总耗油量为负则没有找到解返回-1
    };


    //统计一个数字在排序数组中出现的次数
    function GetNumberOfK(data, k) {
      let low = 0,
        high = data.length - 1;
      let pos, count = 0;
      while (low < high) {
        let mid = Math.floor((low + high) >> 1);
        if (data[mid] === k) {
          pos = mid;
          break;
        } else if (data[mid] < k) {
          low = mid + 1;
        } else {
          high = mid - 1;
        }
      }
      if (pos !== undefined) {
        count++;
        let left = pos,
          right = pos;
        while (left--) {
          if (data[left] === k) {
            count++;
          } else {
            break;
          }
        }
        while (right++) {
          if (data[right] === k) {
            count++;
          } else {
            break;
          }
        }
        return count;
      } else return 0;
    }

    // 面试题53 - II.0～ n - 1 中缺失的数字
    // 一个长度为n - 1 的递增排序数组中的所有数字都是唯一的， 并且每个数字都在范围0～ n - 1 之内。 
    // 在范围0～ n - 1 内的n个数字中有且只有一个数字不在该数组中， 请找出这个数字。
    // 示例 1:
    //   输入: [0, 1, 3]
    // 输出: 2
    // 示例 2:
    //   输入: [0, 1, 2, 3, 4, 5, 6, 7, 9]
    // 输出: 8
    // ad地址：https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/
    // 原文地址：https://xxoo521.com/2020-03-14-missing-number/
    //0 +1 +...+n-数组的和
    var missingNumber = function (nums) {
      let left = 0,
        right = nums.length - 1;
      while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (mid === nums[mid]) {
          left = mid + 1;
        } else if (mid < nums[mid]) {
          right = mid - 1;
        }
      }

      return left;
    };

    // 300. 最长上升子序列
    // 给定一个无序的整数数组， 找到其中最长上升子序列的长度。


    // 示例:

    //   输入: [10, 9, 2, 5, 3, 7, 101, 18]
    // 输出: 4
    // 解释: 最长的上升子序列是[2, 3, 7, 101]， 它的长度是 4。
    // 说明:

    //   可能会有多种最长上升子序列的组合， 你只需要输出对应的长度即可。
    // 你算法的时间复杂度应该为 O(n2)。
    // 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗 ?
    //动态规划
    var lengthOfLIS = function (nums) {
      if (nums.length < 1) {
        return 0
      }
      let dp = new Array(nums.length).fill(1) //dp[n]表示已nums[n]结尾的最长上升子序列长度
      // dp[0] = 0  分析为什么这样不行
      // dp[1] = 1
      let max = 0
      for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
          if (nums[j] < nums[i]) {
            dp[i] = Math.max(dp[i], dp[j] + 1)
          }
        }
        max = Math.max(max, dp[i])
      }
      return max
    };
    //二分法 + 贪心
    var lengthOfLIS = function (nums) {
      let n = nums.length;
      if (n <= 1) {
        return n;
      }
      let tail = new Array(n);
      tail[0] = nums[0];
      let end = 0;
      for (let i = 1; i < n; i++) {
        if (nums[i] > tail[end]) {
          end++;
          tail[end] = nums[i];
        } else {
          let left = 0;
          let right = end;
          while (left < right) {
            let mid = left + ((right - left) >> 1);
            if (tail[mid] < nums[i]) {
              left = mid + 1;
            } else {
              right = mid;
            }
          }
          tail[left] = nums[i];
        }
      }
      return end + 1;
    };

    //搜索二维矩阵
    // 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

    // 每行中的整数从左到右按升序排列。
    // 每行的第一个整数大于前一行的最后一个整数。
    // 示例 1:

    // 输入:
    // matrix = [
    //   [1,   3,  5,  7],
    //   [10, 11, 16, 20],
    //   [23, 30, 34, 50]
    // ]
    // target = 3
    // 输出: true
    // 示例 2:

    // 输入:
    // matrix = [
    //   [1,   3,  5,  7],
    //   [10, 11, 16, 20],
    //   [23, 30, 34, 50]
    // ]
    // target = 13
    // 输出: false
    var searchMatrix = function (matrix, target) {
      if (!matrix.length || !matrix[0].length) return false;

      for (let i = 0; i < matrix.length; i++) {
        let arr = matrix[i];
        let low = 0;
        let high = arr.length - 1;

        if (target < arr[low]) return false;

        if (target <= arr[high]) {
          while (low <= high) {
            let mid = Math.floor(low + (high - low) / 2);
            if (arr[mid] > target) {
              high = mid - 1;
            } else if (arr[mid] < target) {
              low = mid + 1;
            } else {
              return true;
            }
          }
          return false;
        }
      }

      return false;
    };

    // 240. 搜索二维矩阵 II
    // 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。 该矩阵具有以下特性：
    // 每行的元素从左到右升序排列。
    // 每列的元素从上到下升序排列。
    // 示例:
    //   现有矩阵 matrix 如下：
    // [
    //   [1, 4, 7, 11, 15],
    //   [2, 5, 8, 12, 19],
    //   [3, 6, 9, 16, 22],
    //   [10, 13, 14, 17, 24],
    //   [18, 21, 23, 26, 30]
    // ]
    // 给定 target = 5， 返回 true。
    // 给定 target = 20， 返回 false。
    //无脑二分法
    var searchMatrix = function (matrix, target) {
      for (let item of matrix) {
        if (item[0] > target) return false;
        let left = 0,
          right = item.length - 1,
          mid;
        while (left <= right) {
          mid = (left + right) >> 1;
          if (item[mid] === target) return true;
          if (item[mid] > target) right = mid - 1;
          else left = mid + 1;
        }
      }
      return false;
    };
    //有脑二分法
    var searchMatrix = function (matrix, target) {
      if (!(matrix && matrix.length > 0 && typeof matrix[0][0] === 'number')) {
        return false;
      }
      if (target < matrix[0][0]) {
        return false;
      }
      let row = matrix.length - 1;
      let col = 0;
      while (col < matrix[0].length && row >= 0) {
        if (matrix[row][col] > target) {
          row--;
        } else if (matrix[row][col] < target) {
          col++
        } else {
          return true;
        }
      }
      return false;
    };

    // 50. Pow(x, n)
    // 实现 pow(x, n)， 即计算 x 的 n 次幂函数。

    // 示例 1:

    //   输入: 2.00000, 10
    // 输出: 1024.00000
    // 示例 2:

    //   输入: 2.10000, 3
    // 输出: 9.26100
    // 示例 3:

    //   输入: 2.00000, -2
    // 输出: 0.25000
    // 解释: 2 - 2 = 1 / 22 = 1 / 4 = 0.25
    // 说明:

    //   -100.0 < x < 100.0
    // n 是 32 位有符号整数， 其数值范围是[−231, 231− 1]。
    var myPow = (num, power) => {
      if (power < 0) return 1 / (num * myPow(num, -(power + 1)))
      if (power === 0) return 1
      if (power === 1) return num
      return power % 2 === 1 ?
        num * myPow(num, power - 1) :
        myPow(num * num, power / 2)
    }

    // 131. 分割回文串
    // 给定一个字符串 s， 将 s 分割成一些子串， 使每个子串都是回文串。

    // 返回 s 所有可能的分割方案。

    // 示例:

    //   输入: "aab"
    // 输出: [
    //   ["aa", "b"],
    //   ["a", "a", "b"]
    // ]
    var partition = function (s) {
      // 定义是否为回文字符串
      const isPalidrome = (str) => {
        let left = 0,
          right = str.length - 1
        while (left < right) {
          if (str.charAt(left) !== str.charAt(right)) return false
          right--
          left++
        }
        return true
      }

      // 定义回溯算法
      const backTrack = (res, str, tempRes) => {
        // 需要注意，这里必须是 tempRes 的拷贝
        if (str.length === 0) {
          res.push(tempRes.concat())
        }
        for (let i = 1; i <= str.length; i++) {
          if (isPalidrome(str.substring(0, i))) {
            tempRes.push(str.substring(0, i))
            backTrack(res, str.substring(i, str.length), tempRes)
            // 返回上一次递归时，需要去除这次递归的回文子串
            tempRes.pop()
          }
        }
      }
      let res = []
      backTrack(res, s, [])
      return res
    };
    // 单词搜索
    // 给定一个二维网格和一个单词， 找出该单词是否存在于网格中。

    // 单词必须按照字母顺序， 通过相邻的单元格内的字母构成， 其中“ 相邻” 单元格是那些水平相邻或垂直相邻的单元格。
    //  同一个单元格内的字母不允许被重复使用。
    // 示例:

    //   board = [
    //     ['A', 'B', 'C', 'E'],
    //     ['S', 'F', 'C', 'S'],
    //     ['A', 'D', 'E', 'E']
    //   ]

    // 给定 word = "ABCCED", 返回 true
    // 给定 word = "SEE", 返回 true
    // 给定 word = "ABCB", 返回 false


    // 提示：

    // board 和 word 中只包含大写和小写英文字母。
    // 1 <= board.length <= 200
    // 1 <= board[i].length <= 200
    // 1 <= word.length <= 10 ^ 3

    // 岛屿数量
    // 给你一个由 '1'（
    // 陆地） 和 '0'（
    // 水） 组成的的二维网格， 请你计算网格中岛屿的数量。

    // 岛屿总是被水包围， 并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

    // 此外， 你可以假设该网格的四条边均被水包围。

    // 示例 1:

    //   输入:
    //   11110
    // 11010
    // 11000
    // 00000
    // 输出: 1
    // 示例 2:

    //   输入:
    //   11000
    // 11000
    // 00100
    // 00011
    // 输出: 3
    // 解释: 每座岛屿只能由水平和 / 或竖直方向上相邻的陆地连接而成。
    /*
     * @lc app=leetcode id=200 lang=javascript
     *
     * [200] Number of Islands
     */
    function helper(grid, i, j, rows, cols) {
      if (i < 0 || j < 0 || i > rows - 1 || j > cols - 1 || grid[i][j] === "0")
        return;

      grid[i][j] = "0";

      helper(grid, i + 1, j, rows, cols);
      helper(grid, i, j + 1, rows, cols);
      helper(grid, i - 1, j, rows, cols);
      helper(grid, i, j - 1, rows, cols);
    }
    /**
     * @param {character[][]} grid
     * @return {number}
     */
    var numIslands = function (grid) {
      let res = 0;
      const rows = grid.length;
      if (rows === 0) return 0;
      const cols = grid[0].length;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j] === "1") {
            helper(grid, i, j, rows, cols);
            res++;
          }
        }
      }
      return res;
    };


    //     被围绕的区域
    // 给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。

    // 找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

    // 示例:

    // X X X X
    // X O O X
    // X X O X
    // X O X X
    // 运行你的函数后，矩阵变为：

    // X X X X
    // X X X X
    // X X X X
    // X O X X
    // 解释:

    // 被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。
    //  任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。
    //  如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。


    var solve = function (board) {
      let m = board.length;
      if (m == 0) {
        return
      };
      let n = board[0].length;
      let cannot = {};
      let dfs = (i, j) => {
        // 越界、标示过或者非相连O下return
        if (i < 0 || j < 0 || i == m || j == n || board[i][j] != 'O' || cannot[i + '-' + j]) {
          return;
        }
        cannot[i + '-' + j] = true;
        dfs(i - 1, j);
        dfs(i + 1, j);
        dfs(i, j - 1);
        dfs(i, j + 1);
      }
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          // 从边缘O出发寻找其相连点都标示为不可替换
          if ((i == 0 || j == 0 || i == m - 1 || j == n - 1) && board[i][j] == 'O') {
            dfs(i, j);
          }
        }
      }
      // 规避边界条件去循环
      for (let i = 1; i < m - 1; i++) {
        for (let j = 1; j < n - 1; j++) {
          if (!cannot[i + '-' + j] && board[i][j] == 'O') {
            board[i][j] = 'X';
          }
        }
      }
    };

    // 不同的二叉搜索树
    // 给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

    // 示例:

    // 输入: 3
    // 输出: 5
    // 解释:
    // 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

    // 1 3 3 2 1
    // \ / / / \ \
    // 3 2 1 1 3 2
    // / / \ \
    // 2 1 2 3
    // 设n个节点存在二叉排序树的个数是G(n)
    // 设f(i)为以i为根的二叉搜索树的个数
    // 那么G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)

    // 那么f(i)=G(i-1)*G(n-1)f(i)=G(i−1)∗G(n−1)

    // 因为是二叉搜索树，左边的子节点，都要比ii小，共有i-1i−1个；右边子节点，都要比ii大，共n-in−i个

    // 所以带入得

    // G(n)=G(0)∗G(n−1)+G(1)∗G(n−2)+...+G(n−1)∗G(0)G(n)=G(0)∗G(n−1)+G(1)∗G(n−2)+...+G(n−1)∗G(0)
    var numTrees = function (n) {
      let dp = new Array(n + 1).fill(0)
      dp[0] = 1
      dp[1] = 1
      for (let i = 2; i <= n; i++) {
        for (let j = 1; j <= i; j++) {
          dp[i] += dp[j - 1] * dp[i - j]
        }
      }
      console.log(dp)
      return dp[n]
    };


    // 二叉树展开为链表
    // 给定一个二叉树，原地将它展开为一个单链表。
    // 例如，给定二叉树

    //     1
    //    / \
    //   2   5
    //  / \   \
    // 3   4   6
    // 将其展开为：

    // 1
    //  \
    //   2
    //    \
    //     3
    //      \
    //       4
    //        \
    //         5
    //          \
    //           6

    var flatten = function (root) {
      if (!root) return;
      flatten(root.left);
      flatten(root.right);
      var temp = root.right;
      root.right = root.left;
      root.left = null;
      while (root.right) {
        root = root.right;
      }
      root.right = temp;
      return root
    }

    // 面试题49.丑数
    // 我们把只包含因子 2、 3 和 5 的数称作丑数（ Ugly Number）。 求按从小到大的顺序的第 n 个丑数。
    // 示例:
    //   输入: n = 10
    // 输出: 12
    // 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
    // 说明:

    //   1 是丑数。
    // n 不超过1690。
    // 丑数= 之前某个丑数*(2/3/5)
    // M = dp[i-1] 当前dp里最大丑数，是要找比M大的,
    // M2 从最能满足条件的小丑数开始都*2，第1个大于M的丑数，ptr2指向*2的最小丑数
    // M3 从最能满足条件的小丑数开始都*3，第1个大于M的丑数，ptr3指向*3的最小丑数
    // M5 从最能满足条件的小丑数开始都*5，第1个大于M的丑数，ptr5指向*5的最小丑数
    // dp[i] = min(M2,M3,M5);
    //动态规划
    var nthUglyNumber = function (n) {
      const res = new Array(n);
      res[0] = 1;

      let ptr2 = 0, // 下个数字永远 * 2
        ptr3 = 0, // 下个数字永远 * 3
        ptr5 = 0; // 下个数字永远 * 5

      for (let i = 1; i < n; ++i) {
        res[i] = Math.min(res[ptr2] * 2, res[ptr3] * 3, res[ptr5] * 5);
        // 说明前ptr2个丑数*2也不可能产生比i更大的丑数了
        // 所以移动ptr2
        if (res[i] === res[ptr2] * 2) {
          ++ptr2;
        }
        if (res[i] === res[ptr3] * 3) {
          ++ptr3;
        }
        if (res[i] === res[ptr5] * 5) {
          ++ptr5;
        }
      }

      return res[n - 1];
    };


    // 263. 丑数
    // 编写一个程序判断给定的数是否为丑数。

    // 丑数就是只包含质因数 2, 3, 5 的正整数。

    // 示例 1:

    // 输入: 6
    // 输出: true
    // 解释: 6 = 2 × 3
    // 示例 2:

    // 输入: 8
    // 输出: true
    // 解释: 8 = 2 × 2 × 2
    // 示例 3:

    // 输入: 14
    // 输出: false
    // 解释: 14 不是丑数，因为它包含了另外一个质因数 7。
    // 说明：

    // 1 是丑数。
    // 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。
    var isUgly = function (num) {
      if (num < 1) {
        return false
      }
      if (num === 1) {
        return true
      }
      while (num > 1) {
        if (num % 2 === 0) {
          num = num / 2
          continue
        }
        if (num % 3 === 0) {
          num = num / 3
          continue
        }
        if (num % 5 === 0) {
          num = num / 5
          continue
        }
        return false
      }
      return num === 1
    };

    // 单词拆分
    // 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

    // 说明：

    // 拆分时可以重复使用字典中的单词。
    // 你可以假设字典中没有重复的单词。
    // 示例 1：

    // 输入: s = "leetcode", wordDict = ["leet", "code"]
    // 输出: true
    // 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
    // 示例 2：

    // 输入: s = "applepenapple", wordDict = ["apple", "pen"]
    // 输出: true
    // 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
    // 注意你可以重复使用字典中的单词。
    // 示例 3：

    // 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
    // 输出: false
    // dp[i]表示0-i之间的字符串是否可以被拆分并满足题设条件存在于wordDict中。
    // 假设拆分点为j，那么状态转移方程为：
    // dp[i] = dp[j] && s.substring(j+1, i+1)存在于wordDict

    var wordBreak = function (s, wordDict) {
      // dp[i]表示0-i之间的字符串是否可以被拆分并满足题设条件存在于wordDict中
      let dp = new Array(s.length).fill(false);
      let set = new Set(wordDict);
      for (let i = 0; i < s.length; i++) {
        // 检查0-i之间的字符串是否直接存在于wordDict中
        if (set.has(s.substring(0, i + 1))) {
          dp[i] = true;
          continue;
        }
        // 这一步是为了检查。假如s.substring(0,i)不直接存在于wordDict中
        // 那么判断拆分之后是否存在于wordDict中
        for (let j = 0; j < i; j++) {
          if (dp[j] && set.has(s.substring(j + 1, i + 1))) {
            dp[i] = true;
            break;
          }
        }
      }
      return dp[s.length - 1]
    };

    // 前 K 个高频元素
    // 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

    // 示例 1:

    // 输入: nums = [1, 1, 1, 2, 2, 3], k = 2
    // 输出: [1, 2]
    // 示例 2:

    // 输入: nums = [1], k = 1
    // 输出: [1]

    // 提示：

    // 你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
    // 你的算法的时间复杂度必须优于 O(n log n), n 是数组的大小。
    // 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
    // 你可以按任意顺序返回答案。
    //map  小根堆  桶排序

    // 一周中的第几天
    // 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

    // 输入为三个整数：day、month 和 year，分别表示日、月、年。

    // 您返回的结果必须是这几个值中的一个 { "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" } 。
    var dayOfTheWeek = function (day, month, year) {
      let obj = {
        0: 'Sunday',
        1: 'Monday',
        2: 'Tuesday',
        3: 'Wednesday',
        4: 'Thursday',
        5: 'Friday',
        6: 'Saturday'
      }
      let date = new Date();
      date.setYear(year);
      date.setMonth(month - 1);
      date.setDate(day);
      return obj[date.getDay()]
    };


    // 和为K的子数组
    // 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

    // 示例 1 :

    // 输入: nums = [1, 1, 1], k = 2
    // 输出: 2, [1, 1] 与[1, 1] 为两种不同的情况。
    // 说明:

    // 数组的长度为[1, 20, 000]。
    // 数组中元素的范围是[-1000, 1000]，且整数 k 的范围是[-1e7, 1e7]。
    //方法一 暴力解法
    // var subarraySum = function (nums, k) {
    //   if (nums.length <= 0) return 0;
    //   let count = 0;
    //   for (let start = 0; start < nums.length; start++) {
    //     let sum = 0;
    //     for (let end = start; end < nums.length; end++) {
    //       sum += nums[end];
    //       if (sum === k) {
    //         count++;
    //       }
    //     }
    //   }
    //   return count;
    // };
    //hash法

    var subarraySum = function (nums, k) {
      if (nums.length <= 0) return 0;
      let map = new Map([
        [0, 1]
      ]);
      let sum = 0,
        count = 0;
      for (let i = 0; i < nums.length; i++) {
        sum += nums[i];
        // 注意顺序，要先判断存不存在sum - k
        // 然后再设置map
        if (map.has(sum - k)) {
          count += map.get(sum - k);
        }
        if (!map.has(sum)) {
          map.set(sum, 1);
        } else {
          map.set(sum, map.get(sum) + 1);
        }
      }
      return count;
    };

    // 最接近的三数之和
    // 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
    // 示例：
    // 输入：nums = [-1, 2, 1, -4], target = 1
    // 输出：2
    // 解释：与 target 最接近的和是 2(-1 + 2 + 1 = 2) 。
    // 提示：
    // 3 <= nums.length <= 10 ^ 3
    //   - 10 ^ 3 <= nums[i] <= 10 ^ 3
    //   - 10 ^ 4 <= target <= 10 ^ 4

    var threeSumClosest = function (nums, target) {
      nums.sort((a, b) => a - b);
      let res = nums[0] + nums[1] + nums[2];
      let n = nums.length;
      for (let i = 0; i < n; i++) {
        let left = i + 1;
        let right = n - 1;
        while (left < right) {
          let sum = nums[i] + nums[left] + nums[right];
          if (Math.abs(res - target) > Math.abs(sum - target)) {
            res = sum;
          } else if (sum > target) {
            right--;
          } else if (sum < target) {
            left++;
          } else if (sum === target) {
            return res;
          }
        }
      }
      return res;
    };


    // 复制带随机指针的链表
    // 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
    // 要求返回这个链表的 深拷贝。 
    // 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
    // val：一个表示 Node.val 的整数。
    // random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。
    // 第一次循环拷贝普通属性并记录random指针
    // 第二次循环按照对应关系给random赋值
    const copyRandomList = head => {
      if (!head) return null
      let curr = head,
        node = new Node(),
        tmp = node,
        map = new Map()
      while (curr) {
        tmp.val = curr.val
        tmp.next = curr.next ? new Node() : null
        map.set(curr, tmp)
        tmp = tmp.next
        curr = curr.next
      }
      tmp = node
      while (head) {
        tmp.random = head.random ? map.get(head.random) : null
        head = head.next
        tmp = tmp.next
      }
      return node
    }

    //手写去重函数
    // [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{},{a: 1}, '{a: 1}', {a: 1}];
    function arrayNonRepeatfy(arr) { //null undifined NaN可以去重  对象无法去重
      let map = new Map()
      let res = []
      for (let i = 0; i < arr.length; i++) {
        if (map.has(arr[i])) {
          console.log(arr[i])
        } else {
          map.set(arr[i], i)
        }
      }
      for (const [key, value] of map) {
        res.push(key)
      }
      return res
    }

    //手写斐波那契数列及其优化
    function Fibonacci(n) {
      if (n <= 1) {
        return 1
      };
      return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
    // 递归（优化版）
    // 在ES6规范中，有一个尾调用优化，可以实现高效的尾递归方案。
    // ES6的尾调用优化只在严格模式下开启，正常模式是无效的。
    'use strict'

    function fib(n, current = 0, next = 1) {
      if (n == 0) return 0;
      if (n == 1) return next; // return next
      console.log(`fibonacci(${n}, ${next}, ${current + next})`);
      return fib(n - 1, next, current + next);
    }
    // var cache = [];
    // function fib(n) {
    //   if (cache[n] !== undefined) {
    //     return cache[n];
    //   }
    //   if (n <= 2) {
    //     cache[n] = 1;
    //     return 1;
    //   }
    //   cache.push(fib(n - 1) + fib(n - 2));
    //   return cache[n];
    // }
    // console.log(fib(5));//5

    //大数据优化
    //如果一个函数的运行时间过长，那么可以把它拆分为一系列能在较短时间内完成的子函数。
    //同上，可把参数相同的一系列函数调用分割到不同的定时器中执行，通用方法如下：
    function multistep(steps, args, callback) {
      var tasks = steps.concat();
      setTimeout(function () {
        var task = tasks.shift();
        task.apply(null, args || []);

        if (tasks.length > 0) {
          setTimeout(arguments.callee, 25);
        } else {
          callback();
        }
      }, 25);
    }

    function saveDocument(id) {
      var tasks = [open, write, close];
      multistep(tasks, [id], function () {
        console.log('finished!');
      })
    }


    //find和findIndex的实现原理
    Array.prototype.myFind = function (conditionFunc) {
      for (var i = 0; i < this.length; i++) {
        if (conditionFunc(this[i], i)) {
          return this[i]
        }
      }
    }
    Array.prototype.myFindIndex = function (conditionFunc) {
      for (var i = 0; i < this.length; i++) {
        if (conditionFunc(this[i], i)) {
          return i
        }
      }
    }

    //     如何避免给每个 async 写 try/catch
    // 写一个辅助函数：
    async function errorCaptured(asyncFunc) {
      try {
        let res = await asyncFunc()
        return [null, res]
      } catch (e) {
        return [e, null]
      }
    }
    //复制代码使用方式:
    async function func() {
      let [err, res] = await errorCaptured(asyncFunc)
      if (err) {
        //... 错误捕获
      }
      //...
    }

    //如何计算浏览器的localStorage容量
    (function () {
      function getStr(count) {
        return new Array(count + 1).join('a');
      }

      function formatSize(byte) {
        if (byte > 1024 * 1024) {
          return `${(byte / 1024 / 1024)}MB`;
        } else {
          return `${(byte / 1024).toFixed(2)}KB`;
        }
      }

      // 清空
      window.localStorage.clear();

      const KEY = 'a';
      // 开始每次增加 1MB，512 个字符 1KB
      let appendedSize = 512 * 1024;
      let appendedText = '';
      let text = '';

      while (true) {
        try {
          appendedText = getStr(appendedSize);
          text += appendedText;

          window.localStorage.removeItem(KEY);
          window.localStorage.setItem(KEY, text);
        } catch (e) {
          // 如果插入报错，尝试减少增加量，直至少于1个字符
          text = text.slice(0, -appendedText.length);

          appendedSize /= 2;
        } finally {
          // 如果增加量少于1个字符，则退出循环
          if (appendedSize < 1) {
            break;
          }
        }
      }

      // 要算上 KEY 的长度
      console.log('total capacity: ', `${formatSize((text.length + KEY.length) * 2)}`);
    })();


    /* 根据窗口宽度自动计算html基准字体大小，用于移动端弹性布局 */
    (function () {
      var docEl = document.documentElement,
        docBody = document.body,
        baseFontSize = 100, //为了方便，这样rem=px/100
        pageMaxWidth = 750,
        rootHtml = document.getElementsByTagName('html')[0],
        resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
        recalc = function () {
          var clientWidth = docEl.clientWidth || docBody.clientWidth;

          //最大宽度显示为750的宽度
          if (clientWidth > pageMaxWidth) {
            clientWidth = pageMaxWidth
          }

          if (!clientWidth) return;
          rootHtml.style.fontSize = baseFontSize * (clientWidth / pageMaxWidth) + 'px';
        };
      if (!window.addEventListener) return;

      window.addEventListener(resizeEvt, recalc, false);

      recalc();
    })();

    //洋葱模型
    //所以对koa的洋葱模型进行一探究竟，不管是koa1还是koa2的中间件都是基于koa-compose进行编写的，这种V型结构的实现就来源于koa-compose。
    function compose(middleware) {
      //  参数middleware 是一个中间件数组，存放我们用app.use()一个个串联起来的中间件
      //  判断中间件列表是否为数组，如果不为数组，则抛出类型错误
      if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')
      // 判断中间件是否为函数，如果不为函数，则抛出类型错误
      for (const fn of middleware) {
        if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
      }

      return function (context, next) {
        // 这里next指的是洋葱模型的中心函数
        // context是一个配置对象，保存着一些配置，当然也可以利用context将一些参数往下一个中间传递

        // last called middleware #
        let index = -1 // index是记录执行的中间件的索引
        return dispatch(0) // 执行第一个中间件  然后通过第一个中间件递归调用下一个中间件

        function dispatch(i) {
          // 这里是保证同个中间件中一个next（）不被调用多次调用 
          // 当next()函数被调用两次的时候，i会小于index,然后抛出错误
          if (i <= index) return Promise.reject(new Error('next() called multiple times'))
          index = i
          let fn = middleware[i] // 取出要执行的中间件
          if (i === middleware.length) fn = next // 如果i 等于 中间件的长度，即到了洋葱模型的中心（最后一个中间件）
          if (!fn) return Promise.resolve() // 如果中间件为空，即直接resolve
          try {
            //  递归执行下一个中间件 （下面会重点分析这个）
            return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
          } catch (err) {
            return Promise.reject(err)
          }
        }
      }
    }

    // 题目：给出一个N个学生身高的有序数组，
    // 计算最少出列多少位同学，使得剩下的同学排成合唱队形。
    // 合唱队队形指的是身高从低到高再到低。例：[186, 186, 150, 200, 160, 130, 197, 200]，
    // 最少出列四个同学186，186，200，130使得剩下的同学呈合唱队排列[]。
    function f(arr) {
      let arrLen = arr.length;
      let dp1 = [],
        dp2 = [],
        dp3 = [];
      for (let i = 0; i < arrLen; i++) {
        dp1[i] = 1 // 至少有自身1个作为递增序列
        for (let j = 0; j < i; j++) {
          if (arr[j] < arr[i] && dp1[j] >= dp1[i]) {
            dp1[i] = dp1[j] + 1;
          }
        }
      }
      arr.reverse(); // 将数组倒过来，以递增计算递减序列
      for (let i = 0; i < arrLen; i++) {
        dp2[i] = 1 // 至少有自身1个作为递增序列
        for (let j = 0; j < i; j++) {
          if (arr[j] < arr[i] && dp2[j] >= dp2[i]) {
            dp2[i] = dp2[j] + 1;
          }
        }
      }
      dp2.reverse(); // 反过来作为递减序列
      for (let i = 0; i < arrLen; i++) {
        dp3[i] = dp1[i] + dp2[i] - 1;
      }

      return (arrLen - Math.max(...dp3)); // 计算最少出列的数量
    }

    //生成 UUID
    function uuid() {
      var blob = new Blob()
      var temp_url = URL.createObjectURL(blob);
      var uuid = temp_url.toString(); // blob:https://xxx.com/b250d159-e1b6-4a87-9002-885d90033be3
      URL.revokeObjectURL(temp_url);
      console.log(blob, temp_url)
      return uuid.substr(uuid.lastIndexOf("/") + 1);
    }

    // 设计循环队列
    // 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。
    // 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。
    // 你的实现应该支持如下操作：
    // MyCircularQueue(k): 构造器，设置队列长度为 k 。
    // Front: 从队首获取元素。如果队列为空，返回 - 1 。
    // Rear: 获取队尾元素。如果队列为空，返回 - 1 。
    // enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
    // deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
    // isEmpty(): 检查循环队列是否为空。
    // isFull(): 检查循环队列是否已满。
    // 示例：
    // MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
    // circularQueue.enQueue(1);  // 返回 true
    // circularQueue.enQueue(2);  // 返回 true
    // circularQueue.enQueue(3);  // 返回 true
    // circularQueue.enQueue(4);  // 返回 false，队列已满
    // circularQueue.Rear();  // 返回 3
    // circularQueue.isFull();  // 返回 true
    // circularQueue.deQueue();  // 返回 true
    // circularQueue.enQueue(4);  // 返回 true
    // circularQueue.Rear();  // 返回 4
    // 提示：
    // 所有的值都在 0 至 1000 的范围内；
    // 操作数将在 1 至 1000 的范围内；
    // 请不要使用内置的队列库。
    /**循环队列 */
    class MyCircularQueue {
      /**初始化队列容量 */
      constructor(capacity) {
        /**队列容量 */
        this.cap = capacity;
        /**队列头部 */
        this.head = -1;
        /**队列尾部 */
        this.tail = -1;
        /**数据源 */
        this.arr = [];
      }
      /**向循环队列插入一个元素 */
      enQueue(value) {
        if (this.isFull()) {
          return false;
        }
        if (this.isEmpty()) {
          this.head = 0;
        }
        this.tail = (this.tail + 1) % this.cap;
        this.arr[this.tail] = value;
        return true;
      }
      /**从循环队列中删除一个元素 */
      deQueue() {
        if (this.isEmpty()) {
          return false;
        }
        if (this.head == this.tail) {
          this.head = this.tail = -1;
        } else {
          this.head = (this.head + 1) % this.cap;
        }
        return true;
      }
      /**从队首获取元素 */
      Front() {
        if (this.isEmpty()) {
          return -1;
        }
        return this.arr[this.head];
      }
      /**从队尾获取元素 */
      Rear() {
        if (this.isEmpty()) {
          return -1;
        }
        return this.arr[this.tail];
      }
      /**队列是否为空 */
      isEmpty() {
        return this.head == -1;
      }
      /**队列是否已满 */
      isFull() {
        return this.head == (this.tail + 1) % this.cap;
      }
    }

    //JS中的pipe原理
    function pipe(x, ...fns) {
      let accu = x;
      for (let f in fns) {
        accu = f(accu)
      }
      return accu;
    }

    //UMD（兼容全局变量、AMD、CMD和CommonJS）
    ;
    (function (global, factory) {
      'use strict';

      if (typeof module === 'object' && typeof module.exports === 'object') {
        module.exports = global.document ? factory(global, true) : function (w) {
          if (!w.document) {
            throw new Error('jQuery requires a window with a document');
          }
          return factory(w);
        };
      } else if (define && define.cmd) {
        define(function () {
          return factory(global);
        });
      } else {
        factory(global);
      }
    })(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
      // 核心逻辑代码

      // 使代码支持 amd 模块加载
      if (typeof define === 'function' && define.amd) {
        define('jquery', [], function () {
          return jQuery;
        });
      }

      return {
        add: function (a, b) {
          return a + b;
        }
      }
    });

    //数组中数字出现的次数
    //一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
    // 示例 1：
    // 输入：nums = [4,1,4,6]
    // 输出：[1,6] 或 [6,1]
    // 示例 2：
    // 输入：nums = [1,2,10,4,1,4,3,3]
    // 输出：[2,10] 或 [10,2]
    // 限制：

    // 2 <= nums.length <= 10000
    var singleNumbers = function (nums) {
      // res为抑或的结果
      let res = 0
      for (let n of nums) {
        res ^= n
      }
      // console.log(res)
      // div为a、b抑或结果的末尾出现的第一个1，通过将nums数组与div进行抑或，可将nums分成两组，每组只有一个a或b，其他的都是成对的。
      let div = 1
      while ((div & res) === 0) {
        div <<= 1
      }
      let a = 0,
        b = 0
      for (let n of nums) {
        if (div & n) {
          a ^= n
        } else {
          b ^= n
        }
      }
      return [a, b]
    }

    // 三步问题

    // 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

    // 示例1:

    //  输入：n = 3 
    //  输出：4
    //  说明: 有四种走法
    // 示例2:

    //  输入：n = 5
    //  输出：13
    // 提示:

    // n范围在[1, 1000000]之间
    var waysToStep = function (n) {
      let m = 1e9 + 7
      let dp = [0, 1, 2, 4]
      for (let i = 4; i < n + 1; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % m
      }
      return dp[n]
    };

    //每日温度
    // 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。
    // 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
    // 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
    // 暴力法
    // 题意：每个元素找到它右边第一个比它大的元素的位置，求它们的距离
    // ii 指向当前元素，jj 扫描右边的区间，直到找到比当前元素大的元素，记录 j-ij−i
    // 然后 ii 考察下一位，jj 重复上述过程。有两重循环，时间复杂度 O(n^2)O(n 
    // 2
    //  )
    const dailyTemperatures = (T) => {
      const res = new Array(T.length).fill(0)
      for (let i = 0; i < T.length; i++) {
        for (let j = i + 1; j < T.length; j++) {
          if (T[j] > T[i]) {
            res[i] = j - i
            break
          }
        }
      }
      return res
    }

    // 单调栈 解法
    // 当前元素关注的是它右边的元素
    // 我选择从右开始遍历，需要考察的右边元素由少到多
    // 一次遍历：O(n)；每个元素都出栈入栈各一次：线性时间的复杂度。综合：O(n)
    // 空间复杂度：O(n)

    var dailyTemperatures = function (T) {
      let {
        length
      } = T
      let res = new Array(length).fill(0)
      let stack = [] //利用单调栈储存索引
      for (let i = 0; i < length; i++) {
        while (stack.length && T[i] > T[stack[stack.length - 1]]) {
          let index = stack.pop()
          res[index] = i - index
        }
        stack.push(i)
      }
      return res
    };

    //手写 Object.create
    const myCreate = function (obj) {
      function F() { };
      F.prototype = obj;
      return new F();
    }

    Object.ObjectCreate = (proto, propertiesObject) => {
      // 对输入进行检测
      if (typeof proto !== 'object' && typeof proto !== 'function' && proto !== null) {
        throw new Error(`Object prototype may only be an Object or null:${proto}`);
      }
      // 新建一个对象
      const result = {};
      // 将该对象的原型设置为proto
      Object.setPrototypeOf(result, proto);
      // 将属性赋值给该对象
      Object.defineProperties(result, propertiesObject);
      // 返回该对象
      return result;
    }


    // 统计「优美子数组」
    // 给你一个整数数组 nums 和一个整数 k。
    // 如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。
    // 请返回这个数组中「优美子数组」的数目。
    // 示例 1：
    // 输入：nums = [1,1,2,1,1], k = 3
    // 输出：2
    // 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
    // 示例 2：
    // 输入：nums = [2,4,6], k = 1
    // 输出：0
    // 解释：数列中不包含任何奇数，所以不存在优美子数组。
    // 示例 3：
    // 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2
    // 输出：16
    // 双指针法
    var isOdd = function (num) {
      return num % 2 !== 0
    }
    var numberOfSubarrays = function (nums, k) {
      let L = R = 0,
        count = 0,
        result = 0
      while (R < nums.length) {
        let w1 = nums[R]
        R++
        if (isOdd(w1)) count++
        while (count > k) {
          let w2 = nums[L]
          L++
          if (isOdd(w2)) count--
        }
        if (count === k) {
          let tmp = count,
            j = L
          while (j < R && tmp === k) {
            result++
            if (isOdd(nums[j])) tmp--
            j++
          }
        }
      }
      return result
    };
    //动态规划
    //nums中有n个奇数
    // 编号为 1 2 3 ... n
    // dp[i]代表第i个奇数在nums中的索引
    // 则dp[0] 代表-1 因为-1刚好挨着0 相当于在nums前面插入一个奇数
    // 任意连续k个奇数的数列有 例如包含编号2 知道编号为 k+1的数列的个数为
    // (dp[2]-dp[1]) * (dp[k+2]-dp[k-1])
    // 在nums后面在push一个1 则可以求出以nums中最后一个数列

    var numberOfSubarrays = function (nums, k) {
      nums.push(1);
      let dp = [-1];
      let sum = 0;
      for (let i = 0, len = nums.length, start = 0; i < len; ++i) {
        if (nums[i] % 2) {
          dp.push(i);
          if (dp[k + 1]) {
            sum += (dp[start + 1] - dp[start]) * (dp[k + 1] - dp[k])
            ++k;
            ++start;
          }
        }
      }
      return sum;
    };

    // 一道价值25k的蚂蚁金服异步串行面试题
    // const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    // const subFlow = createFlow([() => delay(1000).then(() => log("c"))]);
    // createFlow([
    //   () => log("a"),
    //   () => log("b"),
    //   subFlow,
    //   [() => delay(1000).then(() => log("d")), () => log("e")],
    // ]).run(() => {
    //   console.log("done");
    // });
    // 需要按照 a,b,延迟1秒,c,延迟1秒,d,e, done 的顺序打印

    //大佬思路1
    function createFlow(effects = []) {
      return {
        async run(callback) {
          const flatEffects = effects.flat(Infinity)
          for (let effect of flatEffects) {
            if (typeof effect.run === 'function') {
              await effect.run()
            } else {
              await effect()
            }
          }
          if (typeof callback === 'function') {
            await callback()
          }
        }
      }
    }

    //大佬思路二
    class Flow {
      constructor(arr) {
        this.q = arr
      }
      async run(cb) {
        for (let i = 0; i < this.q.length; i++) {
          const item = this.q[i];
          if (item instanceof Flow) {
            await item.run()
          } else if (Array.isArray(item)) {
            await createFlow(item)
          } else {
            await item()
          }

        }
        //await cb ? .()   编辑器报错所以注释
      }
    }

    function createFlow(arr) {
      return new Flow(arr)
    }

    //深度遍历
    const tree = {
      name: 'root',
      children: [{
        name: 'c1',
        children: [{
          name: 'c11',
          children: []
        },
        {
          name: 'c12',
          children: []
        }
        ]
      },
      {
        name: 'c2',
        children: [{
          name: 'c21',
          children: []
        },
        {
          name: 'c22',
          children: []
        }
        ]
      }
      ]
    }

    // 深度优先的方式遍历 打印 name
    // ['root', 'c1','c11', 'c12', 'c2', 'c21', 'c22']
    //方法一  递归
    function resolve(tree) {
      console.log(tree.name)
      if (tree.children.length > 0) {
        for (let i = 0; i < tree.children.length; i++) {
          const element = tree.children[i];
          resolve(element)
        }
      }
    }
    //方法二  栈
    function resolve(root) {
      let stack = [],
        result = [];
      if (!root) return [];
      stack.push(root)
      while (stack.length) {
        let node = stack.pop()
        if (node == null) continue
        result.push(node.name)
        for (let i = node.children.length - 1; i >= 0; i--) {
          // 这里就是面试的重点,应该从后面的节点压入栈中
          stack.push(node.children[i])
        }
      }
      return result
    }

    // ES6语法，Promise了解吗
    const promise = new Promise((resolve, reject) => {
      console.log(1);
      resolve();
      reject()
      console.log(2);
    })

    promise.then(() => {
      console.log(3);
    }, () => {
      console.log("失败的状态")
    })
    console.log(4);

    //整数反转
    // 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
    // 示例 1:

    // 输入: 123
    // 输出: 321
    // 示例 2:

    // 输入: -123
    // 输出: -321
    // 示例 3:

    // 输入: 120
    // 输出: 21
    // 注意:

    // 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

    var reverse = function (x) {
      let y = 0;
      let MAX = Math.pow(2, 31) - 1;
      let MIN = -Math.pow(2, 31);
      while (x != 0) {
        y = y * 10 + x % 10;
        if (y > MAX || y < MIN) {
          return 0;
        }
        x = Math.trunc(x / 10); //取整
      }
      return y;
    };

    //242. 有效的字母异位词
    // 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

    // 示例 1:

    // 输入: s = "anagram", t = "nagaram"
    // 输出: true
    // 示例 2:

    // 输入: s = "rat", t = "car"
    // 输出: false
    // 说明:
    // 你可以假设字符串只包含小写字母。

    // 进阶:
    // 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？
    //方法一 利用数组sort()方法
    const isAnagram = (s, t) => {
      const sArr = s.split('');
      const tArr = t.split('');
      const sortFn = (a, b) => {
        return a.charCodeAt() - b.charCodeAt();
      };
      sArr.sort(sortFn);
      tArr.sort(sortFn);
      return sArr.join('') === tArr.join('');
    };

    // 时间复杂度： O(nlogn) JavaScript 的 sort 方法的实现原理，当数组长度小于等于 10 的时候，采用插入排序，大
    // 于 10 的时候，采用快排，快排的平均时间复杂度是 O(nlogn) 。
    // 空间复杂度： O(n) 算法中申请了 2 个数组变量用于存放字符串分割后的字符串数组，所以数
    // 组空间长度跟字符串长度线性相关，所以为 O(n) 。

    //方法二 计数累加方法
    const isAnagram = (s, t) => {
      if (s.length !== t.length) {
        return false;
      }
      const hash = {};
      for (const k of s) {
        hash[k] = hash[k] || 0;
        hash[k] += 1;
      }
      for (const k of t) {
        if (!hash[k]) {
          return false;
        }
        hash[k] -= 1;
      }
      return true;
    };

    // 剑指 Offer 50. 第一个只出现一次的字符
    // 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

    // 示例:

    // s = "abaccdeff"
    // 返回 "b"

    // s = ""
    // 返回 " "


    // 限制：

    // 0 <= s 的长度 <= 50000
    //哈希法
    var firstUniqChar = function (s) {
      if (!s) return " "
      let map = new Map()
      for (let c of s) {
        if (map.has(c)) {
          map.set(c, map.get(c) + 1)
        } else {
          map.set(c, 1)
        }
      }
      for (let c of map.keys()) {
        if (map.get(c) === 1) {
          return c
        }
      }

      return " "
    };
    // 时间复杂度：O(n)
    // 空间复杂度：O(n)

    //空间复杂度0(1)
    var firstUniqChar = function (s) {
      let arr = new Array(26).fill(0);

      for (let c of s) {
        arr[c.charCodeAt() - 97] += 1;
      }

      for (let c of s) {
        if (arr[c.charCodeAt() - 97] == 1) {
          return c;
        }
      }
      return ' ';
    };

    // 429. N叉树的层序遍历
    // 给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

    // 例如，给定一个 3叉树 :

    // 返回其层序遍历:

    // [
    //      [1],
    //      [3,2,4],
    //      [5,6]
    // ]


    // 说明:

    // 树的深度不会超过 1000。
    // 树的节点总数不会超过 5000。
    /**
     * // Definition for a Node.
     * function Node(val,children) {
     *    this.val = val;
     *    this.children = children;
     * };
     */
    /**
     * @param {Node} root
     * @return {number[][]}
     */
    var levelOrder = function (root) {
      if (!root) return [];
      let queue = [root];
      let ans = [];
      while (queue.length) {
        let level = [];
        let len = queue.length;
        for (let i = 0; i < len; i++) {
          let current = queue.shift();
          level.push(current.val);
          if (current.children && current.children.length > 0) {
            queue.push(...current.children);
          }
        }
        ans.push(level);
      }
      return ans;
    };


    //原生JS实现复制小尾巴
    //  复制小尾巴，保留版权信息
    // 监听复制事件
    body.addEventListener("copy", (e) => {
      //  阻止默认行为
      e.preventDefault();
      // 获取当前网址和复制的内容
      let url = window.location.href;
      let copyText = window.getSelection().toString();
      // 整合，注意弄好格式
      let returnText =
        `${copyText}
原文出自余烬的小舟 [ ${url} ] 转载请保留原文链接
        `
      // 如果超出规定长度，则添加小尾巴
      if (copyText.length >= 50) {
        // 将文本添加到剪切板中
        e.clipboardData.setData('text/plain', returnText);
      } else {
        e.clipboardData.setData('text/plain', copyText);
      }
    });

    //惰性函数
    //1.使用前
    function getCss(element, attr) {
      if ('getComputedStyle' in window) {
        return window.getComputedStyle(element)[attr];
      }
      return element.currentStyle[attr];
    }

    getCss(document.body, 'margin');
    getCss(document.body, 'padding');
    getCss(document.body, 'width');

    //2.使用后
    function getCss(element, attr) {
      if ('getComputedStyle' in window) {
        getCss = function (element, attr) {
          return window.getComputedStyle(element)[attr];
        };
      } else {
        getCss = function (element, attr) {
          return element.currentStyle[attr];
        };
      }
      //3.用自调用函数实现
      const addHandler = (function () {
        if (document.addEventListener) {
          return function (element, type, handler) {
            element.addEventListener(type, handler, false);
          };
        } else if (document.attachEvent) {
          return function (element, type, handler) {
            element.attachEvent("on" + type, handler);
          };
        } else {
          return function (element, type, handler) {
            element["on" + type] = handler;
          };
        }
      })();

      // 为了第一次也能拿到值
      return getCss(element, attr);
    }
    getCss(document.body, 'margin');
    getCss(document.body, 'padding');
    getCss(document.body, 'width');

    //柯里化转换函数
    function currying(fn, ...args) {
      // fn.length 回调函数的参数的总和
      // args.length currying函数 后面的参数总和 
      // 如：add (a,b,c,d)  currying(add,1,2,3,4)
      if (fn.length === args.length) {
        return fn(...args)
      } else {
        // 继续分步传递参数 newArgs 新一次传递的参数
        return function anonymous(...newArgs) {
          // 将先传递的参数和后传递的参数 结合在一起
          let allArgs = [...args, ...newArgs]
          return currying(fn, ...allArgs)
        }
      }
    }

    let fn1 = currying(add, 1, 2) // 3
    let fn2 = fn1(3) // 6
    let fn3 = fn2(4) // 10

    //reduce的理解
    // 情况1：reduce没有第二个参数时
    // let Array = [10, 20, 30, 40, 50];
    // Array.reduce(previousValue, currentValue, currentIndex, arr){
    //   return previousValue + currentValue;
    // }

    // 第一次触发函数时，previousValue为第一项(10)，currentValue为第二项(20)
    // 第二次触发函数时，previousValue为回调函数的返回值(30)，currentValue为第三项(30)
    // 第X次触发函数时，previousValue为回调函数的返回值，currentValue为第X+1项
    // currentIndex：对应的就是currentValue的索引值
    // arr：是个常量 数组本身
    // 情况2：reduce有第二个参数时
    // let Array = [10, 20, 30, 40, 50];
    // Array.reduce((previousValue, currentValue, currentIndex, arr){
    //   return previousValue + currentValue;
    // }, 0)

    // 第一次触发函数时，previousValue为第二个参数(0)，currentValue为第一项(10)
    // 第二次触发函数时，previousValue为回调函数的返回值(10)，currentValue为第二项(20)
    // 第X次触发函数时，previousValue为回调函数的返回值，currentValue为第X项
    // currentIndex：对应的就是currentValue的索引值
    // arr：是个常量 数组本身

    // 反转链表 II
    // 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

    // 说明:
    // 1 ≤ m ≤ n ≤ 链表长度。

    // 示例:

    // 输入: 1->2->3->4->5->NULL, m = 2, n = 4
    // 输出: 1->4->3->2->5->NULL
    /**
     * Definition for singly-linked list.
     * function ListNode(val) {
     *     this.val = val;
     *     this.next = null;
     * }
     */
    /**
     * @param {ListNode} head
     * @param {number} m
     * @param {number} n
     * @return {ListNode}
     */
    var reverseBetween = function (head, m, n) {

    };

    //扁平数组转树结构

    // 当我们需要将一个一维数组转换成一个多层结构的时候， 最简单但是最慢的就是多个for循环嵌套， 但是这样做有一些缺点， 那就是效率太低、 而且有多少层就需要嵌套几个for循环， 不好用。

    // 实现了用O(n) 级算法将 一个扁平的数组即一维数组代表的菜单结构转换成一个多层级的菜单结构。

    // 一位数组中每一个元素必须要包含以下属性：

    // 拥有一个唯一的id
    // 拥有一个parentid, 这个id指向它父级的id
    var arr = [{
      'id': 1,
      'parentid': 0
    },
    {
      'id': 4,
      'parentid': 2
    },
    {
      'id': 3,
      'parentid': 1
    },
    {
      'id': 5,
      'parentid': 0
    },
    {
      'id': 6,
      'parentid': 0
    },
    {
      'id': 2,
      'parentid': 1
    },
    {
      'id': 7,
      'parentid': 4
    },
    {
      'id': 8,
      'parentid': 1
    }
    ];

    function unflatten(arr) {
      var tree = [],
        mappedArr = {},
        arrElem,
        mappedElem;

      // First map the nodes of the array to an object -> create a hash table.
      for (var i = 0, len = arr.length; i < len; i++) {
        arrElem = arr[i];
        mappedArr[arrElem.id] = arrElem;
        mappedArr[arrElem.id]['children'] = [];
      }


      for (var id in mappedArr) {
        if (mappedArr.hasOwnProperty(id)) {
          mappedElem = mappedArr[id];
          // If the element is not at the root level, add it to its parent array of children.
          if (mappedElem.parentid) {
            mappedArr[mappedElem.parentid].children.push(mappedElem);
          }
          // If the element is at the root level, add it to first level elements array.
          else {
            tree.push(mappedElem);
          }
        }
      }
      return tree;
    }

    var tree = unflatten(arr);

    //将树结构转化为扁平数组
    function nodes2Array(nodes) {
      if (!nodes) return [];
      var childKey = "child",
        r = [];
      if (nodes instanceof Array) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          r.push(nodes[i]);
          if (nodes[i][childKey])
            r = r.concat(nodes2Array(nodes[i][childKey]));
        }
      } else {
        r.push(nodes);
        if (nodes[childKey])
          r = r.concat(nodes2Array(nodes[childKey]));
      }
      return r;
    }

    //用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值
    function insertArr(arr, i = 0, min = 2, max = 32) {
      const num = Math.max(min, Math.ceil(Math.random() * max))
      if (!arr[arr.length - 1]) {
        if (!arr.includes(num)) {
          arr[i++] = num
        }
        return insertArr(arr, i)
      }
      return arr
    }
    const arr = new Array(5);
    const result = insertArr(arr)

    //写一个方法把下划线命名转成大驼峰命名
    function strToCamel(str) {
      return str.replace(/(^|_)(\w)/g, (m, $1, $2) => $2.toUpperCase());
    }

    //obj.a===1 && obj.a===2 && obj.a===3
    let obj = {
      value: 1
    }
    Object.defineProperty(obj, 'a', {
      get() {
        return this.value++
      }
    })
    console.log(obj.a === 1) // true
    console.log(obj.a === 2) // true
    console.log(obj.a === 3) // true

    let obj = {
      value: 1
    }
    let proxy = new Proxy(obj, {
      get(target, key, receiver) {
        if (key === 'a') {
          return target.value++
        }
      }
    })
    console.log(proxy.a === 1) // true
    console.log(proxy.a === 2) // true
    console.log(proxy.a === 3) // true

    // 530. 二叉搜索树的最小绝对差
    // 给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
    // 示例：

    // 输入：

    //    1
    //     \
    //      3
    //     /
    //    2

    // 输出：
    // 1

    // 解释：
    // 最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
    var getMinimumDifference = function (root) {
      function getArr(root) {
        if (!root) return;
        getArr(root.left);
        arr.push(root.val);
        getArr(root.right);
      }
      let arr = [];
      arr[-1] = -Infinity;
      getArr(root);
      return Math.min(...arr.map((item, index) => item - arr[index - 1]));
    };

    //22. 括号生成
    // 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。
    // 示例：

    // 输入：n = 3
    // 输出：[
    //        "((()))",
    //        "(()())",
    //        "(())()",
    //        "()(())",
    //        "()()()"
    //      ]
    // 解答：回溯算法（深度优先遍历）
    // 算法策略： 回溯算法是一种搜索法，试探法，它会在每一步做出选择，一旦发现这个选择无法得到期望结果，就回溯回去，重新做出选择。深度优先搜索利用的就是回溯算法思想。
    // 对应于本题，我们可以每次试探增加 ( 或 ) ，注意：
    // 加入 ( 的条件是，当前是否还有 ( 可以选择
    // 加入 ) 的时候，受到 ( 的限制，如果已选择的结果里的 ( 小于等于已选择里的 ) 时，此时是不能选择 ) 的，例如如果当前是 () ，继续选择 ) 就是 ()) ，是不合法的
    // 代码实现：
    const generateParenthesis = (n) => {
      const res = []
      const dfs = (path, left, right) => {
        // 肯定不合法，提前结束
        if (left > n || left < right) return
        // 到达结束条件
        if (left + right === 2 * n) {
          res.push(path)
          return
        }
        // 选择
        dfs(path + '(', left + 1, right)
        dfs(path + ')', left, right + 1)
      }
      dfs('', 0, 0)
      return res
    }

    // 45. 跳跃游戏 II
    // 给定一个非负整数数组，你最初位于数组的第一个位置。

    // 数组中的每个元素代表你在该位置可以跳跃的最大长度。

    // 你的目标是使用最少的跳跃次数到达数组的最后一个位置。

    // 示例:

    // 输入: [2,3,1,1,4]
    // 输出: 2
    // 解释: 跳到最后一个位置的最小跳跃数是 2。
    //      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
    // 说明:

    // 假设你总是可以到达数组的最后一个位置。
    var jump = function (nums) {
      let curr = 0; // 当前位置
      let next = 0; // 跳跃后的位置
      let stepNum = 0; // 跳跃次数
      let length = nums.length - 1;
      for (let i = 0; i < length; i++) {
        next = Math.max(next, i + nums[i]); // 跳一次的最远跳跃距离 = 当前位置 + 可跳跃的最大数
        if (curr >= length) break;
        if (curr === i) {
          curr = next;
          stepNum++;
        }
      }
      return stepNum;
    };


    //今日头条:转化为36进制
    //十进制数转成36进制
    function scale36(n) {
      function getNums36() {
        var nums36 = [];
        for (var i = 0; i < 36; i++) {
          if (i >= 0 && i <= 9) {
            nums36.push(i);
          } else {
            nums36.push(String.fromCharCode(i + 87));
          }
        }
        return nums36;
      }
      var arr = [];
      var nums36 = getNums36();
      while (n) {
        var res = n % 36;
        //作为下标，对应的36进制数，转换成
        arr.unshift(nums36[res]);
        //去掉个位
        n = parseInt(n / 36);
      }
      return arr.join("");
    }

    //今日头条:合并乱序区间
    // let arr = [[1,3],[2,6],[8,10],[15,18]]
    // [ [ 1, 6 ], [ 8, 10 ], [ 15, 18 ] ]
    function merge(arg) {
      let arr = arg,
        result = [];
      arg.sort((a, b) => a[0] - b[0]); // 先根据第一位进性排序
      for (let i = 0; i < arr.length; i++) {
        if (result.length) {
          let res = result[result.length - 1];
          if (res[1] > arr[i][0]) {
            if (res[1] < arr[i][1]) {
              result[result.length - 1][1] = arr[i][1]; // 如果前一个的第二位大于下一个的第一位,小于第二位,那么被下一个第二位代替
            }
          } else {
            result.push(arr[i])
          }
        } else {
          result.push(arr[i])
        }
      }
      return result
    }

    //偏函数
    // 在计算机科学中，偏函数应用（Partial Application）是指固定一个函数的某些参数，然后产生另一个更小元的函数。而所谓的元是指函数参数的个数，比如含有一个参数的函数被称为一元函数。
    // 偏函数应用（Partial Application）很容易与函数柯里化混淆，它们之间的区别是：
    // 偏函数应用是固定一个函数的一个或多个参数，并返回一个可以接收剩余参数的函数；
    // 柯里化是将函数转化为多个嵌套的一元函数，也就是每个函数只接收一个参数。
    //Lodash 提供的 partial 函数
    function partial(fn) {
      let args = [].slice.call(arguments, 1);
      return function () {
        const newArgs = args.concat([].slice.call(arguments));
        return fn.apply(this, newArgs);
      };
    }

    //缓存函数
    //let complexCalc = (a, b) => {
    //   // 执行复杂的计算
    // };

    // let memoCalc = memorize(complexCalc);
    // memoCalc(666, 888);
    // memoCalc(666, 888); // 从缓存中获取

    function memorize(fn) {
      const cache = Object.create(null); // 存储缓存数据的对象
      return function (...args) {
        const _args = JSON.stringify(args);
        return cache[_args] || (cache[_args] = fn.apply(fn, args));
      };
    };

    //有100匹马，场地只有4条跑道，得出最快的4只马需要多少轮 Lam：100匹马，4个赛道，找出跑最快的4匹马。

    //已知函数fn1会随机返回1-5的整数，要求基于fn1编写fn2，要随机生成1-7，fn2内不能使用系统的随机api，只能调用fn1获取随机数

    //考官直接问，1到1000到多少个7？
    // 要求，不编程，直接给出答案，并简单给出思路。
    // 首先应该有个合理的归类，我一开始就想到了一个合理的分类法，即1到1000，每个数都看作3位数，而1000明显没有7，不考虑那1看成001，19看成019，以此类推
    // 这样每个数字可以用三个格子表示，就有了一个统一的表示方法
    // 第一步，只考虑后面两个格子。
    // 我最初只想第一种情况，X7，即07，17，一直到97，其中先不考虑77的特殊性（隔离的思想），这样从0~9有10个7，再考虑77，就有11个7。还有一种情况，7X，即70，71，一直到79，情况同上，也有11个7。
    // 这两种情况都算上了77里面的两个7，因此减去2。结果是22-2 = 20。
    // 第二步，考虑第一个格子。
    // 第一个格子，从0~9，即有10种上述情况，其中7比较特殊，我们先不把它当作7（隔离的思想），那么情况简单了，一共有10*20 = 200个7。
    // 第三步，考虑刚才被隔离掉的7。
    // 这一步容易想歪，觉得是不是+20呢？其实应该仔细想下，701, 719, 722这些都多了1个7，那777呢？仔细想下，777里面的后面2个7也是前面已经算过了。
    // 那就很明朗了。就是刚才的隔离，仅仅忽略了从00~99这100个数中前面含一个7的情况。
    // 所以，最后的答案是200+100 = 300。
    // 假定前面的结果用f(3)表示
    // 不难归纳，1到10000，即f(4) = 10*f(3) + 1000即4000

    //水壶问题
    //有两个容量分别为 x 升和 y 升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z 升的水？
    // 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z 升水。
    // 你允许：
    // 装满任意一个水壶
    // 清空任意一个水壶
    // 从一个水壶向另外一个水壶倒水，直到装满或者倒空
    // 示例 1
    // 输入: x = 3, y = 5, z = 4
    // 输出: True
    // 示例 2
    // 输入: x = 2, y = 6, z = 5
    // 输出: False
    // 观察题干中给定的三种操作，不难发现在整个过程中，两个桶都不可能同时有水且不满。

    // 有了这个基本判断之后，我们可以发现「装满一个有水但不满的桶」是没有意义的。因为当前桶有水但不满，意味着另外一个桶要么为空，要么全满，因此如果把当前桶再变为满，则不如直接一开始就把当前桶加满。

    // 与此同理，「清空一个有水但不满的桶」也是没有意义的，因为另一个桶非空即满。

    // 所以我们不难发现，「装满任意一个水壶」只会让总水量增加 x 或 y,「清空任意一个水壶」只会让总水量减少 x 或 y，「从一个水壶向另一个水壶倒水」，总水量不变。

    // 由此每次操作只会给总水量带来 x 或 y 的变化量，因此本题可以改写为：

    // 找到一对整数 a,b，使得 ，且

    // 根据「裴蜀定理」，只要 z 是 的倍数，就一定存在一对整数 a,b 满足题意，由此本题得以顺利解决。
    var canMeasureWater = function (x, y, z) {
      if (x + y < z) return false;

      if (z === 0) return true;

      if (x === 0) return y === z;

      if (y === 0) return x === z;

      function GCD(a, b) {
        let min = Math.min(a, b);
        while (min) {
          if (a % min === 0 && b % min === 0) return min;
          min--;
        }
        return 1;
      }

      return z % GCD(x, y) === 0;
    };

    // 1200. 最小绝对差
    // 给你个整数数组 arr，其中每个元素都 不相同。
    // 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。
    // 示例 1：
    // 输入：arr = [4,2,1,3]
    // 输出：[[1,2],[2,3],[3,4]]
    // 示例 2：
    // 输入：arr = [1,3,6,10,15]
    // 输出：[[1,3]]
    // 示例 3：
    // 输入：arr = [3,8,-10,23,19,-4,-14,27]
    // 输出：[[-14,-10],[19,23],[23,27]]
    // 提示：
    // 2 <= arr.length <= 10^5
    // -10^6 <= arr[i] <= 10^6
    var minimumAbsDifference = function (arr) {
      arr.sort((a, b) => a - b);
      let left = 0,
        right = 1,
        res = [],
        c = Number.MAX_SAFE_INTEGER;

      while (right < arr.length) {
        let k = arr[right] - arr[left];

        if (k < c) {
          res = [];
          res.push([arr[left], arr[right]]);
          c = k;
        } else if (k == c) {
          res.push([arr[left], arr[right]]);
        }
        left++;
        right++;
      }
      return res;
    };

    //剑指 Offer 56 - II. 数组中数字出现的次数 II
    // 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
    // 示例 1：
    // 输入：nums = [3,4,3,3]
    // 输出：4
    // 示例 2：
    // 输入：nums = [9,1,7,9,7,9,7]
    // 输出：1
    // 限制：
    // 1 <= nums.length <= 10000
    // 1 <= nums[i] < 2^31
    var singleNumber = function (nums) {
      const set = new Set(nums);
      let sum1 = 0;
      for (let num of set.values()) {
        sum1 += num;
      }
      let sum2 = 0;
      for (let num of nums) {
        sum2 += num;
      }

      return Math.floor((3 * sum1 - sum2) / 2);
    };

    // 最大公约数
    function maxDivisor(num1, num2) {
      let max = num1 > num2 ? num1 : num2,
        min = num1 > num2 ? num2 : num1;
      for (var i = min; i >= 1; i--) {
        if (max % i == 0 && min % i == 0) {
          return i;
        }
      }
    }

    console.log(maxDivisor(60, 30)); // 30

    // 最小公倍数
    function minDivisor(num1, num2) {
      let max = num1 > num2 ? num1 : num2,
        min = num1 > num2 ? num2 : num1,
        result = 0;
      // 这个循环，当两数同为质数时，终止的最大条件值为 i = min
      for (var i = 1; i <= min; i++) {
        result = i * max;
        if (result % max == 0 && result % min == 0) {
          return result;
        }
      }
    }
    console.log(minDivisor(6, 8)); // 24

    // 744. 寻找比目标字母大的最小字母
    // 给你一个排序后的字符列表 letters， 列表中只包含小写英文字母。 另给出一个目标字母 target， 请你寻找在这一有序列表里比目标字母大的最小字母。

    // 在比较时， 字母是依序循环出现的。 举个例子：

    // 如果目标字母 target = 'z'
    // 并且字符列表为 letters = ['a', 'b']， 则答案返回 'a'


    // 示例：

    // 输入:
    //   letters = ["c", "f", "j"]
    // target = "a"
    // 输出: "c"

    // 输入:
    //   letters = ["c", "f", "j"]
    // target = "c"
    // 输出: "f"

    // 输入:
    //   letters = ["c", "f", "j"]
    // target = "d"
    // 输出: "f"

    // 输入:
    //   letters = ["c", "f", "j"]
    // target = "g"
    // 输出: "j"

    // 输入:
    //   letters = ["c", "f", "j"]
    // target = "j"
    // 输出: "c"

    // 输入:
    //   letters = ["c", "f", "j"]
    // target = "k"
    // 输出: "c"


    // 提示：

    // letters长度范围在[2, 10000] 区间内。
    // letters 仅由小写字母组成， 最少包含两个不同的字母。
    // 目标字母target 是一个小写字母。
    /**
     * @param {character[]} letters
     * @param {character} target
     * @return {character}
     */
    var nextGreatestLetter = function (letters, target) {
      let array = Array.from(new Set(letters))
      let left = 0;
      let right = array.length - 1;
      while (left <= right) {
        let mid = Math.floor((left + right) / 2);
        if (array[mid] > target) {
          if (mid - 1 >= 0) {
            if (array[mid - 1] <= target) {
              return array[mid]
            } else {
              right = mid - 1
            }
          } else {
            return array[0]
          }
        } else if (array[mid] === target) {
          if (mid + 1 >= array.length) {
            return array[0]
          }
          return array[mid + 1]
        } else {
          left = mid + 1
        }
      }
      return letters[0]
    };

    // 作用：同valueOf()和toString()一样，但是优先级要高于这两者；
    // 该函数被调用时，会被传递一个字符串参数hint，表示当前运算的模式，一共有三种模式：
    // string：字符串类型
    // number：数字类型
    // default：默认
    class A {
      constructor(count) {
        this.count = count
      }
      valueOf() {
        return 2
      }
      toString() {
        return '哈哈哈'
      }
      // 我在这里
      [Symbol.toPrimitive](hint) {
        if (hint == "number") {
          return 10;
        }
        if (hint == "string") {
          return "Hello Libai";
        }
        return true;
      }
    }

    const a = new A(10)

    console.log(`${a}`) // 'Hello Libai' => (hint == "string")
    console.log(String(a)) // 'Hello Libai' => (hint == "string")
    console.log(+a) // 10            => (hint == "number")
    console.log(a * 20) // 200           => (hint == "number")
    console.log(a / 20) // 0.5           => (hint == "number")
    console.log(Number(a)) // 10            => (hint == "number")
    console.log(a + '22') // 'true22'      => (hint == "default")
    console.log(a == 10) // false        => (hint == "default")

    // 1. a===1&&a===2&&a===3 为 true
    // 双等号(==)：会触发隐式类型转换，所以可以使用 valueOf 或者 toString 来实现。
    // 每次判断都会触发valueOf方法，同时让value+1，才能使得下次判断成立。
    class A {
      constructor(value) {
        this.value = value;
      }
      valueOf() {
        return this.value++;
      }
    }
    const a = new A(1);
    if (a == 1 && a == 2 && a == 3) {
      console.log("Hi Libai!");
    }
    // 全等(===)：严格等于不会进行隐式转换，这里使用 Object.defineProperty 数据劫持的方法来实现
    let value = 1;
    Object.defineProperty(window, 'a', {
      get() {
        return value++
      }
    })
    if (a === 1 && a === 2 && a === 3) {
      console.log("Hi Libai!")
    }

    // 字节跳动:实现一个无限累加函数
    // 问题：用 JS 实现一个无限累加的函数 add，示例如下：

    // add(1); // 1
    // add(1)(2);  // 3
    // add(1)(2)(3) ； // 6
    // add(1)(2)(3)(4) ； // 10 
    function add(a) {
      function sum(b) { // 使用闭包
        a = b ? a + b : a; // 累加
        return sum;
      }
      sum.toString = function () { // 只在最后一次调用
        return a;
      }
      return sum; // 返回一个函数
    }

    add(1) // 1
    add(1)(2) // 3
    add(1)(2)(3) // 6
    add(1)(2)(3)(4) // 10 
    // 复制代码

    // add函数内部定义sum函数并返回，实现连续调用
    // sum函数形成了一个闭包，每次调用进行累加值，再返回当前函数sum
    // add()每次都会返回一个函数sum，直到最后一个没被调用，默认会触发toString方法，所以我们这里重写toString方法，并返回累计的最终值a

    // 柯里化实现多参累加
    // 这里是上面累加的升级版，实现多参数传递累加。

    // add(1)(3,4)(3,5)	// 16
    // add(2)(2)(3,5)		// 12
    // 我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，
    // 函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回变量 a 就可以了
    function add() {
      // 1 把所有参数转换成数组
      let args = Array.prototype.slice.call(arguments)
      // 2 再次调用add函数，传递合并当前与之前的参数
      let fn = function () {
        let arg_fn = Array.prototype.slice.call(arguments)
        return add.apply(null, args.concat(arg_fn))
      }
      // 3 最后默认调用，返回合并的值
      fn.toString = function () {
        return args.reduce(function (a, b) {
          return a + b
        })
      }
      return fn
    }

    // ES6写法
    function add() {
      let args = [...arguments];
      let fn = function () {
        return add.apply(null, args.concat([...arguments]))
      }
      fn.toString = () => args.reduce((a, b) => a + b)
      return fn;
    }

    // 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先
    // 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
    // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
    // 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
    // 示例 1:
    // 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
    // 输出: 6 
    // 解释: 节点 2 和节点 8 的最近公共祖先是 6。
    // 示例 2:
    // 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
    // 输出: 2
    // 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
    // 说明:
    // 所有节点的值都是唯一的。
    // p、q 为不同节点且均存在于给定的二叉搜索树中。
    var lowestCommonAncestor = function (root, p, q) {
      if (root == null) return null;
      if (p.val === q.val) return p;
      while (root) {
        if (p.val < root.val && q.val < root.val) {
          root = root.left;
          lowestCommonAncestor(root, p, q)
        } else if (p.val > root.val && q.val > root.val) {
          root = root.right;
          lowestCommonAncestor(root, p, q)
        } else {
          return root
        }
      }
    };

    // 剑指 Offer 68 - II. 二叉树的最近公共祖先
    // 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
    // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
    // 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
    // 示例 1:
    // 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
    // 输出: 3
    // 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
    // 示例 2:
    // 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
    // 输出: 5
    // 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
    // 说明:
    // 所有节点的值都是唯一的。
    // p、q 为不同节点且均存在于给定的二叉树中。
    var lowestCommonAncestor = function (root, p, q) {
      if (!root || root === p || root === q) return root;
      const left = lowestCommonAncestor(root.left, p, q);
      const right = lowestCommonAncestor(root.right, p, q);
      if (!left) return right; // 左子树找不到，返回右子树
      if (!right) return left; // 右子树找不到，返回左子树
      return root;
    };

    //正常的斐波拉契数列js实现方式
    const Fibonacci = (n) => {
      if (n <= 1) return 1;
      return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
    Fibonacci(10) // 89
    Fibonacci(40) // 165580141 计算缓慢有延迟了
    Fibonacci(100) // 栈溢出，无法得到结果复制代码
    //使用尾递归优化该方法
    const Fibonacci = (n, sum1 = 1, sum2 = 1) => {
      if (n <= 1) return sum2;
      return Fibonacci(n - 1, sum2, sum1 + sum2)
    }
    Fibonacci(10) // 89
    Fibonacci(100) // 573147844013817200000 速度依旧很快

    // 手写Bind、Apply、Call 【美团、神策数据】
    // 手写debounce、throttle 【美团、快手】
    // 基础算法题：冒泡、快速、插入、深度优先（DFS）、广度优先（BFS）、二分查找 【不知名的小公司】
    // 合并乱序区间 【快手、美团】
    // 连续子数组最大和【阿里】
    //     class Solution {
    //     public int maxSubArray(int[] nums) {
    //         if (nums == null || nums.length <= 0) {
    //             return 0;
    //         }

    //         int length = nums.length;
    //         int[] dp = new int[length]; // 动归数组
    //         dp[0] = nums[0];
    //         int maxSum = nums[0];
    //         for (int i = 1; i < length; i++) {
    //             if (dp[i-1] > 0) {
    //                 dp[i] = dp[i - 1] + nums[i];
    //             } else {
    //                 dp[i] = nums[i];
    //             }
    //             maxSum = Math.max(maxSum, dp[i]);
    //         }

    //         return maxSum;
    //     }
    // }
    // 千分位【阿里】
    function formatNumber(num) {
      if (!num) return "";
      let [int, float] = num.split(".");
      let intArr = int.split("");
      let result = [];
      let i = 0;
      while (intArr.length) {
        if (i !== 0 && i % 3 === 0) {
          result.unshift(intArr.pop() + ",");
        } else {
          result.unshift(intArr.pop());
        }
        i++;
      }

      return result.join("") + "." + (float ? float : "");
    }

    function format(num) {
      return (num + '').replace(/(\d{1,3})(?=(\d{3})+(?:\.\d*))/g, '$1,');
    }
    // 无重复字符串的最长子串(剑指 Offer 48. 最长不含重复字符的子字符串)(无重复字符的最长子串长度)(第一求子串长度 第二求子串)

    // 数组转树形对象【头条】
    // 数组拍平和对象拍平【快手】
    //{a:"1",b:{c:"1",d:"1"}} => {a: "1", b.c: "1", b.d: "1"}
    // JSON.flatten = function (data) {
    //   var result = {};
    //   function recurse(cur, prop) {
    //     if (Object(cur) !== cur) {
    //       result[prop] = cur;
    //     } else if (Array.isArray(cur)) {
    //       for (var i = 0, l = cur.length; i < l; i++)
    //         recurse(cur[i], prop + "[" + i + "]");
    //       if (l == 0)
    //         result[prop] = [];
    //     } else {
    //       var isEmpty = true;
    //       for (var p in cur) {
    //         isEmpty = false;
    //         recurse(cur[p], prop ? prop + "." + p : p);
    //       }
    //       if (isEmpty && prop)
    //         result[prop] = {};
    //     }
    //   }
    //   recurse(data, "");
    //   return result;
    // };

    Object.flatten = function (obj) {
      var result = {};

      function recurse(src, prop) {
        var toString = Object.prototype.toString;
        if (toString.call(src) == '[object Object]') {
          var isEmpty = true;
          for (var p in src) {
            isEmpty = false;
            recurse(src[p], prop ? prop + '.' + p : p)
          }
          if (isEmpty && prop) {
            result[prop] = {};
          }
        } else if (toString.call(src) == '[object Array]') {
          var len = src.length;
          if (len > 0) {
            src.forEach(function (item, index) {
              recurse(item, prop ? prop + '.[' + index + ']' : index);
            })
          } else {
            result[prop] = [];
          }
        } else {
          result[prop] = src;
        }
      }
      recurse(obj, '');

      return result;
    }
    // 数组乱序
    // 手写一个简易版的redux
    // 两数之和
    // 合并有序数组【便利蜂、快手、美团】
    // 字符串全排列 【头条】
    // 剑指 Offer 38. 字符串的排列
    // 输入一个字符串， 打印出该字符串中字符的所有排列。
    // 你可以以任意顺序返回这个字符串数组， 但里面不能有重复元素。
    // 示例:
    // 输入： s = "abc"
    // 输出：["abc", "acb", "bac", "bca", "cab", "cba"]
    // 限制：
    // 1 <= s 的长度 <=8
    var permutation = function (s) {
      const res = new Set()
      const visit = {}

      function dfs(path) {
        if (path.length === s.length) return res.add(path)
        for (let i = 0; i < s.length; i++) {
          if (visit[i]) continue
          visit[i] = true
          dfs(path + s[i])
          visit[i] = false
        }
      }
      dfs('')
      return [...res]
    };
    // 实现一个dialog 【快手】
    // 实现一个并发控制的request【快手】
    async function eachLimit(limit, arr, iteratorFn) {
      const res = [];
      const activeList = [];
      for (const item of arr) {
        const p = iteratorFn(item);
        res.push(p);
        const e = p.then(() =>
          activeList.splice(activeList.indexOf(e), 1)
        );
        activeList.push(e)
        while (activeList.length >= limit) {
          await Promise.race(activeList)
        }
      }
      return Promise.all(res);
    }
    async function asyncLoop(limit, arr, iteratorFn) {
      const queues = new Array(limit).fill(0).map(() => Promise.resolve());
      let index = 0;
      const add = cb => {
        index = (index + 1) % limit;
        return queues[index] = queues[index].then(() => cb());
      };
      let results = [];
      for (let v of arr) {
        results.push(add(() => iteratorFn(v)));
      }
      return await Promise.all(results);
    };
    //测试代码
    async function test() {
      const timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));
      const results = await eachLimit(2, [1000, 5000, 3000, 2000], timeout);
      console.log(results);
    }

    // 第一种方法： 主要是利用了 Promise.race , 以及包装原来的 promise 实例进一个新的promise 实例，在 then 里面处理队列，即是把完成的自己移除队列。
    // 第二种方法： 使用了 N 个序列，每个序列都是 promise.then 的链式调用。

    // 作者：22earth
    // 链接：https://juejin.cn/post/6844903972776460301
    // 来源：掘金
    // 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

    // 实现一个多维数组代理器 【快手】
    /**
     * 对象、数组变化监听(增删改)
     * @author w-bing
     * @date 2020-04-22
     * @param {Object} obj
     * @param {Function} cb
     * @return {Proxy}
     */
    function deepProxy(obj, cb) {

      if (typeof obj === 'object') {

        for (let key in obj) {
          if (typeof obj[key] === 'object') {
            obj[key] = deepProxy(obj[key], cb);
          }
        }

      }

      return new Proxy(obj, {

        /**
         * @param {Object, Array} target 设置值的对象
         * @param {String} key 属性
         * @param {any} value 值
         * @param {Object} receiver this
         */
        set: function (target, key, value, receiver) {

          if (typeof value === 'object') {
            value = deepProxy(value, cb);
          }

          let cbType = target[key] == undefined ? 'create' : 'modify';

          //排除数组修改length回调
          if (!(Array.isArray(target) && key === 'length')) {
            cb(cbType, {
              target,
              key,
              value
            });
          }
          return Reflect.set(target, key, value, receiver);

        },
        deleteProperty(target, key) {
          cb('delete', {
            target,
            key
          });
          return Reflect.deleteProperty(target, key);
        }

      });

    }

    // 实现一个lazyman 【阿里】  
    // LazyMan('Hank');
    // // 输出:
    // // Hi! This is Hank!

    // LazyMan('Hank').sleep(3).eat('dinner')
    // // 输出:
    // // Hi! This is Hank!
    // // //等待3秒..
    // // Wake up after 3
    // // Eat dinner~

    // LazyMan('Hank').eat('dinner').eat('supper')
    // // 输出:
    // // Hi This is Hank!
    // // Eat dinner~
    // // Eat supper~

    // LazyMan('Hank').sleepFirst(2).eat('dinner').sleep(3).eat('supper')
    // // 输出:
    // // //等待2秒..
    // // Wake up after 2
    // // Hi This is Hank!
    // // Eat dinner~
    // // //等待3秒..
    // // Wake up after 2
    // // Eat supper~

    // // 以此类推
    // class _LazyMan {
    //   queue: any[] = [];
    //   constructor(name: string) {
    //     this.sayName(name);

    //     setTimeout(() => {
    //       this.next();
    //     })
    //   }

    //   next() {
    //     const fn = this.queue.shift();
    //     fn && fn();
    //   }

    //   _holdOn(time) {
    //     return () => {
    //       setTimeout(() => {
    //         console.log(`Wake up after ${time} second`)
    //         this.next()
    //       }, time * 1000)
    //     }
    //   }

    //   sayName(name) {
    //     const fn = () => {
    //       console.log(`Hi! This is ${name}!`);
    //       this.next();
    //     }
    //     this.queue.push(fn);
    //   }

    //   sleep(time: number) {
    //     this.queue.push(this._holdOn(time));
    //     return this;
    //   }

    //   eat(some: string) {
    //     const fn = () => {
    //       console.log(`Eat ${some}~`);
    //       this.next();
    //     }
    //     this.queue.push(fn);
    //     return this;
    //   }

    //   sleepFirst(time: number) {
    //     this.queue.unshift(this._holdOn(time));
    //     return this;
    //   }
    // }

    // const LazyMan = (name: string) => new _LazyMan(name);

    // LazyMan('Hank').sleepFirst(2).eat('dinner').sleep(3).eat('supper');



    // 深克隆(深拷贝 面试官惊艳版)
    //深拷贝考虑 DOM Node  RegExp Date Array Object克隆版
    // function deepClone(obj) {
    //   var _toString = Object.prototype.toString;
    //   // null, undefined, non-object, function
    //   if (!obj || typeof obj !== 'object') {
    //     return obj;
    //   }
    //   // DOM Node
    //   if (obj.nodeType && 'cloneNode' in obj) {
    //     return obj.cloneNode(true);
    //   }
    //   // Date
    //   if (_toString.call(obj) === '[object Date]') {
    //     return new Date(obj.getTime());
    //   }
    //   // RegExp
    //   if (_toString.call(obj) === '[object RegExp]') {
    //     var flags = [];
    //     if (obj.global) { flags.push('g'); }
    //     if (obj.multiline) { flags.push('m'); }
    //     if (obj.ignoreCase) { flags.push('i'); }
    //     return new RegExp(obj.source, flags.join(''));
    //   }
    //   var result = Array.isArray(obj) ? [] :
    //     obj.constructor ? new obj.constructor() : {};

    //   for (var key in obj) {
    //     result[key] = deepClone(obj[key]);
    //   }

    //   return result;
    // }
    function deepClone(obj, hash = new WeakMap()) {
      if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
      if (obj instanceof Date) return new Date(obj);
      if (obj instanceof RegExp) return new RegExp(obj);
      // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
      if (typeof obj !== "object") return obj;
      // 是对象的话就要进行深拷贝
      if (hash.get(obj)) return hash.get(obj);
      let cloneObj = new obj.constructor();
      // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
      hash.set(obj, cloneObj);
      for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
          // 实现一个递归拷贝
          cloneObj[key] = deepClone(obj[key], hash);
        }
      }
      return cloneObj;
    }
    let obj = {
      name: 1,
      address: {
        x: 100
      }
    };
    obj.o = obj; // 对象存在循环引用的情况
    let d = deepClone(obj);
    obj.address.x = 200;
    console.log(d);

    //proxy实现节流/防抖
    function workSomething(i) {
      console.log(new Date().getTime(), i); // 最终打印 1553181456163 4
    }

    function makeThrottle(fn, delay) {
      let makeTimer = null;
      return new Proxy(fn, {
        apply(target, thisArg, argumentList) {
          clearTimeout(makeTimer);
          makeTimer = setTimeout(() => {
            Reflect.apply(target, thisArg, argumentList);
          }, delay);
        }
      });
    }
    const workSomethingProxy = makeThrottle(workSomething, 100);
    for (let i = 0; i < 5; i++) {
      workSomethingProxy(i);
    }

    //用proxy实现节流
    function work(i) {
      console.log(new Date().getTime(), i)
    }

    function make(fn, delay) {
      let timer
      return new Proxy(fn, {
        apply(target, thisArg, argArray) {
          console.log(target, thisArg, argArray)
          if (!timer) {
            timer = setTimeout(function () {
              timer = null
              Reflect.apply(target, thisArg, argArray)
            }, delay)
          }
        }
      })
    }
    make(work, 1000).call(window, 2)
    // 剑指offer专题

    // 剑指 Offer 03. 数组中重复的数字
    // 找出数组中重复的数字。
    // 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
    // 示例 1：
    // 输入：
    // [2, 3, 1, 0, 2, 5, 3]
    // 输出：2 或 3 
    // 限制：
    // 2 <= n <= 100000
    /**
     * @param {number[]} nums
     * @return {number}
     */
    //用hash
    var findRepeatNumber = function (nums) {
      const map = {};
      for (const num of nums) {
        if (!map[num]) {
          map[num] = true;
        } else {
          return num;
        }
      }
    };
    //用set
    var findRepeatNumber = function (nums) {
      let s = new Set();
      for (var i in nums) {
        var curLenth = s.size;
        s.add(nums[i]);
        if (s.size == curLenth)
          return nums[i];
      }
    };
    //用数组
    var findRepeatNumber = function (nums) {
      nums.sort((a, b) => {
        return a - b;
      })
      let preNum = nums[0];
      for (let i = 1; i < nums.length; i++) {
        if (preNum === nums[i]) {
          return preNum;
        }
        preNum = nums[i];
      }
    };

    // 剑指 Offer 04. 二维数组中的查找
    // 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
    // 示例:
    // 现有矩阵 matrix 如下：
    // [
    //   [1,   4,  7, 11, 15],
    //   [2,   5,  8, 12, 19],
    //   [3,   6,  9, 16, 22],
    //   [10, 13, 14, 17, 24],
    //   [18, 21, 23, 26, 30]
    // ]
    // 给定 target = 5，返回 true。
    // 给定 target = 20，返回 false。
    // 限制：
    // 0 <= n <= 1000
    // 0 <= m <= 1000
    /**
     * @param {number[][]} matrix
     * @param {number} target
     * @return {boolean}
     */
    // 方法一: 循环 + 二分
    // 每一行是递增的, 所以可以用二分查找每行


    /**
     * @param {number[][]} matrix
     * @param {number} target
     * @return {boolean}
     */
    var findNumberIn2DArray = function (matrix, target) {
      let m = matrix.length
      if (!m) return false
      let n = matrix[0].length
      for (let i = 0; i < m; i++) {
        let item = matrix[i]
        if (target >= item[0]) {
          if (bs(item, target)) return true
        } else {
          return false
        }
      }
      return false
    };
    // 二分查找
    function bs(arr, t) {
      let i = 0
      let j = arr.length
      while (i < j) {
        let m = i + ((j - i) >> 1)
        if (arr[m] === t) {
          return true
        } else if (arr[m] > t) {
          j = m
        } else {
          i = m + 1
        }
      }
      return false
    }
    // 时间O(mlogn)
    // 但这样好像没有充分利用题目的纵向也是递增的, 所以有更加快捷的方法

    // 方法二: 从右上角 往左下找
    // 横纵都是递增的, 所以从矩阵的 右上角 往 左下查找
    // 当前比目标大, 如果目标存在, 只能在左下边, 此时范围缩小一列
    // 当前比目标小, 目标存在的话, 只能在下边, 当前行不存在目标值, 此时范围缩小一行

    var findNumberIn2DArray = function (matrix, target) {
      let m = matrix.length
      if (!m) return false
      let n = matrix[0].length
      let i = 0,
        j = n - 1
      while (i < m && j >= 0) { // 从右上角 往左下找
        let t = matrix[i][j]
        if (t === target) {
          return true
        } else if (t > target) { // 大于目标, 说明在左/下边
          j--
        } else { // 小于目标, 说明在下边
          i++
        }
      }
      return false
    };
    //时间O(m + n)

    // 剑指 Offer 05. 替换空格
    // 请实现一个函数，把字符串 s 中的每个空格替换成"%20"。
    // 示例 1：
    // 输入：s = "We are happy."
    // 输出："We%20are%20happy."
    // 限制：
    // 0 <= s 的长度 <= 10000

    // 剑指 Offer 06. 从尾到头打印链表
    // 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
    // 示例 1：
    // 输入：head = [1,3,2]
    // 输出：[2,3,1]
    // 限制：
    // 0 <= 链表长度 <= 10000
    /**
     * @param {ListNode} head
     * @return {number[]}
     */
    var reversePrint = function (head) {
      if (head === null) return []
      const res = []
      while (head) {
        res.push(head.val)
        head = head.next
      }
      return res.reverse()
    }

    // 首先将链表反转
    function reverseLink(head) {
      if (head === null || head.next === null) return head
      let p = head.next
      head.next = null
      let tmp = null
      while (p !== null) {
        tmp = p.next // tmp 指针前进（保存下一个指针信息）
        p.next = head // 指针反转
        head = p // head 指针前进
        p = tmp // p 指针前进
      }
      return head
    }

    //递归反转链表
    function reverseLink(head) {
      if (head === null || head.next === null) return head
      const p = reverseLink(head.next)
      head.next.next = head // 指针反转
      head.next = null
      return p // 返回真正的表头
    }

    // 剑指 Offer 09. 用两个栈实现队列
    // 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
    // 示例 1：

    // 输入：
    // ["CQueue","appendTail","deleteHead","deleteHead"]
    // [[],[3],[],[]]
    // 输出：[null,null,3,-1]
    // 示例 2：

    // 输入：
    // ["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
    // [[],[],[5],[2],[],[]]
    // 输出：[null,-1,null,null,5,2]
    // 提示：

    // 1 <= values <= 10000
    // 最多会对 appendTail、deleteHead 进行 10000 次调用
    // 解题思路:栈后进先出，队列先进先出
    // 双栈可以实现序列倒置：假设有 stack1=[1, 2, 3] 、 stack2=[] ，如果循环出栈 stack1 并将出栈元素进栈 stack2 ，则循环结束后， stack1=[] 、 stack2=[3, 2, 1] ，即通过 stack2 实现了 stack1 中元素的倒置
    // 当需要删除队首元素时，仅仅需要 stack2 出栈即可；当 stack2 为空时，出队就需要将 stack1 元素倒置倒 stack2 ， stack2 再出队即可；如果 stack1 也为空，即队列中没有元素，返回 -1

    var CQueue = function () {
      this.stack1 = []
      this.stack2 = []
    };
    CQueue.prototype.appendTail = function (value) {
      this.stack1.push(value)
    };
    CQueue.prototype.deleteHead = function () {
      if (this.stack2.length) {
        return this.stack2.pop()
      }
      if (!this.stack1.length) return -1
      while (this.stack1.length) {
        this.stack2.push(this.stack1.pop())
      }
      return this.stack2.pop()
    };

    // 剑指 Offer 11. 旋转数组的最小数字
    // 把一个数组最开始的若干个元素搬到数组的末尾， 我们称之为数组的旋转。 输入一个递增排序的数组的一个旋转， 输出旋转数组的最小元素。 例如， 数组[3, 4, 5, 1, 2] 为[1, 2, 3, 4,
    //   5] 的一个旋转， 该数组的最小值为1。
    // 示例 1：
    // 输入：[3, 4, 5, 1, 2]
    // 输出： 1
    // 示例 2：
    // 输入：[2, 2, 2, 0, 1]
    // 输出： 0
    const minArray = (nums) => {
      let left = 0;
      let right = nums.length - 1;
      while (left < right) {
        const mid = left + right >>> 1;
        if (nums[mid] > nums[right]) {
          left = mid + 1;
        } else if (nums[mid] == nums[right]) {
          right--;
        } else {
          right = mid;
        }
      }
      return nums[left];
    };

    // 剑指 Offer 12. 矩阵中的路径
    // 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

    // [["a","b","c","e"],
    // ["s","f","c","s"],
    // ["a","d","e","e"]]

    // 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

    // 示例 1：

    // 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
    // 输出：true
    // 示例 2：

    // 输入：board = [["a","b"],["c","d"]], word = "abcd"
    // 输出：false
    // 提示：

    // 1 <= board.length <= 200
    // 1 <= board[i].length <= 200
    // 注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/
    /**
     * @param {character[][]} board
     * @param {string} word
     * @return {boolean}
     */
    //经典的回溯算法题，和八皇后问题类似。
    /**
     * @param {character[][]} board
     * @param {string} word
     * @return {boolean}
     */
    var exist = function (board, word) {
      //这里可以采用回溯算法的思想，和八皇后问题类似
      const xLen = board.length;
      const yLen = board[0].length;
      const k = 0;
      for (let x = 0; x < xLen; x++) {
        for (let y = 0; y < yLen; y++) {
          if (findFun(board, word, x, y, k, xLen, yLen)) return true;
        }
      }
      return false;
    };
    //用于判断board[x][y]的上下左右是否有work[k+1]，若有返回true
    //这里有个细节，没必要一直求值的数据就以参数的形式传到函数中，不要每次都计算，比如此题中的xLen，yLen
    function findFun(board, word, x, y, k, xLen, yLen) {
      if (x < 0 || x >= xLen || y < 0 || y >= yLen || board[x][y] != word[k])
        return false;
      if (k == word.length - 1) //word到底了
        return true;
      let temp = board[x][y];
      board[x][y] = '-';
      let res = findFun(board, word, x - 1, y, k + 1, xLen, yLen) || findFun(board, word, x, y + 1, k + 1, xLen,
        yLen) || findFun(board, word, x + 1, y, k + 1, xLen, yLen) || findFun(board, word, x, y - 1, k + 1, xLen,
          yLen); //上 右 下 左
      // board[x][y] = word[k];
      board[x][y] = temp;
      return res;
    }

    // 剑指 Offer 13. 机器人的运动范围
    // 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

    // 示例 1：

    // 输入：m = 2, n = 3, k = 1
    // 输出：3
    // 示例 2：

    // 输入：m = 3, n = 1, k = 0
    // 输出：1
    // 提示：

    // 1 <= n,m <= 100
    // 0 <= k <= 20

    // 剑指 Offer 14- II. 剪绳子 II
    // 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

    // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

    // 示例 1：

    // 输入: 2
    // 输出: 1
    // 解释: 2 = 1 + 1, 1 × 1 = 1
    // 示例 2:

    // 输入: 10
    // 输出: 36
    // 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

    // 提示：

    // 2 <= n <= 1000
    /**
     * @param {number} n
     * @return {number}
     */
    var cuttingRope = function (n) {

      let reMax = 0;
      let resArr = [0, 0, 1, 2, 4];
      if (n < 5) {
        return resArr[n];
      }
      let mod = 1e9 + 7;
      let res = 1;
      while (n >= 5) {
        res = res % mod * 3;
        n = n - 3;
      }
      return res * n % mod;
    };

    // 剑指 Offer 17. 打印从1到最大的n位数
    // 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

    // 示例 1:

    // 输入: n = 1
    // 输出: [1,2,3,4,5,6,7,8,9]

    // 说明：

    // 用返回一个整数列表来代替打印
    // n 为正整数
    /**
     * @param {number} n
     * @return {number[]}
     */
    var printNumbers = function (n) {
      return Array.from({
        length: 10 ** n - 1
      }, (item, index) => index + 1)
    };


    // 剑指 Offer 18. 删除链表的节点
    // 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

    // 返回删除后的链表的头节点。

    // 注意：此题对比原题有改动

    // 示例 1:

    // 输入: head = [4,5,1,9], val = 5
    // 输出: [4,1,9]
    // 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
    // 示例 2:

    // 输入: head = [4,5,1,9], val = 1
    // 输出: [4,5,9]
    // 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.

    /**
     * @param {ListNode} head
     * @param {number} val
     * @return {ListNode}
     */
    var deleteNode = function (head, val) {
      if (head.val == val) {
        return head.next
      }
      /**
       * 假设【1，2，3】，目标值是2
       * 当前head是1.
       * 本来head.next是2,但是调用deletenode函数的时候刚刚好2==2,把2（head）的下一个值3的指针返回回去
       * 所以head.next = 3
       * 1->3
       * 
       */
      head.next = deleteNode(head.next, val);
      return head
    };

    // 面试题 02.01. 移除重复节点
    // 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

    // 示例1:

    // 输入：[1, 2, 3, 3, 2, 1]
    // 输出：[1, 2, 3]
    // 示例2:

    // 输入：[1, 1, 1, 1, 2]
    // 输出：[1, 2]
    // 提示：

    // 链表长度在[0, 20000]范围内。
    // 链表元素在[0, 20000]范围内。
    // 进阶：

    // 如果不得使用临时缓冲区，该怎么解决？
    // 设置缓冲区arr, 把链表的每个节点val作为arr的key, 将value设置为1
    // 查找arr[current.val]. 如果有值为1的元素, 说明重复, 需要删除
    var removeDuplicateNodes = function (head) {
      // 缓冲区
      let arr = [];
      let prev = null;
      let current = head;
      while (current !== null) {
        if (arr[current.val] > 0) {
          // 有重复的
          prev.next = current.next;
          current = prev.next;
        } else {
          arr[current.val] = 1;
          prev = current;
          current = current.next;
        }
      }
      return head;
    };

    // 剑指 Offer 26. 树的子结构
    // 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

    // B是A的子结构， 即 A中有出现和B相同的结构和节点值。

    // 例如:
    // 给定的树 A:

    //      3
    //     / \
    //    4   5
    //   / \
    //  1   2
    // 给定的树 B：

    //    4 
    //   /
    //  1
    // 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

    // 示例 1：

    // 输入：A = [1,2,3], B = [3,1]
    // 输出：false
    // 示例 2：

    // 输入：A = [3,4,5,1,2], B = [4,1]
    // 输出：true
    // 限制：

    // 0 <= 节点个数 <= 10000
    /**
     * @param {TreeNode} A
     * @param {TreeNode} B
     * @return {boolean}
     */
    var isSubStructure = function (A, B) {
      // 约定空树不是任意一个树的子结构
      if (!A || !B) {
        return false;
      }
      return isSameTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)
    };

    /**
     * @param {TreeNode} A
     * @param {TreeNode} B
     * @return {boolean}
     */
    var isSameTree = function (A, B) {
      // B子树是空子树 ok
      if (!B) {
        return true;
      }
      // A子树是空子树 且 B 非空，不 ok
      if (!A) {
        return false;
      }
      // 当前节点的值不相等，不 ok
      if (A.val !== B.val) {
        return false;
      }
      // 递归考察左子树、右子树
      return isSameTree(A.left, B.left) && isSameTree(A.right, B.right);
    };

    // 剑指 Offer 29. 顺时针打印矩阵
    // 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

    // 示例 1：

    // 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
    // 输出：[1,2,3,6,9,8,7,4,5]
    // 示例 2：

    // 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
    // 输出：[1,2,3,4,8,12,11,10,9,5,6,7]

    // 限制：

    // 0 <= matrix.length <= 100
    // 0 <= matrix[i].length <= 100
    const spiralOrder = (matrix) => {
      if (matrix.length == 0) return [];
      const res = [];

      let top = 0;
      let bottom = matrix.length - 1;
      let left = 0;
      let right = matrix[0].length - 1;

      while (top < bottom && left < right) {
        for (let i = left; i < right; i++) res.push(matrix[top][i]); // 上层
        for (let i = top; i < bottom; i++) res.push(matrix[i][right]); // 右层
        for (let i = right; i > left; i--) res.push(matrix[bottom][i]); // 下层
        for (let i = bottom; i > top; i--) res.push(matrix[i][left]); // 左层
        right--;
        top++;
        bottom--;
        left++;
      }
      if (top == bottom) { // 剩下一行，从左到右依次添加
        for (let i = left; i <= right; i++) {
          res.push(matrix[top][i]);
        }
      } else if (left == right) { // 剩下一列，从上到下依次添加
        for (let i = top; i <= bottom; i++) {
          res.push(matrix[i][left]);
        }
      }
      return res;
    };

    // 剑指 Offer 39. 数组中出现次数超过一半的数字
    // 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

    // 你可以假设数组是非空的，并且给定的数组总是存在多数元素。

    // 示例 1:

    // 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
    // 输出: 2

    // 限制：

    // 1 <= 数组长度 <= 50000
    var majorityElement = function (nums) {
      let count = 1;
      let majority = nums[0];
      for (let i = 1; i < nums.length; i++) {
        if (count === 0) {
          majority = nums[i];
        }
        if (nums[i] === majority) {
          count++;
        } else {
          count--;
        }
      }
      return majority;
    };

    //美团 var arr =[[‘A’,’B’],[‘a’,’b’],[1,2]] 求二维数组的全排列组合 结果：Aa1,Aa2,Ab1,Ab2,Ba1,Ba2,Bb1,Bb2

    // var versions = ["1.45.0", "1.5", "6", "3.3.3.3.3.3.3"];
    // // 要求从小到大排序，注意'1.45'比'1.5'大
    // // => ['1.5','1.45.0','3.3.3.3.3.3','6']
    // 公司：头条
    function sortVersion(list) {
      return list.sort((a, b) => {
        let aa = a.split(".")
        let bb = b.split(".")
        let len = aa.length > bb.length ? aa.length : bb.length
        for (let i = 0; i < len; i++) {
          let x = aa[i] || 0
          let y = bb[i] || 0
          if (x - y !== 0) {
            return x - y
          }
        }
      })
    }

    //头条
    // function repeat(func, times, wait) {
    // }
    // const repeatFunc = repeat(alert, 4, 3000);
    // 调用这个 repeatFunc ("hellworld")，会alert4次 helloworld, 每次间隔3秒
    function repeat(func, times, wait) {
      let n = times
      let timer = null
      return function (arg) {
        timer = setInterval(() => {
          console.log(arg)
          n--
          n === 0 && clearInterval(timer)
        }, 3000)
      }
    }

    // 1.写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal
    // 公司：头条

    function mySetInterVal(fn, a, b) {
      let timeCount = 0;
      let timer
      const loop = () => {
        timer = setTimeout(() => {
          fn()
          timeCount++
          loop()
        }, a + timeCount * b)
      }
      loop()
      return () => {
        clearTimeout(timer)
      }
    }
    //测试
    const myClear = mySetInterVal(() => {
      console.log('test')
    }, 1000, 500);
    // 清除定时器
    myClear()

    // 2.合并二维有序数组成一维有序数组，归并排序的思路
    // 公司：头条
    //[[1,2,3],[4,5,6],[7,8,9],[1,2,3],[4,5,6]].flat(Infinity).sort((a,b)=>{ return a-b;})
    function merge(arr1, arr2) {
      var result = [];
      while (arr1.length > 0 && arr2.length > 0) {
        if (arr1[0] < arr2[0]) {
          /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/
          result.push(arr1.shift());
        } else {
          result.push(arr2.shift());
        }
      }
      return result.concat(arr1).concat(arr2);
    }

    function mergeSort(arr) {
      let lengthArr = arr.length;
      if (lengthArr === 0) {
        return [];
      }
      while (arr.length > 1) {
        let arrayItem1 = arr.shift();
        let arrayItem2 = arr.shift();
        let mergeArr = merge(arrayItem1, arrayItem2);
        arr.push(mergeArr);
      }
      return arr[0];
    }

    // 有一堆整数，请把他们分成三份，确保每一份和尽量相等（11，42，23，4，5，6 4 5 6 11 23 42 56 78 90）
    // 公司：滴滴

    // 面试题 01.02. 判定是否互为字符重排
    // 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

    // 示例 1：

    // 输入: s1 = "abc", s2 = "bca"
    // 输出: true 
    // 示例 2：

    // 输入: s1 = "abc", s2 = "bad"
    // 输出: false
    // 说明：

    // 0 <= len(s1) <= 100
    // 0 <= len(s2) <= 100
    /**
     * @param {string} s1
     * @param {string} s2
     * @return {boolean}
     */
    // var CheckPermutation = function(s1, s2) {
    // return s1.split('').sort().toString()===s2.split('').sort().toString();
    // };
    var CheckPermutation = function (s1, s2) {
      //长度不对等,肯定不行的
      if (s1.length != s2.length) {
        return false;
      }
      s2 = s2.split('');
      //直接循环
      for (let s of s1) {
        if (s2.indexOf(s) == -1) {
          return false;
        } else {
          s2.splice(s2.indexOf(s), 1);
        }
      }
      return true;
    };

    // 面试题 01.04. 回文排列
    // 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

    // 回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

    // 回文串不一定是字典当中的单词。

    // 示例1：

    // 输入："tactcoa"
    // 输出：true（排列有"tacocat"、"atcocta"，等等）
    /**
     * @param {string} s
     * @return {boolean}
     */
    var canPermutePalindrome = function (s) {
      let obj = {};
      for (let i = 0; i < s.length; i++) {
        let char = s[i];
        if (obj[char])
          delete obj[char]
        else
          obj[char] = 1;
      }
      return Object.keys(obj).length <= 1;
    };

    // 面试题 01.05. 一次编辑
    // 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

    // 示例 1:

    // 输入: 
    // first = "pale"
    // second = "ple"
    // 输出: True

    // 示例 2:

    // 输入: 
    // first = "pales"
    // second = "pal"
    // 输出: False
    /**
     * @param {string} first
     * @param {string} second
     * @return {boolean}
     */
    var oneEditAway = function (first, second) {
      var arr1 = first.split('')
      var arr2 = second.split('');
      var flag = false

      if (Math.abs(arr1.length - arr2.length) > 1) return false

      for (var i = 0, j = 0; i < arr1.length && j < arr2.length; i++, j++) {
        if (arr1[i] != arr2[j]) {
          if (flag) return false
          flag = true

          if (arr1.length != arr2.length) {
            arr1.length > arr2.length ? i++ : j++
            i--;
            j--
          }
        }
      }
      return true
    };

    var oneEditAway = function (first, second) {
      if (first === second) {
        return true
      }
      let a = first.length;
      let b = second.length;
      if (a === b) {
        let c = 0;
        for (let i = 0; i < a; i++) {
          if (first[i] !== second[i]) {
            c++
          }
        }
        return c <= 1
      } else if (a - b === 1 || -1) {
        let s1 = a > b ? first : second;
        let s2 = a < b ? first : second;
        for (let i = 0; i < s1.length; i++) {
          if (s1[i] !== s2[i]) {
            return s1.substring(i + 1) === s2.substring(i)
          }
        }
      }
      return false
    };

    // 面试题 01.06. 字符串压缩
    // 字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

    // 示例1:

    //  输入："aabcccccaaa"
    //  输出："a2b1c5a3"
    // 示例2:

    //  输入："abbccd"
    //  输出："abbccd"
    //  解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
    // 提示：

    // 字符串长度在[0, 50000]范围内。
    var compressString = function (S) {
      let count = 1;
      let str = new String();
      for (let i = 1; i < S.length + 1; i++) {
        if (S[i - 1] === S[i]) {
          count++
        } else {
          str += S.slice(i - 1, i) + count
          count = 1
        }
      }
      return S.length > str.length ? str : S
    };

    // 面试题 01.07. 旋转矩阵
    // 给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

    // 不占用额外内存空间能否做到？

    // 示例 1:

    // 给定 matrix =
    // [
    // [1,2,3],
    // [4,5,6],
    // [7,8,9]
    // ],

    // 原地旋转输入矩阵，使其变为:
    // [
    // [7,4,1],
    // [8,5,2],
    // [9,6,3]
    // ]
    // 示例 2:

    // 给定 matrix =
    // [
    // [ 5, 1, 9,11],
    // [ 2, 4, 8,10],
    // [13, 3, 6, 7],
    // [15,14,12,16]
    // ],

    // 原地旋转输入矩阵，使其变为:
    // [
    // [15,13, 2, 5],
    // [14, 3, 4, 1],
    // [12, 6, 8, 9],
    // [16, 7,10,11]
    // ]
    //一、倒序倒置法
    let rotate = (matrix) => {
      for (let i = 0; i < matrix.length; i++) {
        for (let j = i; j < matrix[i].length; j++) {
          [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]
        }
      }
      matrix.forEach(row => row.reverse())
    };

    // 面试题 01.09. 字符串轮转
    // 字符串轮转。给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。

    // 示例1:

    //  输入：s1 = "waterbottle", s2 = "erbottlewat"
    //  输出：True
    // 示例2:

    //  输入：s1 = "aa", s2 = "aba"
    //  输出：False
    // 提示：

    // 字符串长度在[0, 100000]范围内。
    // 说明:

    // 你能只调用一次检查子串的方法吗？
    var isFlipedString = function (s1, s2) {
      return s1.length === s2.length && (s2 + s2).includes(s1)
    };

    // 784. 字母大小写全排列
    // 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

    // 示例：
    // 输入：S = "a1b2"
    // 输出：["a1b2", "a1B2", "A1b2", "A1B2"]

    // 输入：S = "3z4"
    // 输出：["3z4", "3Z4"]

    // 输入：S = "12345"
    // 输出：["12345"]

    // 提示：

    // S 的长度不超过12。
    // S 仅由数字和字母组成。
    const letterCasePermutation = S => {
      const res = [];
      const backtrack = (start, s) => {
        res.push(s);
        for (let i = start; i < s.length; i++) {
          if (s[i] >= 'a' && s[i] <= 'z') {
            backtrack(i + 1, s.slice(0, i) + s[i].toUpperCase() + s.slice(i + 1));
          } else if (s[i] >= 'A' && s[i] <= 'Z') {
            backtrack(i + 1, s.slice(0, i) + s[i].toLowerCase() + s.slice(i + 1));
          }
        }
      };
      backtrack(0, S);
      return res;
    };

    //在什么情况下 a === a - 1 ？
    // console.log(Infinity + Infinity); // Infinity
    // console.log(Infinity - Infinity); // NaN
    // console.log(Infinity * Infinity); // Infinity
    // console.log(Infinity / Infinity); // NaN
    // console.log(Infinity * 0); // NaN


    // 方法一:
    let a = Infinity;
    console.log(a === a - 1); // true
    let b = -Infinity;
    console.log(b === b - 1); // true
    let a = Number.MIN_SAFE_INTEGER - 1;
    console.log(a === a - 1); // true
    //方法二:
    let bValue = 1
    Object.defineProperty(window, 'a', {
      get() {
        return bValue++
      }
    });
    console.log(a === a - 1)

    // 如何遍历一个dom树
    function traversal(node) {
      //对node的处理
      if (node && node.nodeType === 1) {
        console.log(node.tagName);
      }
      var i = 0,
        childNodes = node.childNodes,
        item;
      for (; i < childNodes.length; i++) {
        item = childNodes[i];
        if (item.nodeType === 1) {
          //递归先序遍历子节点
          traversal(item);
        }
      }
    }

    //new操作符都做了什么
    // 1、创建一个空对象，并且 this 变量引用该对象，// lat target = {};
    // 2、继承了函数的原型。// target.proto = func.prototype;
    // 3、属性和方法被加入到 this 引用的对象中。并执行了该函数func// func.call(target);
    // 4、新创建的对象由 this 所引用，并且最后隐式的返回 this 。// 如果func.call(target)返回的res是个对象或者function 就返回它

    function _new(func) {
      let target = {};
      target.__proto__ = func.prototype;
      let res = func.call(target);
      //默认情况下函数的返回值为undefined（即没有显示地定义返回值的话）,
      // 但是构造函数比较例外，new构造函数在没有return的情况下默认返回新创建的对象。
      // 但是在有显示返回值的情况下，如果返回值为基本数据类型的话（string，number，boolean，undefined，null），
      // 返回值仍然为新创建的对象，这一点比较奇怪，需要注意。只有在显示返回一个非基本数据类型的对象的时候，
      // 函数的返回值才为指定的对象。
      if (typeof (res) == "object" || typeof (res) == "function") {
        return res;
      }
      return target;
    }

    // 简易版本的promise 
    // 第一步： 列出三大块  this.then   resolve/reject   fn(resolve,reject)
    // 第二步： this.then负责注册所有的函数   resolve/reject负责执行所有的函数 
    // 第三步： 在resolve/reject里面要加上setTimeout  防止还没进行then注册 就直接执行resolve了
    // 第四步： resolve/reject里面要返回this  这样就可以链式调用了
    // 第五步： 三个状态的管理 pending fulfilled rejected

    // *****promise的链式调用 在then里面return一个promise 这样才能then里面加上异步函数
    // 加上了catch
    function PromiseM(fn) {
      var value = null;
      var callbacks = [];
      //加入状态 为了解决在Promise异步操作成功之后调用的then注册的回调不会执行的问题
      var state = 'pending';
      var _this = this;

      //注册所有的回调函数
      this.then = function (fulfilled, rejected) {
        //如果想链式promise 那就要在这边return一个new Promise
        return new PromiseM(function (resolv, rejec) {
          //异常处理
          try {
            if (state == 'pending') {
              callbacks.push(fulfilled);
              //实现链式调用
              return;
            }
            if (state == 'fulfilled') {
              var data = fulfilled(value);
              //为了能让两个promise连接起来
              resolv(data);
              return;
            }
            if (state == 'rejected') {
              var data = rejected(value);
              //为了能让两个promise连接起来
              resolv(data);
              return;
            }
          } catch (e) {
            _this.catch(e);
          }
        });
      }

      //执行所有的回调函数
      function resolve(valueNew) {
        value = valueNew;
        state = 'fulfilled';
        execute();
      }

      //执行所有的回调函数
      function reject(valueNew) {
        value = valueNew;
        state = 'rejected';
        execute();
      }

      function execute() {
        //加入延时机制 防止promise里面有同步函数 导致resolve先执行 then还没注册上函数
        setTimeout(function () {
          callbacks.forEach(function (cb) {
            value = cb(value);
          });
        }, 0);
      }

      this.catch = function (e) {
        console.log(JSON.stringify(e));
      }

      //经典 实现异步回调
      fn(resolve, reject);
    }

    //大厂面试
    //https://github.com/airuikun/Weekly-FE-Interview

    //简单实现async/await中的async函数
    function spawn(genF) {
      return new Promise(function (resolve, reject) {
        const gen = genF();

        function step(nextF) {
          let next;
          try {
            next = nextF();
          } catch (e) {
            return reject(e);
          }
          if (next.done) {
            return resolve(next.value);
          }
          Promise.resolve(next.value).then(
            function (v) {
              step(function () {
                return gen.next(v);
              });
            },
            function (e) {
              step(function () {
                return gen.throw(e);
              });
            }
          );
        }
        step(function () {
          return gen.next(undefined);
        });
      });
    }

    // react项目中，constructor(){ this.target = this.func.bind(this); },JSX里onChange={this.target}的写法，为什么要比非bind的func = () => {}的写法效率高 请解释其中的原理
    // bind之后锁定了上下文，不用向上查找

    //tx小笔试
    Promise.reject("error").then(() => {
      console.log("success1")
    }, () => {
      console.log("error1")
    }).then(() => {
      console.log("success2")
    }, () => {
      console.log("error2")
    })
    //error1 success2

    //tx小笔试
    function a() {
      setTimeout(function () {
        return 1
      }, 1000)
    }
    let b = a()
    console.log(b) //undefined

    //将 aabb 变为 bbaa
    var reg = /(\w)\1(\w)\2/g
    var str = "aabb"
    console.log(str.replace(reg, "$2$2$1$1"))

    //将 the-first-name 变成 theFirstName
    var reg = /-(\w)/g
    var str = "the-first-name"

    console.log(str.replace(reg, function ($, $1) {
      return $1.toUpperCase()
    }))
    //首尾是否都含有数字
    var reg = /^\d[\s\S]*\d$/g
    var str = "123avf9"
    reg.test(str)

    //数组拉平(generator写法)
    function* iterTree(tree) {
      if (Array.isArray(tree)) {
        for (let i = 0; i < tree.length; i++) {
          yield* iterTree(tree[i]);
        }
      } else {
        yield tree;
      }
    }

    const tree = ['a', ['b', 'c'],
      ['d', 'e']
    ];

    // for (let x of iterTree(tree)) {
    //   console.log(x);
    // }
    [...iterTree(tree)] // ["a", "b", "c", "d", "e"]

    // 栈思想
    function flat(arr) {
      const newArr = [];
      const stack = [].concat(arr); // 将数组元素拷贝至栈，直接赋值会改变原数组
      //如果栈不为空，则循环遍历
      while (stack.length !== 0) {
        const val = stack.pop(); // 删除数组最后一个元素，并获取它
        if (Array.isArray(val)) {
          stack.push(...val); // 如果是数组再次入栈，并且展开了一层
        } else {
          newArr.unshift(val); // 如果不是数组就将其取出来放入结果数组中
        }
      }
      return newArr;
    }

    let arr = [12, 23, [34, 56, [78, 90, 100, [110, 120, 130, 140]]]];
    console.log(flat(arr));
    // [12, 23, 34, 56, 78, 90, 100, 110, 120, 130, 140]


    //数组乱序
    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    arr.sort(function () {
      return Math.random() - 0.5;
    })
    console.log(arr);

    //实现一个带并发限制的异步调度器Scheduler，最多同时运行两个任务
    //异步调度器
    class Scheduler {
      constructor(maxNum) {
        //等待执行的任务队列
        this.taskList = []
        //当前任务数
        this.count = 0
        //最大任务数
        this.maxNum = maxNum
      }

      async add(promiseCreator) {
        //当当前任务数超出最大任务数就将其加入等待执行的任务队列
        if (this.count >= this.maxNum) {
          await new Promise(resolve => {
            this.taskList.push(resolve)
          })
        }
        this.count++
        const result = await promiseCreator()
        this.count--
        //当其它任务执行完任务队列中还有任务没执行就将其出队并执行
        if (this.taskList.length > 0) {
          this.taskList.shift()()
        }
        return result
      }
    }

    const timeout = time => {
      return new Promise(resolve => {
        setTimeout(resolve, time)
      })
    }

    const scheduler = new Scheduler(2)
    const addTask = (time, value) => {
      scheduler.add(() => {
        return timeout(time).then(() => {
          console.log(value)
        })
      })
    }

    addTask(1000, "1")
    addTask(500, "2")
    addTask(300, "3")
    addTask(400, "4")

    //此处输出2 -> 3 ->1 -> 4
    //一开始1、2两个任务进入队列
    //500ms时，2完成，输出2，任务3进入队列
    //800ms时，3完成，输出3，任务4进入队列
    //1000ms时，1完成，输出1
    //1200ms时，4完成，输出4

    //如何在ES5环境下实现const
    function _const(key, value) {
      const desc = {
        value,
        writable: false
      }
      Object.defineProperty(window, key, desc)
    }

    _const('obj', {
      a: 1
    }) //定义obj
    obj = {} //重新赋值不生效

    //解析"(1+2+3)*4"(oppo面试题)
    //     概念
    // 　　你可能听说过表达式，a+b，a+b*c这些，但是前缀表达式，前缀记法，中缀表达式，波兰式，后缀表达式，后缀记法，逆波兰式这些都是也是表达式。
    // 　　a+b，a+b*c这些看上去比较正常的是中缀表达式，就是运算符放在两个操作数之间。前缀表达式是将运算符放在相关操作数之前，后缀表达式是将运算符放在操作数之后。
    // 　　至于前面说的那些概念：
    // 　　前缀表达式就是波兰式就是前缀记法
    // 　　后缀表达式就是逆波兰式就是后缀记法
    // 举例如下：
    // (3+4)*5-6就是中缀表达式
    // -*+3456就是前缀表达式
    // 34+5*6-就是后缀表达式
    // 虽然人的大脑很容易理解与分析中缀表达式，但是对于计算机来说中缀表达式确是很复杂的，因此计算表达式的值时通常需要把中置表达式转换为前置或者后置表达式，然后再进行求值。对于计算机来说，计算前缀表达式或者后置表达式非常简单。
    // 中缀表达式转后缀表达式:https://www.cnblogs.com/tylerdonet/p/5816464.html
    /*-------------------栈将中缀表达式转换成后缀表达式-------------------*/
    function suffixExpression() {
      var str = 'a+b*c+(d*e+f)*g';
      var stack = new Stack();
      var outStack = new Array();
      for (var i = 0; i < str.length; ++i) {
        if (')' == str[i]) {
          while (true) {
            var top = stack.peek();
            stack.pop();
            if ('(' != top) {
              outStack[outStack.length] = top;
            } else {
              break;
            }
          }
        } else if (['-', '+'].indexOf(str[i]) > -1) {
          if (['*', '/'].indexOf(stack.peek()) > -1) {
            while (['*', '/'].indexOf(stack.peek()) > -1) {
              outStack[outStack.length] = stack.peek();
              stack.pop();
            }
            outStack[outStack.length] = str[i];
          } else {
            stack.push(str[i]);
          }
        } else if (['(', '*', '/'].indexOf(str[i]) > -1) {
          stack.push(str[i]);
        } else {
          outStack[outStack.length] = str[i];
        }
      }

      for (var i = 0; i < outStack.length; i++) {
        document.write(outStack[i]);
      }
    }
    suffixExpression();

    // 逆波兰表达式求值(后辍表达式求职算法)
    // 根据 逆波兰表示法，求表达式的值。

    // 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

    // 说明：

    // 整数除法只保留整数部分。
    // 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

    // 示例 1：

    // 输入: ["2", "1", "+", "3", "*"]
    // 输出: 9
    // 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
    // 示例 2：

    // 输入: ["4", "13", "5", "/", "+"]
    // 输出: 6
    // 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
    // 示例 3：

    // 输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
    // 输出: 22
    // 解释: 
    // 该算式转化为常见的中缀算术表达式为：
    //   ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
    // = ((10 * (6 / (12 * -11))) + 17) + 5
    // = ((10 * (6 / -132)) + 17) + 5
    // = ((10 * 0) + 17) + 5
    // = (0 + 17) + 5
    // = 17 + 5
    // = 22
    /**
     * @param {string[]} tokens
     * @return {number}
     */
    var evalRPN = function (tokens) {
      let stack = [];
      let num; //由于减法和除法的存在顺序问题
      for (let char of tokens) {
        switch (char) {
          case "+":
            stack.push(stack.pop() + stack.pop());
            break;
          case "-":
            num = stack.pop();
            stack.push(stack.pop() - num);
            break;
          case "*":
            stack.push(stack.pop() * stack.pop());
            break;
          case "/":
            num = stack.pop();
            stack.push(parseInt(stack.pop() / num, 10));
            break;
          default:
            stack.push(parseInt(char, 10));
        }
      }
      return stack.pop();
    };

    //在限定并发数下用 Promise 并发完成请求
    class PromisePool {
      constructor(max, fn) {
        this.max = max; // 最大并发数
        this.fn = fn; // 自定义的请求函数
        this.pool = []; // 并发池
        this.urls = []; // 剩余的请求地址
      }

      start(urls) {
        this.urls = urls;
        // 先循环把并发池塞满
        while (this.pool.length < this.max) {
          let url = this.urls.shift();
          this.setTask(url);
        }
        // 利用Promise.race 方法来获得并发池中某任务完成的信号
        let race = Promise.race(this.pool);
        return this.run(race);
      }

      run(race) {
        race
          .then(res => {
            // 每当并发池跑完一个任务，就再塞入一个任务
            let url = this.urls.shift();
            this.setTask(url);
            return this.run(Promise.race(this.pool));
          });
      }
      setTask(url) {
        if (!url) return;
        let task = this.fn(url);
        this.pool.push(task); // 将该任务推入pool并发池中
        console.log(`\x1B[43m ${url} 开始，当前并发数：${this.pool.length}`);
        task.then(res => {
          // 请求结束后将该Promise任务从并发池中移除
          this.pool.splice(this.pool.indexOf(task), 1);
          console.log(`\x1B[43m ${url} 结束，当前并发数：${this.pool.length}`);
        });
      }
    }

    // test
    const URLs = [
      'bytedance.com',
      'tencent.com',
      'alibaba.com',
      'microsoft.com',
      'apple.com',
      'hulu.com',
      'amazon.com'
    ];
    let dur = 0;
    // 自定义请求函数
    var requestFn = url => {
      return new Promise(resolve => {
        setTimeout(_ => {
          resolve(`任务 ${url} 完成`);
        }, 1000 * dur++)
      }).then(res => {
        console.log('外部逻辑 ', res);
      })
    }

    const pool = new PromisePool(5, requestFn); // 并发数为3
    pool.start(URLs);

    //ts工具泛型 
    //type Keys = "a" | "b" type Obj =  {  [p in Keys]: any} // -> { a: any, b: any }
    //Partial
    //type Partial<T> = { [P in keyof T]?: T[P] };
    //Required
    //type Required<T> = { [P in keyof T]-?: T[P] };
    // 我们发现一个有意思的用法 -?, 这里很好理解就是将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个+? , 这个含义自然与-?之前相反, 它是用来把属性变成可选项的.
    //Readonly
    //type Readonly<T> = { readonly [P in keyof T]: T[P] };
    //Mutable (未包含)
    // type Mutable < T > = {
    //   -readonly[P in keyof T]: T[P]
    // }
    //Record  该类型可以将 K 中所有的属性的值转化为 T 类型，源码实现如下：
    // type Record < K extends keyof any, T > = {
    //   [P in K]: T;
    // };
    //type T11 = Record<'a' | 'b' | 'c', Person>; // -> { a: Person; b: Person; c: Person; }
    //Pick
    //type Pick<T,K> = {[P in keyof K]:T[P]}  (我的写法,有问题!! 如果K的类型在T里面没有呢?)
    // type Pick < T, K extends keyof T > = {  (官方写法)
    //   [P in K]: T[P];
    // };
    //Exclude 将某个类型中属于另一个的类型移除掉。
    //T extends U ? X : Y
    //以上语句的意思就是 如果 T 是 U 的子类型的话，那么就会返回 X，否则返回 Y
    // 对于联合类型来说会自动分发条件，例如 T extends U ? X : Y, T 可能是 A | B 的联合类型,
    //  那实际情况就变成(A extends U ? X : Y) | (B extends U ? X : Y)
    //type Exclude<T, U> = T extends U ? never : T;
    // Extract  从 T 中提取出 U
    // type Extract<T, U> = T extends U ? T : never;
    //Omit
    //type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>;
    //type Foo = Omit<{name: string, age: number}, 'name'> // -> { age: number }
    //ReturnType 用于提取函数类型的返回值类型
    //type ReturnType<T> = T extends (...args: any[]) => infer P ? P : any;
    //NonNullable NonNullable<T> 的作用是用来过滤类型中的 null 及 undefined 类型。
    //  type NonNullable<T> = T extends null | undefined ? never : T;
    // InstanceType  InstanceType 的作用是获取构造函数类型的实例类型。
    // type InstanceType<T extends new (...args: any) => any> = T extends new (...args: any) => infer R ? R : any;
    //Parameters  Parameters<T> 的作用是用于获得函数的参数类型组成的元组类型。
    //  type Parameters<T extends (...args: any) => any> = T extends (...args: infer P) => any ? P : never;  


    //枚举的相互映射
    // enum Colors { Red, Yellow, Blue }
    // Colors['Red'] === 0 // true  从0开始递增
    // Colors[0] === 'Red' // 相互映射

    // 枚举事实上会编译成如下
    var Color;
    (function (Color) {
      Color[Color["Red"] = 0] = "Red";
      Color[Color["Yellow"] = 1] = "Yellow";
      Color[Color["Blue"] = 2] = "Blue";
    })(Color || (Color = {}));

    //实现一个对象被for of 遍历
    // let es6 = {
    // edition: 6,
    // committee: "TC39",
    // standard: "ECMA-262"
    // };

    // for (let e in es6) {
    // console.log(e);
    // }
    // // edition
    // // committee
    // // standard

    // for (let e of es6) {
    // console.log(e);
    // }
    // // TypeError: es6[Symbol.iterator] is not a function
    //方法1:
    for (var key of Object.keys(someObject)) {
      console.log(key + ': ' + someObject[key]);
    }
    //方法2:
    function* entries(obj) {
      for (let key of Object.keys(obj)) {
        yield [key, obj[key]];
      }
    }
    for (let [key, value] of entries(obj)) {
      console.log(key, '->', value);
    }

    var myObject = {
      a: 1,
      b: 2,
      c: 3
    };

    //方法3：简单写法
    myObject[Symbol.iterator] = function () {
      const _this = this
      //也可使用: keys = Object.getOwnPropertyNames(this)
      const keys = Object.keys(this)
      let index = 0
      return {
        next() {
          return {
            value: _this[keys[index++]],
            done: index > keys.length
          }
        }
      }
    }

    //方法3：标准写法，可以指定属性描述符
    Object.defineProperty(myObject, Symbol.iterator, {
      enumerable: false,
      writable: false,
      configurable: true,
      value: function () {
        const _this = this
        //也可使用: keys = Object.getOwnPropertyNames(this)
        const keys = Object.keys(this)
        let index = 0
        return {
          next() {
            return {
              value: _this[keys[index++]],
              done: index > keys.length
            }
          }
        }
      }
    });

    //方法3: 手动遍历 myObject
    var it = myObject[Symbol.iterator]();
    it.next(); // { value:1, done:false }
    it.next(); // { value:2, done:false }
    it.next(); // { value:3, done:false }
    it.next(); // { value:undefined, done:true }

    //方法3: 用 for..of 遍历 myObject
    //不要指望遍历结果总是(1，2，3)，因为Object.keys()的无序性
    for (var v of myObject) {
      console.log(v);
    }
    // 1
    // 2
    // 3

    //Object.defineProperty(obj, prop, descriptor)
    // var obj = new Object();
    // Object.defineProperty(obj, 'name', {
    //   configurable: false,
    //   writable: true,
    //   enumerable: true,
    //   value: '张三'
    // })
    // console.log(obj.name)  //张三
    //Object.defineProperties()
    // var obj = new Object();
    // Object.defineProperties(obj, {
    //   name: {
    //     value: '张三',
    //     configurable: false,
    //     writable: true,
    //     enumerable: true
    //   },
    //   age: {
    //     value: 18,
    //     configurable: true
    //   }
    // })
    // console.log(obj.name, obj.age) // 张三, 18
    //Object.getOwnPropertyDescriptor()
    //     var person = {
    //     name: '张三',
    //     age: 18
    // }

    // var desc = Object.getOwnPropertyDescriptor(person, 'name'); 
    // console.log(desc)  结果如下
    // {
    //     configurable: true,
    //     enumerable: true,
    //     writable: true,
    //     value: "张三"
    // }

    //Object. getOwnPropertyDescriptors()
    // var person = {
    //     name: '张三',
    //     age: 18
    // }
    // var desc = Object.getOwnPropertyDescriptors(person, 'name');
    // console.log(desc) 
    //{
    //    configurable: true,
    //    enumerable: true,
    //    value: '张三',
    //    writable: true
    //}

    //字节跳动实现
    let a = Foo() // a.id -> 1
    let b = new Foo() // b.id -> 2
    let c = new Foo() // c.id -> 3
    let d = Foo() // d.id -> 4
    const Foo = (function () {
      let index = 1;
      return function () {
        if (this instanceof Foo) {
          // 使用new
          this.id = index++;
        } else {
          // 没有使用new, 直接返回一个对象
          return {
            id: index++
          }
        }
      }
    })();

    // URL处理
    // 实现效果：将地址栏中的URL中问号后面的内容变为对象的形式：http://www.baidu.com/search?name=li&age=18#student
    // =>
    // {HASH: "student", name: "li", age: "18"}
    // let str = 'http://www.baidu.com/search?name=li&age=18#student';
    // function urlQuery(str) {
    //   // 获取？和#的索引
    //   let askIndex = str.indexOf('?'),
    //     polIndex = str.indexOf('#'),
    //     askText = '',
    //     polText = '';
    //   //存储最后我们想要的结果    
    //   let obj = {};
    //   // 把# ?后面的内容给polText 和 askText
    //   polIndex != -1 ? polText = str.substring(polIndex + 1) : null;
    //   askIndex != -1 ? askText = str.substring(askIndex + 1, polIndex) : null;
    //   //存储到对象中
    //   polText ? obj['HASH'] = polText : null;
    //   if (askText) {
    //     askText.split('&').forEach((item, index) => {
    //       item = item.split('=');
    //       obj[item[0]] = item[1];
    //     });
    //   }
    //   return obj;
    // }
    // console.log(urlQuery(str));  //=> {HASH: "student", name: "li", age: "18"} 

    let str = 'http://www.baidu.com/search?name=li&age=18#student';

    function urlQuery(str) {
      let obj = {};
      //正则匹配=两边的
      //[^abc]：查找不在方括号内的字符。
      str.replace(/([^=?&#]+)=([^=?&#]+)/g, ($, $1, $2) => {
        obj[$1] = $2;
      });
      //正则匹配#后边的
      str.replace(/#([^=?&#]+)/g, ($, $1) => {
        obj['HASH'] = $1;
      });
      return obj;
    }
    console.log(urlQuery(str)); //=> {name: "li", age: "18", HASH: "student"}

    // var a = ?;
    // if (a == 1 && a == 2 && a == 3) {
    //     console.log('ok');
    // }
    //方案一 
    var a = {
      n: 0,
      toString: function () {
        return ++this.n;
      }
    }

    //方案二
    var a = [1, 2, 3];
    a.toString = a.shift;

    //方案三
    var i = 0;
    Object.defineProperty(window, 'a', {
      get() {
        //只有获取a的值，就一定会触发get方法执行
        return ++i;
      }
    })

    //验证是否是有效数字
    // 规则：
    // 开头可以有+ -
    // 整数位：
    // 如果是一位数可以是 0-9 任意数；
    // 如果是多位数，首位不可以是 0；
    // 小数位：如果有小数位，那么小数位后面至少有一位数字，也可以没有小数位
    let reg = /^[+-]?(\d|[1-9]\d+)(\.\d+)?$/;
    console.log(reg.test('0.2')); //true
    console.log(reg.test('02.1')); //false
    console.log(reg.test('20.')); //false

    //正则表达式反向引用和禁止反向引用
    var s = "<h1>title<h1><p>text<p>";
    var r = /(<\/?\w+>).*\1/g;
    var a = s.match(r); //返回数组["<h1>title<h1>","<p>text<p>"]

    var s = "abc";
    var r = /(a(b(c)))/;
    var a = s.match(r); //返回数组["abc","abc","bc","c"]  

    //在正则表达式对象的 test() 方法中，以及字符串对象的 match() 和 search() 等方法中使用。在这些方法中，反向引用的值可以从 RegExp() 构造函数中获得。
    var s = "abcdefghijklmn";
    var r = /(\w)(\w)(\w)/;
    r.test(s);
    console.log(RegExp.$1); //返回第1个子表达式匹配的字符a
    console.log(RegExp.$2); //返回第2个子表达式匹配的字符b
    console.log(RegExp.$3); //返回第3个子表达式匹配的字符c

    //反向引用会占用一定的系统资源，在较长的正则表达式中，反向引用会降低匹配速度。如果分组仅仅是为了方便操作，可以禁止反向引用。
    //实现方法：在左括号的后面加上一个问号和冒号。
    var s = "abc";
    var r = /(?:\w*?)|(?:\d*?)/;
    var a = r.test(s);

    //验证密码
    // 规则：
    // 6-16 位组成
    // 必须由数字字母组成
    //必须包含大小写字母
    let reg = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[\d(a-z)(A-Z)]{6,16}$/;

    //时间格式字符串
    // 月日不足十位补零
    // 换成年月日的格式
    let time = '2020-5-27';
    String.prototype.formatTime = function formatTime(template) {
      let arr = this.match(/\d+/g).map(item => {
        return item.length < 2 ? '0' + item : item;
      });
      template = template || '{0}年{1}月{2}日 {3}时{4}分{5}秒';
      return template.replace(/\{(\d+)\}/g, (_, group) => {
        return arr[group] || "00";
      });
    };
    console.log(time.formatTime()); //=> 2020年05月27日 00时00分00秒

    //字符串中出现次数最多的字符以及次数
    let str = "hello";
    let ary = [...new Set(str.split(''))];
    let max = 0;
    let code = '';
    for (let i = 0; i < ary.length; i++) {
      //创建正则匹配字符 
      let reg = new RegExp(ary[i], 'g');
      //利用match找出对应字符在中字符串中出现的地方，取匹配的返回数组的长度，即是对应字符串出现的次数 
      let val = str.match(reg).length; //更新出现次数最高的字符与次数 
      if (val > max) {
        max = val;
        code = ary[i];
      } else if (val === max) {
        //处理不同字符出现次数相同的情况  
        code = `${code}、${ary[i]}`;
      }
    }
    console.log(`出现次数最多的字符是：${code},次数为：${max}`); //=> 出现次数最多的字符是：l,次数为：2

    //手写cookie
    // 简单分析：
    // getCookie

    // document.cookie可以获取到对应cookie的值(非httpOnly:true的情况可以拿到)
    // match匹配正则

    // 如age=41，它前面可能是空格,也可能是age为开头的字符，对应(^| )
    // key的后面跟着是=号，=号后面跟着是除了;号外的任意字符([^;]*)
    // ([^;]*)的*表示0到多次，因为会出现有key没有value值的情况
    // 最后会以;结尾或者value结尾的情况，对应(;|$)


    // 返回解码后匹配到的第2个分组，就是key对应的value值
    // 没找到就返回null

    // setCookie

    // 设置一个数组arr用来存放所有要设置的参数
    // httpOnly设置为true，通过document.cookie拿不到设置对应key的cookie
    // max-age用来设置cookie过期时间，以秒为单位
    // domain设置域名，指定域名可以接受cookie，包含子域名(如.baidu.com设置，下面子域都可以接受cookie)
    // path指定路径接受cookie(如path=/web,那么/web/fe,/web/login子路径也可以接受)
    // secure指定只能在https协议下接受cookie
    // sameSite在跨域的时候可以不发送cookie
    // document.cookie直接设置对应的key和value以及配置参数即可

    const Cookie = {
      getCookie(key) {
        let match = document.cookie.match(new RegExp('(^| )' + key + '=([^;]*)(;|$)'));

        if (match && match.length) {
          return decodeURIComponent(match[2]);
        }
        return null;
      },
      setCookie(key, value, opts = {}) {
        let arr = [];
        if (opts.httpOnly) {
          arr.push('httpOnly=true');
        }
        if (opts.maxAge) {
          arr.push(`max-age=${opts.maxAge}`);
        }
        if (opts.domain) {
          arr.push(`domain=${opts.domain}`);
        }
        if (opts.path) {
          arr.push(`path=${opts.path}`);
        }
        // secure|sameSite等就省略了
        document.cookie = `${key}=${encodeURIComponent(value)}; ${arr.join('; ')}`;
      }
    };

    //洗牌算法
    const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    const shuffle = ([...arr]) => {
      let m = arr.length;
      while (m) {
        const i = Math.floor(Math.random() * m--);
        [arr[m], arr[i]] = [arr[i], arr[m]];
      }
      return arr;
    };
    console.log(shuffle(arr))
    // [10, 9, 7, 5, 6, 4, 1, 2, 8, 3]

    //实现promise
    const PENDING = "pending";
    const FULFILLED = "fulfilled";
    const REJECTED = "rejected";

    function Promise(excutor) {
      let that = this; // 缓存当前promise实例对象
      that.status = PENDING; // 初始状态
      that.value = undefined; // fulfilled状态时 返回的信息
      that.reason = undefined; // rejected状态时 拒绝的原因
      that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
      that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数

      function resolve(value) { // value成功态时接收的终值
        if (value instanceof Promise) {
          return value.then(resolve, reject);
        }
        // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。
        setTimeout(() => {
          // 调用resolve 回调对应onFulfilled函数
          if (that.status === PENDING) {
            // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject)
            that.status = FULFILLED;
            that.value = value;
            that.onFulfilledCallbacks.forEach(cb => cb(that.value));
          }
        });
      }

      function reject(reason) { // reason失败态时接收的拒因
        setTimeout(() => {
          // 调用reject 回调对应onRejected函数
          if (that.status === PENDING) {
            // 只能由pending状态 => rejected状态 (避免调用多次resolve reject)
            that.status = REJECTED;
            that.reason = reason;
            that.onRejectedCallbacks.forEach(cb => cb(that.reason));
          }
        });
      }

      // 捕获在excutor执行器中抛出的异常
      // new Promise((resolve, reject) => {
      //  throw new Error('error in excutor')
      // })
      try {
        excutor(resolve, reject);
      } catch (e) {
        reject(e);
      }
    }

    Promise.prototype.then = function (onFulfilled, onRejected) {
      const that = this;
      let newPromise;
      // 处理参数默认值 保证参数后续能够继续执行
      onFulfilled =
        typeof onFulfilled === "function" ? onFulfilled : value => value;
      onRejected =
        typeof onRejected === "function" ? onRejected : reason => {
          throw reason;
        };
      if (that.status === FULFILLED) { // 成功态
        return newPromise = new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              let x = onFulfilled(that.value);
              resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值
            } catch (e) {
              reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected);
            }
          });
        })
      }

      if (that.status === REJECTED) { // 失败态
        return newPromise = new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              let x = onRejected(that.reason);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          });
        });
      }

      if (that.status === PENDING) { // 等待态
        // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
        return newPromise = new Promise((resolve, reject) => {
          that.onFulfilledCallbacks.push((value) => {
            try {
              let x = onFulfilled(value);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          });
          that.onRejectedCallbacks.push((reason) => {
            try {
              let x = onRejected(reason);
              resolvePromise(newPromise, x, resolve, reject);
            } catch (e) {
              reject(e);
            }
          });
        });
      }
    };

    //实现阶乘
    // function factorial(num, total) {
    //   if (num < 0) {
    //     throw new Error('负数没有阶乘')
    //   }
    //   if (num === 1 || num === 0) {
    //     return total
    //   }
    //   return factorial(num - 1, total * num)
    // }

    // factorial(6) //6
    //尾调用版
    function factorial(num, total = 1) {
      if (num < 0) {
        throw new Error('负数没有阶乘')
      }
      if (num === 1 || num === 0) {
        return total
      }
      return factorial(num - 1, total * num)
    }

    factorial(6) //6

    //js中只有词法作用域，也就是说在定义时而不是执行时确定作用域。例如：
    var value = 1;

    function foo() {
      console.log(value);
    }

    function bar() {
      var value = 2;
      foo();
    }
    bar(); //1
    //复制代码注意： with和eval可以修改词法作用域
  </script>
</body>

</html>